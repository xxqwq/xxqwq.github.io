<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/12/19/2022-12-19%20%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%20copy/"/>
      <url>/2022/12/19/2022-12-19%20%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%20copy/</url>
      
        <content type="html"><![CDATA[<h1 id="这是第一篇文章"><a href="#这是第一篇文章" class="headerlink" title="这是第一篇文章"></a>这是第一篇文章</h1><h1 id="顺序：《代码随想录》"><a href="#顺序：《代码随想录》" class="headerlink" title="顺序：《代码随想录》"></a>顺序：《代码随想录》</h1><h1 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h1><h2 id="Day1-Leetcode-704二分查找"><a href="#Day1-Leetcode-704二分查找" class="headerlink" title="Day1 Leetcode 704二分查找"></a>Day1 Leetcode 704二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var search = function (nums, target) &#123;</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = nums.length - 1</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    let middle = left + Math.floor((right - left) / 2)</span><br><span class="line">    if (nums[middle] &gt; target) &#123;</span><br><span class="line">      right = middle - 1</span><br><span class="line">    &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">      left = middle + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return middle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>二分查找法是很简单的一类题目，但是经常容易写错。主要在于区间的取值以及对左右的更新</li><li>首先对于left和right的取值，需要根据区间来判断，如果左闭右闭left就取0，right取数组大小减1，如果左闭右开right得取数组的大小。</li><li>第二个点是while循环里面的条件，如果是左闭右闭的话left&lt;&#x3D;right,如果是左闭右开的话那么left&lt;right</li><li>第三个点是left、right的更新，如果左闭右闭那么更新的时候right、left就不能是middle而要是middle-1、middle+1，因为middle那个点已经不算在搜索区间里了。如果左闭右开的话right就可以是middle，因为本身middle就取不到</li></ul><h2 id="Day-1-Leetcode-27-删除元素"><a href="#Day-1-Leetcode-27-删除元素" class="headerlink" title="Day 1 Leetcode 27 删除元素"></a>Day 1 Leetcode 27 删除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//双指针法</span><br><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">let slow = 0</span><br><span class="line">for (let fast = 0; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">if (nums[fast] !== val) &#123;</span><br><span class="line">nums[slow++] = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">return slow</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//暴力求解</span><br><span class="line">var size = nums.length</span><br><span class="line">for (let i = 0; i &lt; size; i++) &#123;</span><br><span class="line">if (nums[i] === val) &#123;</span><br><span class="line">for (let j = i + 1; j &lt; size; j++) &#123;</span><br><span class="line">nums[j - 1] = nums[j]</span><br><span class="line">    &#125;</span><br><span class="line">i--</span><br><span class="line">size--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return size</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解：</p></li><li><ul><li>使用两个for循环，第一个for循环用来遍历数组，第二个for循环用来将需要删除的元素后面的所有元素都往前移动一位。</li><li>需要注意的是移动完之后数组的大小要减少（因为题目要求返回数组大小）</li></ul></li><li><p>双指针法：</p></li><li><ul><li>双指针法只需要用一个for循环，因此时间复杂度为O(N）</li><li>定义一个slow一个fast指针，slow指针用来指向新数组的下标，fast指针用来指向原数组中的元素<br>首先让fast指针往前走，当fast指针指向的不是要删除的元素的时候，slow所在位置的数据应当被fast指向的数据给覆盖掉，然后slow往前走。从而实现一个覆盖的功能</li></ul></li></ul><h2 id="Day-2-Leetcode-977-有序数组的平方"><a href="#Day-2-Leetcode-977-有序数组的平方" class="headerlink" title="Day 2 Leetcode 977 有序数组的平方"></a>Day 2 Leetcode 977 有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var sortedSquares = function (nums) &#123;</span><br><span class="line">  //暴力求解</span><br><span class="line">  let result = []</span><br><span class="line">  // for(let i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">  //     nums[i]*=nums[i]</span><br><span class="line">  // &#125;</span><br><span class="line">  // nums.sort((a,b)=&gt;&#123;return a-b&#125;)</span><br><span class="line">  // return nums</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = nums.length - 1</span><br><span class="line">  let res = nums.length - 1</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    if (nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;</span><br><span class="line">      result[res--] = nums[right] * nums[right]</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      result[res--] = nums[left] * nums[left]</span><br><span class="line">      left++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解:</p></li><li><ul><li>本题暴力求解方法很简单，将所有数组元素都平方后放入另一个数组里再进行一次排序就可以了，不过需要注意的是js里的排序方法要指定一下升序还是降序。时间复杂度为O（n+logn）</li></ul></li><li><p>双指针法:</p></li><li><ul><li>这种方法要重新定义一种数组，然后用left和right分别指向原数组的开头和结尾。当left&lt;&#x3D;right的时候，开始比较nums[left]平方和nums[right]平方的大小，并把大的放进新数组的最后。根据情况left++或者right–。时间复杂度为O(n)</li><li></li></ul></li></ul><h2 id="Day-3-Leetcode-209-长度最小的子数组"><a href="#Day-3-Leetcode-209-长度最小的子数组" class="headerlink" title="Day 3 Leetcode 209 长度最小的子数组"></a>Day 3 Leetcode 209 长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var minSubArrayLen = function (target, nums) &#123;</span><br><span class="line">    //双指针法</span><br><span class="line">    let i=0</span><br><span class="line">    let sum=0</span><br><span class="line">    let result=Infinity</span><br><span class="line">    let subL=0</span><br><span class="line">    for(let j=0;j&lt;nums.length;j++)&#123;</span><br><span class="line">        sum+=nums[j];</span><br><span class="line">        while(sum&gt;=target)&#123;</span><br><span class="line">            subL=j-i+1</span><br><span class="line">            result=Math.min(result,subL)</span><br><span class="line">            sum-=nums[i++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result===Infinity?0:result</span><br><span class="line">    //暴力求解</span><br><span class="line">    // let result = Infinity</span><br><span class="line">    // let sum = 0</span><br><span class="line">    // let subL = 0</span><br><span class="line">    // for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    //     sum = 0</span><br><span class="line">    //     for (let j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">    //         sum += nums[j]</span><br><span class="line">    //         while (sum &gt;= target) &#123;</span><br><span class="line">    //             subL = j - i + 1</span><br><span class="line">    //             result = Math.min(result, subL)</span><br><span class="line">    //             break</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return result === Infinity ? 0 : result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解：用两个for循环不断地寻找所有符合条件的子数组，时间复杂度是O(n²)</p></li><li><p>双指针法：</p></li><li><ul><li>用两个指针i和j分别指向起始位置和终止位置</li><li>首先先让j指针往后走，然后用sum记录数组元素之和，当sum符合条件的时候记录数组长度，并且和当前最小的数组长度开始比较，然后再让起始位置往后走，同时要在sum里减去去掉的元素。</li><li>这题的要点一个是for循环里写的是终止位置，另一个是起始位置什么时候走</li></ul></li></ul><h2 id="Day-4-Leetcode-59-螺旋矩阵"><a href="#Day-4-Leetcode-59-螺旋矩阵" class="headerlink" title="Day 4 Leetcode 59 螺旋矩阵"></a>Day 4 Leetcode 59 螺旋矩阵</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var generateMatrix = function (n) &#123;</span><br><span class="line">    let startx = 0, starty = 0;</span><br><span class="line">    let count = 1, offset = 1;</span><br><span class="line">    let mid = Math.floor(n / 2)</span><br><span class="line">    let loop = mid</span><br><span class="line">    let res = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line">    while (loop) &#123;</span><br><span class="line">        let row = startx, col = starty</span><br><span class="line">        for (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[startx][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        for (; col &gt; starty; col--) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        for (; row &gt; startx; row--) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        startx++</span><br><span class="line">        starty++</span><br><span class="line">        offset++</span><br><span class="line">        loop--</span><br><span class="line">    &#125;</span><br><span class="line">    if (n % 2 == 1) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29638251/1670932087977-490f8e24-b3f6-454b-9a65-2e06fe395f57.png" alt="img"></p></li><li><p>解法：</p></li><li><ul><li>本题比较重要的思想是循环不变量思想，为了防止考虑过多边界条件，每次循环的时候采用左闭右开的区间。</li><li>奇偶的情况只差最中间一位，因此只要用一个if来判断奇数的情况就可以了</li><li>用四个for循环来表示每一条边，当转完一圈之后，总圈数loop要减一，第二圈起始点的横纵坐标startx&#x2F;starty都是前一圈加一，最边上一点离本条边结束点的距离offset要增加1.</li></ul></li></ul><h1 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h1><h2 id="Day-5-Leetcode-203-移除链表元素"><a href="#Day-5-Leetcode-203-移除链表元素" class="headerlink" title="Day 5 Leetcode 203 移除链表元素"></a>Day 5 Leetcode 203 移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">  <span class="comment">//分情况删除法</span></span><br><span class="line">  <span class="comment">// let cur=head</span></span><br><span class="line">  <span class="comment">// while(head!==null&amp;&amp;head.val===val)&#123;</span></span><br><span class="line">  <span class="comment">//     head=head.next</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// while(cur!==null&amp;&amp;cur.next!==null)&#123;</span></span><br><span class="line">  <span class="comment">//     if(cur.next.val===val)&#123;</span></span><br><span class="line">  <span class="comment">//         cur.next=cur.next.next</span></span><br><span class="line">  <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">  <span class="comment">//         cur=cur.next</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//虚拟头结点法</span></span><br><span class="line">  <span class="keyword">const</span> virnode=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="literal">null</span>,head)</span><br><span class="line">  <span class="keyword">let</span> cur=virnode<span class="comment">//记录头结点的位置</span></span><br><span class="line">  <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span>===val)&#123;</span><br><span class="line">      cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur=cur.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> virnode.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：分情况讨论</p></li><li><ul><li>分情况讨论主要分的是头结点和普通结点，这里的头结点是一个真正的结点，有自己的next指针和val</li></ul></li><li><p>解法二：虚拟头结点法</p></li><li><ul><li>这种解法省去了分情况讨论，将两种情况合在一起。</li><li>首先定义一个虚拟头结点指向原本的head结点（这里可能和我平时理解的头结点一样）</li><li>之后所有的操作和解法一的删除普通结点方法一样</li><li>需要注意的是最后返回的应该是虚拟头结点的下一个位置。</li></ul></li></ul><h2 id="Day-6-Leetcode-707-设计链表"><a href="#Day-6-Leetcode-707-设计链表" class="headerlink" title="Day 6 Leetcode 707 设计链表"></a>Day 6 Leetcode 707 设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/submissions/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">var MyLinkedList = function() &#123;</span></span><br><span class="line"><span class="comment">    this._size = 0;</span></span><br><span class="line"><span class="comment">    this._tail = null;</span></span><br><span class="line"><span class="comment">    this._head = null;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the value of the index-th node in the linked list. If the index is invalid, return -1. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getNode</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">_head</span>);</span><br><span class="line">    <span class="comment">// 0 -&gt; head</span></span><br><span class="line">    <span class="keyword">while</span>(index-- &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index).<span class="property">val</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtHead</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, <span class="variable language_">this</span>.<span class="property">_head</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Append a node of value val to the last element of the linked list. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtTail</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span>.<span class="property">next</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtIndex</span> = <span class="keyword">function</span>(<span class="params">index, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index - <span class="number">1</span>);</span><br><span class="line">    node.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, node.<span class="property">next</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete the index-th node in the linked list, if the index is valid. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteAtIndex</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_head</span> = <span class="variable language_">this</span>.<span class="property">_head</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span> - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_tail</span> = <span class="variable language_">this</span>.<span class="property">_head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index - <span class="number">1</span>);    </span><br><span class="line">    node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyLinkedList()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>虚拟头结点的运用</li><li>主要就是边界条件的判断</li><li>注意：在第n个节点前插入节点要注意：current要指向虚拟头节点</li></ul><h2 id="Day-6-Leetcode-206-反转链表"><a href="#Day-6-Leetcode-206-反转链表" class="headerlink" title="Day 6 Leetcode 206 反转链表"></a>Day 6 Leetcode 206 反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">var</span> reverse=<span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!cur) <span class="keyword">return</span> pre</span><br><span class="line">     <span class="keyword">const</span> temp=cur.<span class="property">next</span></span><br><span class="line">     cur.<span class="property">next</span>=pre</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">reverse</span>(cur,temp)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">//双指针法</span></span><br><span class="line">    <span class="comment">// if(!head||!head.next) return head</span></span><br><span class="line">    <span class="comment">// let cur=head,pre=null,temp=null</span></span><br><span class="line">    <span class="comment">// while(cur)&#123;</span></span><br><span class="line">    <span class="comment">//     temp=cur.next</span></span><br><span class="line">    <span class="comment">//     cur.next=pre</span></span><br><span class="line">    <span class="comment">//     pre=cur</span></span><br><span class="line">    <span class="comment">//     cur=temp</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return pre</span></span><br><span class="line">    <span class="comment">//递归法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(<span class="literal">null</span>,head)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法：</p></li><li><ul><li>双指针法要定义两个指针，一个是pre一个是cur，cur指向的是第一个节点，pre的初始指向是null。</li><li>然后先要保存下来cur.next，因为接下来要将cur.next的指向翻转</li><li>反转后先移动pre到cur的位置再把cur移到之前的cur.next的位置，这样就完成了一个结点的反转</li><li>当cur为null的时候，也就是pre移动到了最后一个结点处，这个时候返回pre就可以了</li></ul></li><li><p>解法二：递归法：</p></li><li><ul><li>递归法和双指针法差不多，都需要定义两个指针来反转，但是递归法需要另外一个函数，并且在函数结束的时候返回这个函数，但是参数变为反转后的pre和cur</li></ul></li></ul><h2 id="Day-7-Leetcode-24-两两交换链表中的节点"><a href="#Day-7-Leetcode-24-两两交换链表中的节点" class="headerlink" title="Day 7 Leetcode 24 两两交换链表中的节点"></a>Day 7 Leetcode 24 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> cur=vhead</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>&amp;&amp;cur.<span class="property">next</span>.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=cur.<span class="property">next</span></span><br><span class="line">        <span class="keyword">let</span> temp1=cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span>=temp</span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span>=temp1</span><br><span class="line">        cur=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vhead.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>本题依然要使用虚拟头结点，这样可以省去对头结点的单独判断</li><li>首先要让cur指向虚拟头结点</li><li>这道题要注意的一点是判断循环结束的条件，也就是要清楚想要反转两个结点，必须把cur指向两个结点之前的那个结点，因此循环结束条件就是cur.next不为null并且cur.next.next不为空，这样可以保证cur之后有两个结点来反转。注意：必须要把cur.next不为空写在前面，因为&amp;&amp;有“短路”，如果cur.next.next先为空的话就少判断一个结点了</li><li>之后用temp，temp1分别保存下第一个结点和第三个结点</li><li>cur.next&#x3D;cur.next.next</li><li>cur.next.next&#x3D;temp</li><li>cur.next.next.next&#x3D;temp1完成反转</li><li>最后不要忘记把cur往后移动两位</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29638251/1671247398670-b71e4a31-17fa-4c91-9ddf-633d8e8719b6.jpeg" alt="img"></p><h2 id="Day-7-Leetcode-19-删除链表倒数第N个结点"><a href="#Day-7-Leetcode-19-删除链表倒数第N个结点" class="headerlink" title="Day 7 Leetcode 19 删除链表倒数第N个结点"></a>Day 7 Leetcode 19 删除链表倒数第N个结点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> fast=vhead</span><br><span class="line">    <span class="keyword">let</span> slow=vhead</span><br><span class="line">    n++</span><br><span class="line">    <span class="keyword">while</span>(n--&amp;&amp;fast!==<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast!==<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span></span><br><span class="line">        slow=slow.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow.<span class="property">next</span>=slow.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    <span class="keyword">return</span> vhead.<span class="property">next</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> cur=vhead</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        cur=cur.<span class="property">next</span></span><br><span class="line">        x++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x===n)&#123;</span><br><span class="line">        head=head.<span class="property">next</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;x-n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur=cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法</p></li><li><ul><li>本题使用了虚拟头结点和双指针法</li><li>删除操作很容易，就是让需要删除的元素target前一个元素slow的next不指向target而是指向target.next。本题主要的问题就是在寻找target前一个元素</li><li>双指针法定义了一个slow，一个fast指针，先让fast前进n+1步然后slow和fast一起走，这样当fast走完链表到null的时候，slow刚好指向target的前一个元素</li><li>这里要注意让fast前进n+1步，可以先让n++，再进行循环，也可以在fast走完n步之后再走一步,即fast&#x3D;fast.next</li></ul></li><li><p>解法二：判断结点数法</p></li><li><ul><li>这种解法的思路就是，通过找出要删除的那个数处于正数的第几位来删除</li><li>首先要知道整个链表的长度，需要用一个循环来找出。</li><li>注意：当n与链表长度相等时，说明要删除的是头结点，只需要让头结点等于下一个结点就可以</li><li>找到链表长度后，从头开始遍历，找到第length-n-1个元素，也就是要删除的元素前一个元素，接着进行删除就可以了</li></ul></li></ul><h2 id="Day-7-Leetcode-142-环形链表"><a href="#Day-7-Leetcode-142-环形链表" class="headerlink" title="Day 7 Leetcode 142 环形链表"></a>Day 7 Leetcode 142 环形链表</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.<span class="property">next</span>)<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> slow = head,fast=head</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        slow = slow.<span class="property">next</span></span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            <span class="keyword">let</span> index1 = fast</span><br><span class="line">            <span class="keyword">let</span> index2 = head</span><br><span class="line">            <span class="keyword">while</span> (index1 !== index2) &#123;</span><br><span class="line">                index1 = index1.<span class="property">next</span></span><br><span class="line">                index2 = index2.<span class="property">next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题有两个难点，一个难点是判断有没有环，另一个难点是找到环的入口</li><li>第一个难点的解决办法是用两个指针，一个slow一次移动一格，一个fast一次移动两格，如果他们能相遇，那么一定存在环，反之则不存在环。因为fast指针相对于slow指针速度为1，相当于slow静止，二fast以速度为1追赶slow。</li><li>第二个难点的解决办法涉及到数学公式，设头结点到环入口有x个结点，环入口到fast和slow相遇处有y个结点，环中剩余结点数为z。</li><li>相遇时，fast走过：x+y+n(y+z),slow走过:x+y,因为fast指针速度是slow的两倍，因此fast走过的结点数也是slow的两倍-&gt;2*(x+y)&#x3D;x+y+n(y+z);由此可得  x &#x3D; (n - 1) (y + z) + z</li><li>这样也就是从头结点和相遇处各有一个指针出发，他们一定会在入口处相遇。</li><li><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29638251/1671273801106-e56f126d-4bc3-4f87-82ed-49fb320e1458.jpeg" alt="img"></li></ul></li></ul><h2 id="Day-8-剑指offer-35-复杂链表的复制"><a href="#Day-8-剑指offer-35-复杂链表的复制" class="headerlink" title="Day 8 剑指offer 35 复杂链表的复制"></a>Day 8 剑指offer 35 复杂链表的复制</h2><p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, next, random) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(node.<span class="property">val</span>, node.<span class="property">next</span>)</span><br><span class="line">        node = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node.<span class="property">next</span>.<span class="property">random</span> = node.<span class="property">random</span> ? node.<span class="property">random</span>.<span class="property">next</span>: <span class="literal">null</span></span><br><span class="line">        node = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode = head.<span class="property">next</span>, res = newNode</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">next</span> &amp;&amp; newNode.<span class="property">next</span>) &#123;</span><br><span class="line">        node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        newNode.<span class="property">next</span> = newNode.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">        newNode = newNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：</li></ul><ol><li>首先遍历原链表，在每个节点后面复制一个新节点。这样原链表和新链表就形成了一个“拼接”的形式，如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原链表：    A -&gt; B -&gt; C -&gt; D </span><br><span class="line">新链表： A&#x27;-&gt; A -&gt; B&#x27;-&gt; B -&gt; C&#x27;-&gt; C -&gt; D&#x27;-&gt; D</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29638251/1671334766865-bd365a5f-6940-474e-8ea9-e8fc29f0f21c.jpeg" alt="img"></p><ol><li>然后再次遍历原链表，根据原链表中每个节点的 random 指针，为新链表中对应的节点建立 random 指针。由于原链表和新链表是“拼接”在一起的，因此可以通过每个节点的 next 指针来访问新链表中的节点。</li><li>最后再次遍历原链表，将原链表和新链表从中间“拆分”开来，即将原链表中的每个节点的 next 指针指向原链表的下一个节点，将新链表中的每个节点的 next 指针指向新链表的下一个节点。最终得到的就是两个独立的链表：原链表和新链表。</li></ol><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="Day-9-Leetcode-242-有效的字母异位词"><a href="#Day-9-Leetcode-242-有效的字母异位词" class="headerlink" title="Day 9 Leetcode 242 有效的字母异位词"></a>Day 9 Leetcode 242 有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span> (<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> !== t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> record = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> a=<span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        record[s[i].<span class="title function_">charCodeAt</span>() - a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        record[t[i].<span class="title function_">charCodeAt</span>() - a]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i] !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>本题用哈希法进行解题，思路就是用一个数组来记录每个字母重复的次数</li><li>先遍历第一个字符串，遇到字符就在record数组中对应的位置加一记录下</li><li>之后遍历第二个，遇到字符后再record数组中对应的位置减一来记录</li><li>最后遍历record，如果出现不为0的位置证明两个字符串所含字母不一定相同</li><li>注意：js里获取字符串的ascii码必须要用charCodeAt（）方法</li></ul></li></ul><h2 id="Day-10-Leetcode-349-两个数组的交集"><a href="#Day-10-Leetcode-349-两个数组的交集" class="headerlink" title="Day 10 Leetcode 349 两个数组的交集"></a>Day 10 Leetcode 349 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/submissions/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums1.<span class="property">length</span>&lt;nums2.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t=nums1</span><br><span class="line">        nums1=nums2</span><br><span class="line">        nums2=t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hash=<span class="keyword">new</span> <span class="title class_">Set</span>(nums1)</span><br><span class="line">    <span class="keyword">const</span> res=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums2.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(nums2[i]))&#123;</span><br><span class="line">            res.<span class="title function_">add</span>(nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(res)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题主要要注意返回的是一个不含重复数字的数组，因此可以使用set来保证没有重复，最后转换成数组就可以了</li><li>先找到比较大的那个数组，然后让这个数组转成hash表（set结构）这样的话只需要用另一个数组中的元素来和这个hash表来判断有没有重复就可以了，有重复就加到res这个表中</li><li>注意：只有当数值比较小的时候才能用数组做哈希表</li></ul></li></ul><h2 id="Day-10-Leetcode-202-快乐数"><a href="#Day-10-Leetcode-202-快乐数" class="headerlink" title="Day 10 Leetcode  202 快乐数"></a>Day 10 Leetcode  202 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        sum += (num % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> ()</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="title function_">has</span>(n))<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(n===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        m.<span class="title function_">set</span>(n,<span class="number">1</span>)</span><br><span class="line">        n=<span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>当出现了要快速判断一个元素是否在集合里的时候就要考虑哈希法</li><li>根据题意，首先要定义一个函数来算整个数每一位平方和</li><li>然后定义一个map，用has可以判断n是不是在里面，n已经在map中的话那么就是在无限循环。如果n不在里面的话，为map添加一个制定了key:n,value:1的键值对，最后再更新n</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        sum += (num % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> set=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">while</span>(n!==<span class="number">1</span>&amp;&amp;!set.<span class="title function_">has</span>(n))&#123;</span><br><span class="line">        set.<span class="title function_">add</span>(n)</span><br><span class="line">        n=<span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n===<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p></li><li><ul><li>用set可以保证不会有重复的元素</li><li>如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数</li></ul></li></ul><h2 id="Day-11-Leetcode-454-四数相加"><a href="#Day-11-Leetcode-454-四数相加" class="headerlink" title="Day 11 Leetcode 454 四数相加"></a>Day 11 Leetcode 454 四数相加</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>,sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> sumMap= <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n1 <span class="keyword">of</span> nums1)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> n2 <span class="keyword">of</span> nums2)&#123;</span><br><span class="line">            sum=n1+n2</span><br><span class="line">            <span class="keyword">let</span> num=sumMap.<span class="title function_">get</span>(sum)||<span class="number">0</span></span><br><span class="line">            sumMap.<span class="title function_">set</span>(sum,num+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n3 <span class="keyword">of</span> nums3)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> n4 <span class="keyword">of</span> nums4)&#123;</span><br><span class="line">            sum=n3+n4</span><br><span class="line">            count+=(sumMap.<span class="title function_">get</span>(<span class="number">0</span>-sum)||<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>用一个map来存储两个数组元素相加和的值和出现次数</li><li>首先遍历nums1、nums2，把所有元素相加，放入map里，统计出现的次数</li><li>然后遍历nums3、nums4，和为sum，在map中找到key为0-sum的元素，出现的次数value即为所要求值。</li><li>两个两个遍历是为了减少时间复杂度。</li></ul></li></ul><h2 id="Day-12-Leetcode-15-三数之和"><a href="#Day-12-Leetcode-15-三数之和" class="headerlink" title="Day 12 Leetcode 15 三数之和"></a>Day 12 Leetcode 15 三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a - b &#125;)</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>, res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125;</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法</p></li><li><ul><li>这道题不太适合用哈希法来做，因为需要去重</li><li>首先将数组排序，然后开始遍历数组</li><li>注意点一：如果nums[i]已经大于0的话，说明后面不会有合适的元素了，因此直接返回res</li><li>去重一：如果nums[i]&#x3D;&#x3D;&#x3D;nums[i-1]就代表之前出现过这个元素，因此不管这个组合直接continue</li><li>注意点二：这里不用nums[i+1]的原因是因为会影响到left的取值</li><li>之后开始算三数之和，如果三数之和大于0说明数字大了，那么移动right–，如果小于0说明数字笑了，那么移动left++。如果刚好等于0，说明是符合条件的三元组，那么就将三个数放到数组里</li><li>去重二：如果nums[left&#x2F;right]&#x3D;&#x3D;&#x3D;nums[left+1&#x2F;right+1]那么说明left&#x2F;right要重复了，就移动对应的指针</li><li>正常情况还要移动一下指针</li></ul></li></ul><h2 id="Day-12-Leetcode-18-四数之和"><a href="#Day-12-Leetcode-18-四数之和" class="headerlink" title="Day 12 Leetcode 18 四数之和"></a>Day 12 Leetcode 18 四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">return</span> []</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; target &gt; <span class="number">0</span>) <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] + nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l = j + <span class="number">1</span>, r = len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123; l++ &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123; r-- &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题和三数之和的方法类似，但要注意去重的地方有些不同</li><li>在第一个循环的时候要进行第一次剪枝</li><li>第一次剪枝要判断nums[i]是不是大于0，因为负数相加可以变小</li><li>第二次循环的时候要进行第二次剪枝</li><li>第二次剪枝吧nums[i]和nums[j]当做一个整体来判断</li><li>注意：这里和三数之和不同的地方在于：target可以是负数，这样的话进行驱虫的时候</li></ul></li></ul><h2 id="Day-12-Leetcode-383-赎金信"><a href="#Day-12-Leetcode-383-赎金信" class="headerlink" title="Day 12 Leetcode 383 赎金信"></a>Day 12 Leetcode 383 赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">ransomNote</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">magazine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="keyword">function</span> (<span class="params">ransomNote, magazine</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashArr=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> a=<span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> magazine)&#123;</span><br><span class="line">        hashArr[i.<span class="title function_">charCodeAt</span>()-a]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> ransomNote)&#123;</span><br><span class="line">        <span class="keyword">const</span> index=i.<span class="title function_">charCodeAt</span>()-a</span><br><span class="line">        <span class="keyword">if</span>(!hashArr[index])<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        hashArr[index]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题直接用哈希法</li><li>用一个数组存储26个字母</li><li>然后遍历magazine字符串，把出现的数字次数记下来</li><li>然后遍历ransomNote字符串，记录对应的字母的ascii值，然后看hashArr里有没有，没有的话说明ransomNote有magazine里面没有的字母，直接返回false；有的话把数组的对应位置减一</li></ul></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="Day-13-Leetcode-344-反转字符串"><a href="#Day-13-Leetcode-344-反转字符串" class="headerlink" title="Day 13 Leetcode 344 反转字符串"></a>Day 13 Leetcode 344 反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len=s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=len-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">      <span class="comment">// 解法一</span></span><br><span class="line">        <span class="comment">// let t=s[l]</span></span><br><span class="line">        <span class="comment">// s[l]=s[r]</span></span><br><span class="line">        <span class="comment">// s[r]=t</span></span><br><span class="line">      <span class="comment">//解法二：解构赋值</span></span><br><span class="line">        [s[l],s[r]]=[s[r],s[l]]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//解法三:s.reverse()</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题很简单，直接用双指针法，一个从左边第一个出发，一个从右边第一个出发，两个交换位置之后再分别前进&#x2F;后退就可以了</li><li>交换的时候可以定义临时变量，也可以解构赋值</li></ul></li></ul><h2 id="Day-13-Leetcode-541-反转字符串②"><a href="#Day-13-Leetcode-541-反转字符串②" class="headerlink" title="Day 13 Leetcode 541 反转字符串②"></a>Day 13 Leetcode 541 反转字符串②</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span> (<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> resArr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i - <span class="number">1</span>, r = i + k &gt; len ? len : i + k;</span><br><span class="line">        <span class="keyword">while</span> (++l &lt; --r) &#123;</span><br><span class="line">            [resArr[l], resArr[r]] = [resArr[r], resArr[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法</p></li><li><ul><li>这道题主要就是边界条件的判断</li><li>注意：循环的时候i要加2k而不是加加，这样可以减少判断</li><li>之后反转操作的时候要判断一下i+k和s.length的大小来决定反转的右边是什么位置</li></ul></li></ul><h2 id="Day-14-Leetcode-151-翻转字符串里的单词"><a href="#Day-14-Leetcode-151-翻转字符串里的单词" class="headerlink" title="Day 14 Leetcode 151 翻转字符串里的单词"></a>Day 14 Leetcode 151 翻转字符串里的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s+/g</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>直接调用api</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> strArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">   <span class="title function_">removeExtraSpaces</span>(strArr);</span><br><span class="line">   <span class="title function_">reverse</span>(strArr, <span class="number">0</span>, strArr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (strArr[i] === <span class="string">&#x27; &#x27;</span> || i === strArr.<span class="property">length</span>) &#123;</span><br><span class="line">       <span class="title function_">reverse</span>(strArr, start, i - <span class="number">1</span>);</span><br><span class="line">       start = i + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">strArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fastIndex &lt; strArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[fastIndex] === <span class="string">&#x27; &#x27;</span> &amp;&amp; (fastIndex === <span class="number">0</span> || strArr[fastIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      fastIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strArr[slowIndex++] = strArr[fastIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  strArr.<span class="property">length</span> = strArr[slowIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span> ? slowIndex - <span class="number">1</span> : slowIndex;</span><br><span class="line">  <span class="comment">//通过改变数组长度来移除末尾的空格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">strArr, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = end;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];</span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p></li><li><ul><li>这道题需要完成的功能：</li></ul></li><li><ul><li><ul><li>删除多余的空格</li><li>反转字符串</li><li>反转单词</li></ul></li></ul></li><li><ul><li>反转在前面已经实现过，这里可以额外用两个变量来定义开始和结尾，这样可以也可以实现字符串里面的单词反转</li><li>第二步是删除多余的空格，删除多余的空格用的方法是双指针法，参考前面数组题目的删除元素。</li><li>然后先将题目给的字符串变成一个数组，之后删除多余的空格，然后反转整个数组</li><li>之后用循环，当遇到空格的时候，说明一个单词便利完了，可以进行反转，最后更新一下start</li><li>最后调用js中的join方法把数组变成一个字符串就可以了</li></ul></li></ul><h2 id="Day-15-Leetcode-剑指offer-58-左旋转字符串"><a href="#Day-15-Leetcode-剑指offer-58-左旋转字符串" class="headerlink" title="Day 15 Leetcode 剑指offer 58 左旋转字符串"></a>Day 15 Leetcode 剑指offer 58 左旋转字符串</h2><h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span> (<span class="params">start, end, s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left=start,right=end</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        [s[left],s[right]]=[s[right],s[left]]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="keyword">function</span> (<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="number">0</span>,n-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="title function_">reverse</span>(n,s.<span class="property">length</span>-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="number">0</span>,s.<span class="property">length</span>-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>这道题比较简单，整体的思路就是反转三次字符串</li><li>第一次反转从开头到n-1位置的字符串</li><li>第二次反转从n到结尾的字符串</li><li>第三次反转整个字符串</li><li>这样就实现了将开头n个放到结尾的操作</li></ul></li></ul><h2 id="Day-16-KMP算法（理论）"><a href="#Day-16-KMP算法（理论）" class="headerlink" title="Day 16 KMP算法（理论）"></a>Day 16 KMP算法（理论）</h2><ul><li><p>解决问题：字符串匹配问题</p></li><li><p>以aabaabaaf和aabaaf举例</p></li><li><p>前缀：包含首字母，不包含尾字母的字符串（模式串中）</p></li><li><p>后缀：只包含尾字母，不包含首字母的字符串（模式串中）</p></li><li><p>前缀表：记录最长相等前后缀，比如a-&gt;0,aa-&gt;1,aab-&gt;0，aaba-&gt;0,aabaa-&gt;2,aabaaf-&gt;0,那么前缀表就是010020</p></li><li><p>找到最长下相等前后缀的位置，最长相等前后缀的长度也就是下标，比如aabaaf-&gt;下标为2也就是b所在的位置，从b所在的位置重新匹配</p></li><li><p>next数组 ：存放前缀表，<strong>告诉发生冲突的时候回退到哪里</strong></p></li><li><ul><li>如果右移前缀表作为next数组，那么回退的下标就是冲突的位置对应的前缀表中下标</li><li>如果直接拿前缀表作为next数组，那么回退的下标是冲突的位置前一位对应的前缀表中下标</li><li>如果统一减一后作为next数组，那么回退的下标是冲突的位置前一位对应的前缀表中下标+1…</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNext</span>(<span class="params">next,s</span>)&#123;</span><br><span class="line">  <span class="comment">//初始化next数组和遍历</span></span><br><span class="line">  <span class="keyword">let</span> j=<span class="number">0</span><span class="comment">//i指向后缀末尾位置，j指向前缀末尾位置以及i之前字串的最长相等前后缀的长度</span></span><br><span class="line">  next[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;s.<span class="property">length</span>;i++)&#123;<span class="comment">//因为在aa的时候才有前后缀，此时i为1，j为0</span></span><br><span class="line">      <span class="comment">//处理前后缀不相同的情况</span></span><br><span class="line">    <span class="keyword">while</span>(s[i]!==s[j]&amp;&amp;j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      j=next[j-<span class="number">1</span>]</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//处理前后缀相同的地方</span></span><br><span class="line">    <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新next数组的值</span></span><br><span class="line">    next[i]=j</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Day-17-Leecode-459-重复的子字符串"><a href="#Day-17-Leecode-459-重复的子字符串" class="headerlink" title="Day 17 Leecode 459 重复的子字符串"></a>Day 17 Leecode 459 重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext= <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> next=[]</span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span></span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!==s[j])&#123;</span><br><span class="line">            j=next[j-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> next=<span class="title function_">getNext</span>(s)</span><br><span class="line">    <span class="keyword">if</span>(next[next.<span class="property">length</span>-<span class="number">1</span>]!==<span class="number">0</span>&amp;&amp;s.<span class="property">length</span>%(s.<span class="property">length</span>-next[next.<span class="property">length</span>-<span class="number">1</span>])===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：KMP（时间复杂度O(m+n ))</p></li><li><ul><li>KMP解法中，找到最长相等前后缀，不相等的那一部分就是重复的最小子串（此处需要数学推导一下）</li><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li><li>如果数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// let next=getNext(s)</span></span><br><span class="line">    <span class="comment">// if(next[next.length-1]!==0&amp;&amp;s.length%(s.length-next[next.length-1])===0)return true</span></span><br><span class="line">    <span class="comment">// return false</span></span><br><span class="line">    ssArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(s+s)</span><br><span class="line">    ssArr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ssArr.<span class="title function_">splice</span>(ssArr.<span class="property">length</span>-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> ss=ssArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(ss.<span class="title function_">indexOf</span>(s)!==-<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：移动匹配(时间复杂度O(m*n))</p></li><li><ul><li>如果一个字符串是由重复子串构成，那么两个它拼接起来中间一定会有它本身这个字符串，因此可以调用库函数</li><li>注意：js里面要将字符串转化为数组，然后将第一个和最后一个字符删除（因为本身就有两个字符串本身，一定能找到本身）</li></ul></li></ul><h2 id="Day-17-Leetcode-28-找出字符串中第一个匹配项的下标"><a href="#Day-17-Leetcode-28-找出字符串中第一个匹配项的下标" class="headerlink" title="Day 17 Leetcode 28 找出字符串中第一个匹配项的下标"></a>Day 17 Leetcode 28 找出字符串中第一个匹配项的下标</h2><h4 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = []</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span> (<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="title function_">getNext</span>(needle)</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] !== needle[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] === needle[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === needle.<span class="property">length</span>)</span><br><span class="line">            <span class="keyword">return</span> (i-needle.<span class="property">length</span>+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>首先，求模式串的next数组（这串代码可以背下来)</li><li>然后从0开始遍历长的字符串，依然是分两种情况</li><li>第一种情况：s[i]和t[j]不相同的情况，这个时候j要做回退</li><li>第二种情况：s[i]和t[j]相同的情况，这个时候i、j都向前走一个</li><li>当j走到了模式串的末尾的时候，那么说明字符串中有模式串，这个时候返回i（原字符串走到的位置)-模式串长度+1</li></ul></li></ul><h2 id="Leetcode-125-验证回文串（第五届字节跳动青训营前端题目）"><a href="#Leetcode-125-验证回文串（第五届字节跳动青训营前端题目）" class="headerlink" title="Leetcode 125 验证回文串（第五届字节跳动青训营前端题目）"></a>Leetcode 125 验证回文串（第五届字节跳动青训营前端题目）</h2><h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (arr[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)||(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="number">9</span>)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> str = res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> reverArr = res.<span class="title function_">reverse</span>()</span><br><span class="line">    <span class="keyword">let</span> str1 = reverArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> res1=str.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">let</span> res2=str1.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">if</span> (res1 === res2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题比较简单，把字符串中多余的符号删除掉之后，转换成数组然后反转，用反转前的数组连接成的字符串和反转后的数组连接成的字符串比较</li></ul></li></ul><h2 id="Leetcode-3-无重复字符的最长子串（第五届字节跳动青训营前端题目）"><a href="#Leetcode-3-无重复字符的最长子串（第五届字节跳动青训营前端题目）" class="headerlink" title="Leetcode 3 无重复字符的最长子串（第五届字节跳动青训营前端题目）"></a>Leetcode 3 无重复字符的最长子串（第五届字节跳动青训营前端题目）</h2><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="title function_">includes</span>(x)) &#123;</span><br><span class="line">            queue.<span class="title function_">shift</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        queue.<span class="title function_">push</span>(x)</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, queue.<span class="property">length</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>1</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// let queue = []</span></span><br><span class="line">    <span class="comment">// let max = 0</span></span><br><span class="line">    <span class="comment">// for (const x of s) &#123;</span></span><br><span class="line">    <span class="comment">//     while (queue.includes(x)) &#123;</span></span><br><span class="line">    <span class="comment">//         queue.shift()</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     queue.push(x)</span></span><br><span class="line">    <span class="comment">//     max = Math.max(max, queue.length)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>, left = <span class="number">0</span>, right = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">            res.<span class="title function_">delete</span>(res.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">add</span>(s[right])</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, res.<span class="property">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：（滑动窗口）</p></li><li><ul><li>这道题用滑动窗口来解决，用set这个数据结构</li><li>注意：无重复字符的字串必须是<strong>连续的,否则就不是子串而是子序列</strong></li><li>如果 set中含有当前字符，就删除第一个字符,同时缩小窗口left++</li><li>如果没有含有，就添加当前值到 set上，同时把right++</li></ul></li></ul><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="Day-18-Leetcode-232-用栈实现队列"><a href="#Day-18-Leetcode-232-用栈实现队列" class="headerlink" title="Day 18 Leetcode 232 用栈实现队列"></a>Day 18 Leetcode 232 用栈实现队列</h2><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>很简单的数组应用</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>=[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size = <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">pop</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>&amp;&amp;!<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p></li><li><ul><li>用两个数组模拟栈，要实现队列的先进先出的功能，首先有一个进栈，然后当要出栈的时候，就把进栈末尾（先进来的元素）弹出并且压到出栈中，这是一个持续的过程</li></ul></li></ul><h2 id="Day-18-Leetcode-225-用队列实现栈"><a href="#Day-18-Leetcode-225-用队列实现栈" class="headerlink" title="Day 18 Leetcode 225 用队列实现栈"></a>Day 18 Leetcode 225 用队列实现栈</h2><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x=<span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>解法一：数组应用(最好不用)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法二：用一个队列模拟</p></li><li><ul><li>这道题比较简单，用一个队列实现的要点在于出栈的时候要先将队列的首元素弹出然后再放进队列末尾，这样就能模拟出栈的出栈顺序了</li></ul></li></ul><h2 id="Day-18-Leetcode-20-有效的括号"><a href="#Day-18-Leetcode-20-有效的括号" class="headerlink" title="Day 18 Leetcode 20 有效的括号"></a>Day 18 Leetcode 20 有效的括号</h2><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = s[i]</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(x!==stack.<span class="title function_">pop</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>这道题是栈的应用，js里用数组来模拟一个栈。</li><li>括号不匹配有三种情况</li><li>第一种：左括号多余</li><li>第二种：右括号多余</li><li>第三种：括号类型不匹配</li><li>从头遍历整个字符串，遇到左括号就把对应的有括号压入栈中，遇到右括号就开始和栈顶元素比较，如果相同就出栈。第一种情况在遍历完之后栈中还有元素，第二种情况是栈中美原油可匹配的元素，第三种情况是在遍历完之前栈就空了。</li><li>因此遍历完之后返回的栈如果是空的说明括号都匹配了，反之则不匹配</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">const</span> map=&#123;</span><br><span class="line">        <span class="string">&quot;&#123;&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(&quot;</span>:<span class="string">&quot;)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;[&quot;</span>:<span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x <span class="keyword">in</span> map)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(x)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[stack.<span class="title function_">pop</span>()]!==x)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：（简化版）</p></li><li><ul><li>和解法一思路一样，有一点不同的是这里压入栈的是左括号本身，用到了map的数据结构来做映射。这样的话在遍历字符串的时候就简化了一些操作。</li></ul></li></ul><h2 id="Day-18-Leetcode-1047-删除字符串中的所有相邻重复项"><a href="#Day-18-Leetcode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="Day 18 Leetcode  1047 删除字符串中的所有相邻重复项"></a>Day 18 Leetcode  1047 删除字符串中的所有相邻重复项</h2><h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="property">length</span>!==<span class="number">0</span>&amp;&amp;x===(temp=stack.<span class="title function_">pop</span>()))&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;        </span><br><span class="line">      <span class="keyword">if</span>(temp)stack.<span class="title function_">push</span>(temp)</span><br><span class="line">        <span class="comment">// if(stack.length!==0&amp;&amp;x===stack[stack.length-1])&#123;</span></span><br><span class="line">        <span class="comment">//     stack.pop()</span></span><br><span class="line">        <span class="comment">//     continue</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        stack.<span class="title function_">push</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：用栈来解决</p></li><li><ul><li>这道题用栈来解决很方便。</li><li>遍历字符串的时候先做一个判断，如果栈顶元素和当前元素相同，说明可以消掉，那么就出栈。否者就把当前元素压入栈。</li><li>因为是用数组模拟的栈，所以既可以用temp保存弹出的元素，也可以直接用数组访问元素来判断.</li><li>最后直接将栈中元素连接成字符串即可。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> str=<span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="keyword">let</span> top=-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(top===-<span class="number">1</span>||str[top]!==s[i])&#123;</span><br><span class="line">            str[++top]=s[i]<span class="comment">//进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            top--<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.<span class="property">length</span>=top+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：双指针法</p></li><li><ul><li>这道题还是用的数组的数据结构，不过用top来记录栈顶，这样直接操作一个数组，限定长度即可</li></ul></li></ul><h2 id="Day-19-Leetcode-150-逆波兰表达式求值"><a href="#Day-19-Leetcode-150-逆波兰表达式求值" class="headerlink" title="Day 19 Leetcode 150 逆波兰表达式求值"></a>Day 19 Leetcode 150 逆波兰表达式求值</h2><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span> (<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tokens.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="comment">// for (const x of tokens) &#123;</span></span><br><span class="line">    <span class="comment">//     if (isNaN(Number(x))) &#123;</span></span><br><span class="line">    <span class="comment">//         const num1 = stack.pop()</span></span><br><span class="line">    <span class="comment">//         const num2 = stack.pop()</span></span><br><span class="line">    <span class="comment">//         if (x === &#x27;+&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 + num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;-&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 - num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;*&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 * num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;/&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 / num1 | 0)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//         stack.push(Number(x))</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] === <span class="string">&#x27;+&#x27;</span> || tokens[i] === <span class="string">&#x27;-&#x27;</span> || tokens[i] === <span class="string">&#x27;*&#x27;</span> || tokens[i] === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> num1 = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">const</span> num2 = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;+&quot;</span>) stack.<span class="title function_">push</span>(num2 + num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;-&quot;</span>) stack.<span class="title function_">push</span>(num2 - num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;*&quot;</span>) stack.<span class="title function_">push</span>(num2 * num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;/&quot;</span>) stack.<span class="title function_">push</span>(num2 / num1 | <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(tokens[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题用栈解决</li><li>遍历整个字符串，遇到数字就放到栈里，遇到运算符的话就弹出栈里两个元素然后做完运算后再放回去</li><li>需要注意的是这里的除法运算<strong>向零截断</strong> ，也就是要用到“|”这个为运算符</li></ul></li></ul><h2 id="Day-20-Leecode-239-滑动窗口最大值"><a href="#Day-20-Leecode-239-滑动窗口最大值" class="headerlink" title="Day 20 Leecode 239 滑动窗口最大值"></a>Day 20 Leecode 239 滑动窗口最大值</h2><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; value &gt; back &amp;&amp; back !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>()</span><br><span class="line">                back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">pop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; value === <span class="variable language_">this</span>.<span class="title function_">front</span>()) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> myQueue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>()</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        myQueue.<span class="title function_">push</span>(nums[j++])</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(myQueue.<span class="title function_">front</span>())</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        myQueue.<span class="title function_">push</span>(nums[j])</span><br><span class="line">        myQueue.<span class="title function_">pop</span>(nums[i])</span><br><span class="line">        res.<span class="title function_">push</span>(myQueue.<span class="title function_">front</span>())</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>1</li></ul></li></ul><h2 id="Day-21-Leetcode-347-前k个高频元素"><a href="#Day-21-Leetcode-347-前k个高频元素" class="headerlink" title="Day 21 Leetcode 347 前k个高频元素"></a>Day 21 Leetcode 347 前k个高频元素</h2><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">compareFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">compareFn</span> = compareFn</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value)</span><br><span class="line">        <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> (parent &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(parent, index) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[parent]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[parent], <span class="variable language_">this</span>.<span class="property">queue</span>[index]]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> out = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">let</span> searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="keyword">while</span> (searchChild !== <span class="literal">undefined</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(index, searchChild) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[searchChild]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[searchChild], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line">            index = searchChild;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">compare</span>(<span class="params">index1, index2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index1] === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index2] === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">compareFn</span>(<span class="variable language_">this</span>.<span class="property">queue</span>[index1], <span class="variable language_">this</span>.<span class="property">queue</span>[index2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> heap = <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">            heap.<span class="title function_">push</span>(entry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">                heap.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = heap.<span class="title function_">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = heap.<span class="title function_">pop</span>()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法:</p></li><li><ul><li>这道题需要用到小顶堆和优先级队列两种数据结构</li><li>首先定义一个map来储存每个字符出现的频率</li><li>然后用一个heap来模拟小顶堆</li><li>小顶堆本质上是一种树，它有上浮和下沉的操作，因此在编写弹出和压入两个操作的时候要注意下标的变化。</li><li>小顶堆的根节点是频率最小的字符，因此每次压入之后判断小顶堆的大小并且弹出节点，最后剩下的就是需要求的数组</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 第一篇文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2022/12/19/2022-12-19%20%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/19/2022-12-19%20%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="这是第一篇文章"><a href="#这是第一篇文章" class="headerlink" title="这是第一篇文章"></a>这是第一篇文章</h1><h1 id="顺序：《代码随想录》"><a href="#顺序：《代码随想录》" class="headerlink" title="顺序：《代码随想录》"></a>顺序：《代码随想录》</h1><h1 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h1><h2 id="Day1-Leetcode-704二分查找"><a href="#Day1-Leetcode-704二分查找" class="headerlink" title="Day1 Leetcode 704二分查找"></a>Day1 Leetcode 704二分查找</h2><p><a href="https://leetcode.cn/problems/binary-search/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var search = function (nums, target) &#123;</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = nums.length - 1</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    let middle = left + Math.floor((right - left) / 2)</span><br><span class="line">    if (nums[middle] &gt; target) &#123;</span><br><span class="line">      right = middle - 1</span><br><span class="line">    &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">      left = middle + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return middle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>二分查找法是很简单的一类题目，但是经常容易写错。主要在于区间的取值以及对左右的更新</li><li>首先对于left和right的取值，需要根据区间来判断，如果左闭右闭left就取0，right取数组大小减1，如果左闭右开right得取数组的大小。</li><li>第二个点是while循环里面的条件，如果是左闭右闭的话left&lt;&#x3D;right,如果是左闭右开的话那么left&lt;right</li><li>第三个点是left、right的更新，如果左闭右闭那么更新的时候right、left就不能是middle而要是middle-1、middle+1，因为middle那个点已经不算在搜索区间里了。如果左闭右开的话right就可以是middle，因为本身middle就取不到</li></ul><h2 id="Day-1-Leetcode-27-删除元素"><a href="#Day-1-Leetcode-27-删除元素" class="headerlink" title="Day 1 Leetcode 27 删除元素"></a>Day 1 Leetcode 27 删除元素</h2><p><a href="https://leetcode.cn/problems/remove-element/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//双指针法</span><br><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">let slow = 0</span><br><span class="line">for (let fast = 0; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">if (nums[fast] !== val) &#123;</span><br><span class="line">nums[slow++] = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">return slow</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//暴力求解</span><br><span class="line">var size = nums.length</span><br><span class="line">for (let i = 0; i &lt; size; i++) &#123;</span><br><span class="line">if (nums[i] === val) &#123;</span><br><span class="line">for (let j = i + 1; j &lt; size; j++) &#123;</span><br><span class="line">nums[j - 1] = nums[j]</span><br><span class="line">    &#125;</span><br><span class="line">i--</span><br><span class="line">size--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return size</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解：</p></li><li><ul><li>使用两个for循环，第一个for循环用来遍历数组，第二个for循环用来将需要删除的元素后面的所有元素都往前移动一位。</li><li>需要注意的是移动完之后数组的大小要减少（因为题目要求返回数组大小）</li></ul></li><li><p>双指针法：</p></li><li><ul><li>双指针法只需要用一个for循环，因此时间复杂度为O(N）</li><li>定义一个slow一个fast指针，slow指针用来指向新数组的下标，fast指针用来指向原数组中的元素<br>首先让fast指针往前走，当fast指针指向的不是要删除的元素的时候，slow所在位置的数据应当被fast指向的数据给覆盖掉，然后slow往前走。从而实现一个覆盖的功能</li></ul></li></ul><h2 id="Day-2-Leetcode-977-有序数组的平方"><a href="#Day-2-Leetcode-977-有序数组的平方" class="headerlink" title="Day 2 Leetcode 977 有序数组的平方"></a>Day 2 Leetcode 977 有序数组的平方</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var sortedSquares = function (nums) &#123;</span><br><span class="line">  //暴力求解</span><br><span class="line">  let result = []</span><br><span class="line">  // for(let i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">  //     nums[i]*=nums[i]</span><br><span class="line">  // &#125;</span><br><span class="line">  // nums.sort((a,b)=&gt;&#123;return a-b&#125;)</span><br><span class="line">  // return nums</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = nums.length - 1</span><br><span class="line">  let res = nums.length - 1</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    if (nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;</span><br><span class="line">      result[res--] = nums[right] * nums[right]</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      result[res--] = nums[left] * nums[left]</span><br><span class="line">      left++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解:</p></li><li><ul><li>本题暴力求解方法很简单，将所有数组元素都平方后放入另一个数组里再进行一次排序就可以了，不过需要注意的是js里的排序方法要指定一下升序还是降序。时间复杂度为O（n+logn）</li></ul></li><li><p>双指针法:</p></li><li><ul><li>这种方法要重新定义一种数组，然后用left和right分别指向原数组的开头和结尾。当left&lt;&#x3D;right的时候，开始比较nums[left]平方和nums[right]平方的大小，并把大的放进新数组的最后。根据情况left++或者right–。时间复杂度为O(n)</li><li></li></ul></li></ul><h2 id="Day-3-Leetcode-209-长度最小的子数组"><a href="#Day-3-Leetcode-209-长度最小的子数组" class="headerlink" title="Day 3 Leetcode 209 长度最小的子数组"></a>Day 3 Leetcode 209 长度最小的子数组</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var minSubArrayLen = function (target, nums) &#123;</span><br><span class="line">    //双指针法</span><br><span class="line">    let i=0</span><br><span class="line">    let sum=0</span><br><span class="line">    let result=Infinity</span><br><span class="line">    let subL=0</span><br><span class="line">    for(let j=0;j&lt;nums.length;j++)&#123;</span><br><span class="line">        sum+=nums[j];</span><br><span class="line">        while(sum&gt;=target)&#123;</span><br><span class="line">            subL=j-i+1</span><br><span class="line">            result=Math.min(result,subL)</span><br><span class="line">            sum-=nums[i++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result===Infinity?0:result</span><br><span class="line">    //暴力求解</span><br><span class="line">    // let result = Infinity</span><br><span class="line">    // let sum = 0</span><br><span class="line">    // let subL = 0</span><br><span class="line">    // for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    //     sum = 0</span><br><span class="line">    //     for (let j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">    //         sum += nums[j]</span><br><span class="line">    //         while (sum &gt;= target) &#123;</span><br><span class="line">    //             subL = j - i + 1</span><br><span class="line">    //             result = Math.min(result, subL)</span><br><span class="line">    //             break</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return result === Infinity ? 0 : result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解：用两个for循环不断地寻找所有符合条件的子数组，时间复杂度是O(n²)</p></li><li><p>双指针法：</p></li><li><ul><li>用两个指针i和j分别指向起始位置和终止位置</li><li>首先先让j指针往后走，然后用sum记录数组元素之和，当sum符合条件的时候记录数组长度，并且和当前最小的数组长度开始比较，然后再让起始位置往后走，同时要在sum里减去去掉的元素。</li><li>这题的要点一个是for循环里写的是终止位置，另一个是起始位置什么时候走</li></ul></li></ul><h2 id="Day-4-Leetcode-59-螺旋矩阵"><a href="#Day-4-Leetcode-59-螺旋矩阵" class="headerlink" title="Day 4 Leetcode 59 螺旋矩阵"></a>Day 4 Leetcode 59 螺旋矩阵</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">题目</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var generateMatrix = function (n) &#123;</span><br><span class="line">    let startx = 0, starty = 0;</span><br><span class="line">    let count = 1, offset = 1;</span><br><span class="line">    let mid = Math.floor(n / 2)</span><br><span class="line">    let loop = mid</span><br><span class="line">    let res = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line">    while (loop) &#123;</span><br><span class="line">        let row = startx, col = starty</span><br><span class="line">        for (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[startx][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        for (; col &gt; starty; col--) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        for (; row &gt; startx; row--) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        startx++</span><br><span class="line">        starty++</span><br><span class="line">        offset++</span><br><span class="line">        loop--</span><br><span class="line">    &#125;</span><br><span class="line">    if (n % 2 == 1) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29638251/1670932087977-490f8e24-b3f6-454b-9a65-2e06fe395f57.png" alt="img"></p></li><li><p>解法：</p></li><li><ul><li>本题比较重要的思想是循环不变量思想，为了防止考虑过多边界条件，每次循环的时候采用左闭右开的区间。</li><li>奇偶的情况只差最中间一位，因此只要用一个if来判断奇数的情况就可以了</li><li>用四个for循环来表示每一条边，当转完一圈之后，总圈数loop要减一，第二圈起始点的横纵坐标startx&#x2F;starty都是前一圈加一，最边上一点离本条边结束点的距离offset要增加1.</li></ul></li></ul><h1 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h1><h2 id="Day-5-Leetcode-203-移除链表元素"><a href="#Day-5-Leetcode-203-移除链表元素" class="headerlink" title="Day 5 Leetcode 203 移除链表元素"></a>Day 5 Leetcode 203 移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">  <span class="comment">//分情况删除法</span></span><br><span class="line">  <span class="comment">// let cur=head</span></span><br><span class="line">  <span class="comment">// while(head!==null&amp;&amp;head.val===val)&#123;</span></span><br><span class="line">  <span class="comment">//     head=head.next</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// while(cur!==null&amp;&amp;cur.next!==null)&#123;</span></span><br><span class="line">  <span class="comment">//     if(cur.next.val===val)&#123;</span></span><br><span class="line">  <span class="comment">//         cur.next=cur.next.next</span></span><br><span class="line">  <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">  <span class="comment">//         cur=cur.next</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//虚拟头结点法</span></span><br><span class="line">  <span class="keyword">const</span> virnode=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="literal">null</span>,head)</span><br><span class="line">  <span class="keyword">let</span> cur=virnode<span class="comment">//记录头结点的位置</span></span><br><span class="line">  <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span>===val)&#123;</span><br><span class="line">      cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur=cur.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> virnode.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：分情况讨论</p></li><li><ul><li>分情况讨论主要分的是头结点和普通结点，这里的头结点是一个真正的结点，有自己的next指针和val</li></ul></li><li><p>解法二：虚拟头结点法</p></li><li><ul><li>这种解法省去了分情况讨论，将两种情况合在一起。</li><li>首先定义一个虚拟头结点指向原本的head结点（这里可能和我平时理解的头结点一样）</li><li>之后所有的操作和解法一的删除普通结点方法一样</li><li>需要注意的是最后返回的应该是虚拟头结点的下一个位置。</li></ul></li></ul><h2 id="Day-6-Leetcode-707-设计链表"><a href="#Day-6-Leetcode-707-设计链表" class="headerlink" title="Day 6 Leetcode 707 设计链表"></a>Day 6 Leetcode 707 设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/submissions/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">var MyLinkedList = function() &#123;</span></span><br><span class="line"><span class="comment">    this._size = 0;</span></span><br><span class="line"><span class="comment">    this._tail = null;</span></span><br><span class="line"><span class="comment">    this._head = null;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the value of the index-th node in the linked list. If the index is invalid, return -1. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getNode</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">_head</span>);</span><br><span class="line">    <span class="comment">// 0 -&gt; head</span></span><br><span class="line">    <span class="keyword">while</span>(index-- &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index).<span class="property">val</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtHead</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, <span class="variable language_">this</span>.<span class="property">_head</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Append a node of value val to the last element of the linked list. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtTail</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span>.<span class="property">next</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtIndex</span> = <span class="keyword">function</span>(<span class="params">index, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index - <span class="number">1</span>);</span><br><span class="line">    node.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, node.<span class="property">next</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete the index-th node in the linked list, if the index is valid. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteAtIndex</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_head</span> = <span class="variable language_">this</span>.<span class="property">_head</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span> - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_tail</span> = <span class="variable language_">this</span>.<span class="property">_head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index - <span class="number">1</span>);    </span><br><span class="line">    node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyLinkedList()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>虚拟头结点的运用</li><li>主要就是边界条件的判断</li><li>注意：在第n个节点前插入节点要注意：current要指向虚拟头节点</li></ul><h2 id="Day-6-Leetcode-206-反转链表"><a href="#Day-6-Leetcode-206-反转链表" class="headerlink" title="Day 6 Leetcode 206 反转链表"></a>Day 6 Leetcode 206 反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">var</span> reverse=<span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!cur) <span class="keyword">return</span> pre</span><br><span class="line">     <span class="keyword">const</span> temp=cur.<span class="property">next</span></span><br><span class="line">     cur.<span class="property">next</span>=pre</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">reverse</span>(cur,temp)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">//双指针法</span></span><br><span class="line">    <span class="comment">// if(!head||!head.next) return head</span></span><br><span class="line">    <span class="comment">// let cur=head,pre=null,temp=null</span></span><br><span class="line">    <span class="comment">// while(cur)&#123;</span></span><br><span class="line">    <span class="comment">//     temp=cur.next</span></span><br><span class="line">    <span class="comment">//     cur.next=pre</span></span><br><span class="line">    <span class="comment">//     pre=cur</span></span><br><span class="line">    <span class="comment">//     cur=temp</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return pre</span></span><br><span class="line">    <span class="comment">//递归法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(<span class="literal">null</span>,head)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法：</p></li><li><ul><li>双指针法要定义两个指针，一个是pre一个是cur，cur指向的是第一个节点，pre的初始指向是null。</li><li>然后先要保存下来cur.next，因为接下来要将cur.next的指向翻转</li><li>反转后先移动pre到cur的位置再把cur移到之前的cur.next的位置，这样就完成了一个结点的反转</li><li>当cur为null的时候，也就是pre移动到了最后一个结点处，这个时候返回pre就可以了</li></ul></li><li><p>解法二：递归法：</p></li><li><ul><li>递归法和双指针法差不多，都需要定义两个指针来反转，但是递归法需要另外一个函数，并且在函数结束的时候返回这个函数，但是参数变为反转后的pre和cur</li></ul></li></ul><h2 id="Day-7-Leetcode-24-两两交换链表中的节点"><a href="#Day-7-Leetcode-24-两两交换链表中的节点" class="headerlink" title="Day 7 Leetcode 24 两两交换链表中的节点"></a>Day 7 Leetcode 24 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> cur=vhead</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>&amp;&amp;cur.<span class="property">next</span>.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=cur.<span class="property">next</span></span><br><span class="line">        <span class="keyword">let</span> temp1=cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span>=temp</span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span>=temp1</span><br><span class="line">        cur=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vhead.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>本题依然要使用虚拟头结点，这样可以省去对头结点的单独判断</li><li>首先要让cur指向虚拟头结点</li><li>这道题要注意的一点是判断循环结束的条件，也就是要清楚想要反转两个结点，必须把cur指向两个结点之前的那个结点，因此循环结束条件就是cur.next不为null并且cur.next.next不为空，这样可以保证cur之后有两个结点来反转。注意：必须要把cur.next不为空写在前面，因为&amp;&amp;有“短路”，如果cur.next.next先为空的话就少判断一个结点了</li><li>之后用temp，temp1分别保存下第一个结点和第三个结点</li><li>cur.next&#x3D;cur.next.next</li><li>cur.next.next&#x3D;temp</li><li>cur.next.next.next&#x3D;temp1完成反转</li><li>最后不要忘记把cur往后移动两位</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29638251/1671247398670-b71e4a31-17fa-4c91-9ddf-633d8e8719b6.jpeg" alt="img"></p><h2 id="Day-7-Leetcode-19-删除链表倒数第N个结点"><a href="#Day-7-Leetcode-19-删除链表倒数第N个结点" class="headerlink" title="Day 7 Leetcode 19 删除链表倒数第N个结点"></a>Day 7 Leetcode 19 删除链表倒数第N个结点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> fast=vhead</span><br><span class="line">    <span class="keyword">let</span> slow=vhead</span><br><span class="line">    n++</span><br><span class="line">    <span class="keyword">while</span>(n--&amp;&amp;fast!==<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast!==<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span></span><br><span class="line">        slow=slow.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow.<span class="property">next</span>=slow.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    <span class="keyword">return</span> vhead.<span class="property">next</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> cur=vhead</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        cur=cur.<span class="property">next</span></span><br><span class="line">        x++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x===n)&#123;</span><br><span class="line">        head=head.<span class="property">next</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;x-n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur=cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法</p></li><li><ul><li>本题使用了虚拟头结点和双指针法</li><li>删除操作很容易，就是让需要删除的元素target前一个元素slow的next不指向target而是指向target.next。本题主要的问题就是在寻找target前一个元素</li><li>双指针法定义了一个slow，一个fast指针，先让fast前进n+1步然后slow和fast一起走，这样当fast走完链表到null的时候，slow刚好指向target的前一个元素</li><li>这里要注意让fast前进n+1步，可以先让n++，再进行循环，也可以在fast走完n步之后再走一步,即fast&#x3D;fast.next</li></ul></li><li><p>解法二：判断结点数法</p></li><li><ul><li>这种解法的思路就是，通过找出要删除的那个数处于正数的第几位来删除</li><li>首先要知道整个链表的长度，需要用一个循环来找出。</li><li>注意：当n与链表长度相等时，说明要删除的是头结点，只需要让头结点等于下一个结点就可以</li><li>找到链表长度后，从头开始遍历，找到第length-n-1个元素，也就是要删除的元素前一个元素，接着进行删除就可以了</li></ul></li></ul><h2 id="Day-7-Leetcode-142-环形链表"><a href="#Day-7-Leetcode-142-环形链表" class="headerlink" title="Day 7 Leetcode 142 环形链表"></a>Day 7 Leetcode 142 环形链表</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.<span class="property">next</span>)<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> slow = head,fast=head</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        slow = slow.<span class="property">next</span></span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            <span class="keyword">let</span> index1 = fast</span><br><span class="line">            <span class="keyword">let</span> index2 = head</span><br><span class="line">            <span class="keyword">while</span> (index1 !== index2) &#123;</span><br><span class="line">                index1 = index1.<span class="property">next</span></span><br><span class="line">                index2 = index2.<span class="property">next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题有两个难点，一个难点是判断有没有环，另一个难点是找到环的入口</li><li>第一个难点的解决办法是用两个指针，一个slow一次移动一格，一个fast一次移动两格，如果他们能相遇，那么一定存在环，反之则不存在环。因为fast指针相对于slow指针速度为1，相当于slow静止，二fast以速度为1追赶slow。</li><li>第二个难点的解决办法涉及到数学公式，设头结点到环入口有x个结点，环入口到fast和slow相遇处有y个结点，环中剩余结点数为z。</li><li>相遇时，fast走过：x+y+n(y+z),slow走过:x+y,因为fast指针速度是slow的两倍，因此fast走过的结点数也是slow的两倍-&gt;2*(x+y)&#x3D;x+y+n(y+z);由此可得  x &#x3D; (n - 1) (y + z) + z</li><li>这样也就是从头结点和相遇处各有一个指针出发，他们一定会在入口处相遇。</li><li><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29638251/1671273801106-e56f126d-4bc3-4f87-82ed-49fb320e1458.jpeg" alt="img"></li></ul></li></ul><h2 id="Day-8-剑指offer-35-复杂链表的复制"><a href="#Day-8-剑指offer-35-复杂链表的复制" class="headerlink" title="Day 8 剑指offer 35 复杂链表的复制"></a>Day 8 剑指offer 35 复杂链表的复制</h2><p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, next, random) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(node.<span class="property">val</span>, node.<span class="property">next</span>)</span><br><span class="line">        node = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node.<span class="property">next</span>.<span class="property">random</span> = node.<span class="property">random</span> ? node.<span class="property">random</span>.<span class="property">next</span>: <span class="literal">null</span></span><br><span class="line">        node = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode = head.<span class="property">next</span>, res = newNode</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">next</span> &amp;&amp; newNode.<span class="property">next</span>) &#123;</span><br><span class="line">        node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        newNode.<span class="property">next</span> = newNode.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">        newNode = newNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：</li></ul><ol><li>首先遍历原链表，在每个节点后面复制一个新节点。这样原链表和新链表就形成了一个“拼接”的形式，如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原链表：    A -&gt; B -&gt; C -&gt; D </span><br><span class="line">新链表： A&#x27;-&gt; A -&gt; B&#x27;-&gt; B -&gt; C&#x27;-&gt; C -&gt; D&#x27;-&gt; D</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29638251/1671334766865-bd365a5f-6940-474e-8ea9-e8fc29f0f21c.jpeg" alt="img"></p><ol><li>然后再次遍历原链表，根据原链表中每个节点的 random 指针，为新链表中对应的节点建立 random 指针。由于原链表和新链表是“拼接”在一起的，因此可以通过每个节点的 next 指针来访问新链表中的节点。</li><li>最后再次遍历原链表，将原链表和新链表从中间“拆分”开来，即将原链表中的每个节点的 next 指针指向原链表的下一个节点，将新链表中的每个节点的 next 指针指向新链表的下一个节点。最终得到的就是两个独立的链表：原链表和新链表。</li></ol><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="Day-9-Leetcode-242-有效的字母异位词"><a href="#Day-9-Leetcode-242-有效的字母异位词" class="headerlink" title="Day 9 Leetcode 242 有效的字母异位词"></a>Day 9 Leetcode 242 有效的字母异位词</h2><p><a href="https://leetcode.cn/problems/valid-anagram/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span> (<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> !== t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> record = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> a=<span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        record[s[i].<span class="title function_">charCodeAt</span>() - a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        record[t[i].<span class="title function_">charCodeAt</span>() - a]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i] !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>本题用哈希法进行解题，思路就是用一个数组来记录每个字母重复的次数</li><li>先遍历第一个字符串，遇到字符就在record数组中对应的位置加一记录下</li><li>之后遍历第二个，遇到字符后再record数组中对应的位置减一来记录</li><li>最后遍历record，如果出现不为0的位置证明两个字符串所含字母不一定相同</li><li>注意：js里获取字符串的ascii码必须要用charCodeAt（）方法</li></ul></li></ul><h2 id="Day-10-Leetcode-349-两个数组的交集"><a href="#Day-10-Leetcode-349-两个数组的交集" class="headerlink" title="Day 10 Leetcode 349 两个数组的交集"></a>Day 10 Leetcode 349 两个数组的交集</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/submissions/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums1.<span class="property">length</span>&lt;nums2.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t=nums1</span><br><span class="line">        nums1=nums2</span><br><span class="line">        nums2=t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hash=<span class="keyword">new</span> <span class="title class_">Set</span>(nums1)</span><br><span class="line">    <span class="keyword">const</span> res=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums2.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(nums2[i]))&#123;</span><br><span class="line">            res.<span class="title function_">add</span>(nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(res)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题主要要注意返回的是一个不含重复数字的数组，因此可以使用set来保证没有重复，最后转换成数组就可以了</li><li>先找到比较大的那个数组，然后让这个数组转成hash表（set结构）这样的话只需要用另一个数组中的元素来和这个hash表来判断有没有重复就可以了，有重复就加到res这个表中</li><li>注意：只有当数值比较小的时候才能用数组做哈希表</li></ul></li></ul><h2 id="Day-10-Leetcode-202-快乐数"><a href="#Day-10-Leetcode-202-快乐数" class="headerlink" title="Day 10 Leetcode  202 快乐数"></a>Day 10 Leetcode  202 快乐数</h2><p><a href="https://leetcode.cn/problems/happy-number/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        sum += (num % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> ()</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="title function_">has</span>(n))<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(n===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        m.<span class="title function_">set</span>(n,<span class="number">1</span>)</span><br><span class="line">        n=<span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>当出现了要快速判断一个元素是否在集合里的时候就要考虑哈希法</li><li>根据题意，首先要定义一个函数来算整个数每一位平方和</li><li>然后定义一个map，用has可以判断n是不是在里面，n已经在map中的话那么就是在无限循环。如果n不在里面的话，为map添加一个制定了key:n,value:1的键值对，最后再更新n</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        sum += (num % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> set=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">while</span>(n!==<span class="number">1</span>&amp;&amp;!set.<span class="title function_">has</span>(n))&#123;</span><br><span class="line">        set.<span class="title function_">add</span>(n)</span><br><span class="line">        n=<span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n===<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p></li><li><ul><li>用set可以保证不会有重复的元素</li><li>如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数</li></ul></li></ul><h2 id="Day-11-Leetcode-454-四数相加"><a href="#Day-11-Leetcode-454-四数相加" class="headerlink" title="Day 11 Leetcode 454 四数相加"></a>Day 11 Leetcode 454 四数相加</h2><p><a href="https://leetcode.cn/problems/4sum-ii/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>,sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> sumMap= <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n1 <span class="keyword">of</span> nums1)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> n2 <span class="keyword">of</span> nums2)&#123;</span><br><span class="line">            sum=n1+n2</span><br><span class="line">            <span class="keyword">let</span> num=sumMap.<span class="title function_">get</span>(sum)||<span class="number">0</span></span><br><span class="line">            sumMap.<span class="title function_">set</span>(sum,num+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n3 <span class="keyword">of</span> nums3)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> n4 <span class="keyword">of</span> nums4)&#123;</span><br><span class="line">            sum=n3+n4</span><br><span class="line">            count+=(sumMap.<span class="title function_">get</span>(<span class="number">0</span>-sum)||<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>用一个map来存储两个数组元素相加和的值和出现次数</li><li>首先遍历nums1、nums2，把所有元素相加，放入map里，统计出现的次数</li><li>然后遍历nums3、nums4，和为sum，在map中找到key为0-sum的元素，出现的次数value即为所要求值。</li><li>两个两个遍历是为了减少时间复杂度。</li></ul></li></ul><h2 id="Day-12-Leetcode-15-三数之和"><a href="#Day-12-Leetcode-15-三数之和" class="headerlink" title="Day 12 Leetcode 15 三数之和"></a>Day 12 Leetcode 15 三数之和</h2><p><a href="https://leetcode.cn/problems/3sum/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a - b &#125;)</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>, res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125;</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法</p></li><li><ul><li>这道题不太适合用哈希法来做，因为需要去重</li><li>首先将数组排序，然后开始遍历数组</li><li>注意点一：如果nums[i]已经大于0的话，说明后面不会有合适的元素了，因此直接返回res</li><li>去重一：如果nums[i]&#x3D;&#x3D;&#x3D;nums[i-1]就代表之前出现过这个元素，因此不管这个组合直接continue</li><li>注意点二：这里不用nums[i+1]的原因是因为会影响到left的取值</li><li>之后开始算三数之和，如果三数之和大于0说明数字大了，那么移动right–，如果小于0说明数字笑了，那么移动left++。如果刚好等于0，说明是符合条件的三元组，那么就将三个数放到数组里</li><li>去重二：如果nums[left&#x2F;right]&#x3D;&#x3D;&#x3D;nums[left+1&#x2F;right+1]那么说明left&#x2F;right要重复了，就移动对应的指针</li><li>正常情况还要移动一下指针</li></ul></li></ul><h2 id="Day-12-Leetcode-18-四数之和"><a href="#Day-12-Leetcode-18-四数之和" class="headerlink" title="Day 12 Leetcode 18 四数之和"></a>Day 12 Leetcode 18 四数之和</h2><p><a href="https://leetcode.cn/problems/4sum/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">return</span> []</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; target &gt; <span class="number">0</span>) <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] + nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l = j + <span class="number">1</span>, r = len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123; l++ &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123; r-- &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题和三数之和的方法类似，但要注意去重的地方有些不同</li><li>在第一个循环的时候要进行第一次剪枝</li><li>第一次剪枝要判断nums[i]是不是大于0，因为负数相加可以变小</li><li>第二次循环的时候要进行第二次剪枝</li><li>第二次剪枝吧nums[i]和nums[j]当做一个整体来判断</li><li>注意：这里和三数之和不同的地方在于：target可以是负数，这样的话进行驱虫的时候</li></ul></li></ul><h2 id="Day-12-Leetcode-383-赎金信"><a href="#Day-12-Leetcode-383-赎金信" class="headerlink" title="Day 12 Leetcode 383 赎金信"></a>Day 12 Leetcode 383 赎金信</h2><p><a href="https://leetcode.cn/problems/ransom-note/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">ransomNote</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">magazine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="keyword">function</span> (<span class="params">ransomNote, magazine</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashArr=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> a=<span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> magazine)&#123;</span><br><span class="line">        hashArr[i.<span class="title function_">charCodeAt</span>()-a]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> ransomNote)&#123;</span><br><span class="line">        <span class="keyword">const</span> index=i.<span class="title function_">charCodeAt</span>()-a</span><br><span class="line">        <span class="keyword">if</span>(!hashArr[index])<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        hashArr[index]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题直接用哈希法</li><li>用一个数组存储26个字母</li><li>然后遍历magazine字符串，把出现的数字次数记下来</li><li>然后遍历ransomNote字符串，记录对应的字母的ascii值，然后看hashArr里有没有，没有的话说明ransomNote有magazine里面没有的字母，直接返回false；有的话把数组的对应位置减一</li></ul></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="Day-13-Leetcode-344-反转字符串"><a href="#Day-13-Leetcode-344-反转字符串" class="headerlink" title="Day 13 Leetcode 344 反转字符串"></a>Day 13 Leetcode 344 反转字符串</h2><p><a href="https://leetcode.cn/problems/reverse-string/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len=s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=len-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">      <span class="comment">// 解法一</span></span><br><span class="line">        <span class="comment">// let t=s[l]</span></span><br><span class="line">        <span class="comment">// s[l]=s[r]</span></span><br><span class="line">        <span class="comment">// s[r]=t</span></span><br><span class="line">      <span class="comment">//解法二：解构赋值</span></span><br><span class="line">        [s[l],s[r]]=[s[r],s[l]]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//解法三:s.reverse()</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题很简单，直接用双指针法，一个从左边第一个出发，一个从右边第一个出发，两个交换位置之后再分别前进&#x2F;后退就可以了</li><li>交换的时候可以定义临时变量，也可以解构赋值</li></ul></li></ul><h2 id="Day-13-Leetcode-541-反转字符串②"><a href="#Day-13-Leetcode-541-反转字符串②" class="headerlink" title="Day 13 Leetcode 541 反转字符串②"></a>Day 13 Leetcode 541 反转字符串②</h2><p><a href="https://leetcode.cn/problems/reverse-string-ii/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span> (<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> resArr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i - <span class="number">1</span>, r = i + k &gt; len ? len : i + k;</span><br><span class="line">        <span class="keyword">while</span> (++l &lt; --r) &#123;</span><br><span class="line">            [resArr[l], resArr[r]] = [resArr[r], resArr[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法</p></li><li><ul><li>这道题主要就是边界条件的判断</li><li>注意：循环的时候i要加2k而不是加加，这样可以减少判断</li><li>之后反转操作的时候要判断一下i+k和s.length的大小来决定反转的右边是什么位置</li></ul></li></ul><h2 id="Day-14-Leetcode-151-翻转字符串里的单词"><a href="#Day-14-Leetcode-151-翻转字符串里的单词" class="headerlink" title="Day 14 Leetcode 151 翻转字符串里的单词"></a>Day 14 Leetcode 151 翻转字符串里的单词</h2><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s+/g</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>直接调用api</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> strArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">   <span class="title function_">removeExtraSpaces</span>(strArr);</span><br><span class="line">   <span class="title function_">reverse</span>(strArr, <span class="number">0</span>, strArr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (strArr[i] === <span class="string">&#x27; &#x27;</span> || i === strArr.<span class="property">length</span>) &#123;</span><br><span class="line">       <span class="title function_">reverse</span>(strArr, start, i - <span class="number">1</span>);</span><br><span class="line">       start = i + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">strArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fastIndex &lt; strArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[fastIndex] === <span class="string">&#x27; &#x27;</span> &amp;&amp; (fastIndex === <span class="number">0</span> || strArr[fastIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      fastIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strArr[slowIndex++] = strArr[fastIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  strArr.<span class="property">length</span> = strArr[slowIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span> ? slowIndex - <span class="number">1</span> : slowIndex;</span><br><span class="line">  <span class="comment">//通过改变数组长度来移除末尾的空格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">strArr, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = end;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];</span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p></li><li><ul><li>这道题需要完成的功能：</li></ul></li><li><ul><li><ul><li>删除多余的空格</li><li>反转字符串</li><li>反转单词</li></ul></li></ul></li><li><ul><li>反转在前面已经实现过，这里可以额外用两个变量来定义开始和结尾，这样可以也可以实现字符串里面的单词反转</li><li>第二步是删除多余的空格，删除多余的空格用的方法是双指针法，参考前面数组题目的删除元素。</li><li>然后先将题目给的字符串变成一个数组，之后删除多余的空格，然后反转整个数组</li><li>之后用循环，当遇到空格的时候，说明一个单词便利完了，可以进行反转，最后更新一下start</li><li>最后调用js中的join方法把数组变成一个字符串就可以了</li></ul></li></ul><h2 id="Day-15-Leetcode-剑指offer-58-左旋转字符串"><a href="#Day-15-Leetcode-剑指offer-58-左旋转字符串" class="headerlink" title="Day 15 Leetcode 剑指offer 58 左旋转字符串"></a>Day 15 Leetcode 剑指offer 58 左旋转字符串</h2><h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span> (<span class="params">start, end, s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left=start,right=end</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        [s[left],s[right]]=[s[right],s[left]]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="keyword">function</span> (<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="number">0</span>,n-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="title function_">reverse</span>(n,s.<span class="property">length</span>-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="number">0</span>,s.<span class="property">length</span>-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>这道题比较简单，整体的思路就是反转三次字符串</li><li>第一次反转从开头到n-1位置的字符串</li><li>第二次反转从n到结尾的字符串</li><li>第三次反转整个字符串</li><li>这样就实现了将开头n个放到结尾的操作</li></ul></li></ul><h2 id="Day-16-KMP算法（理论）"><a href="#Day-16-KMP算法（理论）" class="headerlink" title="Day 16 KMP算法（理论）"></a>Day 16 KMP算法（理论）</h2><ul><li><p>解决问题：字符串匹配问题</p></li><li><p>以aabaabaaf和aabaaf举例</p></li><li><p>前缀：包含首字母，不包含尾字母的字符串（模式串中）</p></li><li><p>后缀：只包含尾字母，不包含首字母的字符串（模式串中）</p></li><li><p>前缀表：记录最长相等前后缀，比如a-&gt;0,aa-&gt;1,aab-&gt;0，aaba-&gt;0,aabaa-&gt;2,aabaaf-&gt;0,那么前缀表就是010020</p></li><li><p>找到最长下相等前后缀的位置，最长相等前后缀的长度也就是下标，比如aabaaf-&gt;下标为2也就是b所在的位置，从b所在的位置重新匹配</p></li><li><p>next数组 ：存放前缀表，<strong>告诉发生冲突的时候回退到哪里</strong></p></li><li><ul><li>如果右移前缀表作为next数组，那么回退的下标就是冲突的位置对应的前缀表中下标</li><li>如果直接拿前缀表作为next数组，那么回退的下标是冲突的位置前一位对应的前缀表中下标</li><li>如果统一减一后作为next数组，那么回退的下标是冲突的位置前一位对应的前缀表中下标+1…</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNext</span>(<span class="params">next,s</span>)&#123;</span><br><span class="line">  <span class="comment">//初始化next数组和遍历</span></span><br><span class="line">  <span class="keyword">let</span> j=<span class="number">0</span><span class="comment">//i指向后缀末尾位置，j指向前缀末尾位置以及i之前字串的最长相等前后缀的长度</span></span><br><span class="line">  next[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;s.<span class="property">length</span>;i++)&#123;<span class="comment">//因为在aa的时候才有前后缀，此时i为1，j为0</span></span><br><span class="line">      <span class="comment">//处理前后缀不相同的情况</span></span><br><span class="line">    <span class="keyword">while</span>(s[i]!==s[j]&amp;&amp;j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      j=next[j-<span class="number">1</span>]</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//处理前后缀相同的地方</span></span><br><span class="line">    <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新next数组的值</span></span><br><span class="line">    next[i]=j</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Day-17-Leecode-459-重复的子字符串"><a href="#Day-17-Leecode-459-重复的子字符串" class="headerlink" title="Day 17 Leecode 459 重复的子字符串"></a>Day 17 Leecode 459 重复的子字符串</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">题目</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext= <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> next=[]</span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span></span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!==s[j])&#123;</span><br><span class="line">            j=next[j-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> next=<span class="title function_">getNext</span>(s)</span><br><span class="line">    <span class="keyword">if</span>(next[next.<span class="property">length</span>-<span class="number">1</span>]!==<span class="number">0</span>&amp;&amp;s.<span class="property">length</span>%(s.<span class="property">length</span>-next[next.<span class="property">length</span>-<span class="number">1</span>])===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：KMP（时间复杂度O(m+n ))</p></li><li><ul><li>KMP解法中，找到最长相等前后缀，不相等的那一部分就是重复的最小子串（此处需要数学推导一下）</li><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li><li>如果数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// let next=getNext(s)</span></span><br><span class="line">    <span class="comment">// if(next[next.length-1]!==0&amp;&amp;s.length%(s.length-next[next.length-1])===0)return true</span></span><br><span class="line">    <span class="comment">// return false</span></span><br><span class="line">    ssArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(s+s)</span><br><span class="line">    ssArr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ssArr.<span class="title function_">splice</span>(ssArr.<span class="property">length</span>-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> ss=ssArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(ss.<span class="title function_">indexOf</span>(s)!==-<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：移动匹配(时间复杂度O(m*n))</p></li><li><ul><li>如果一个字符串是由重复子串构成，那么两个它拼接起来中间一定会有它本身这个字符串，因此可以调用库函数</li><li>注意：js里面要将字符串转化为数组，然后将第一个和最后一个字符删除（因为本身就有两个字符串本身，一定能找到本身）</li></ul></li></ul><h2 id="Day-17-Leetcode-28-找出字符串中第一个匹配项的下标"><a href="#Day-17-Leetcode-28-找出字符串中第一个匹配项的下标" class="headerlink" title="Day 17 Leetcode 28 找出字符串中第一个匹配项的下标"></a>Day 17 Leetcode 28 找出字符串中第一个匹配项的下标</h2><h4 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = []</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span> (<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="title function_">getNext</span>(needle)</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] !== needle[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] === needle[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === needle.<span class="property">length</span>)</span><br><span class="line">            <span class="keyword">return</span> (i-needle.<span class="property">length</span>+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>首先，求模式串的next数组（这串代码可以背下来)</li><li>然后从0开始遍历长的字符串，依然是分两种情况</li><li>第一种情况：s[i]和t[j]不相同的情况，这个时候j要做回退</li><li>第二种情况：s[i]和t[j]相同的情况，这个时候i、j都向前走一个</li><li>当j走到了模式串的末尾的时候，那么说明字符串中有模式串，这个时候返回i（原字符串走到的位置)-模式串长度+1</li></ul></li></ul><h2 id="Leetcode-125-验证回文串（第五届字节跳动青训营前端题目）"><a href="#Leetcode-125-验证回文串（第五届字节跳动青训营前端题目）" class="headerlink" title="Leetcode 125 验证回文串（第五届字节跳动青训营前端题目）"></a>Leetcode 125 验证回文串（第五届字节跳动青训营前端题目）</h2><h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (arr[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)||(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="number">9</span>)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> str = res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> reverArr = res.<span class="title function_">reverse</span>()</span><br><span class="line">    <span class="keyword">let</span> str1 = reverArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> res1=str.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">let</span> res2=str1.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">if</span> (res1 === res2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题比较简单，把字符串中多余的符号删除掉之后，转换成数组然后反转，用反转前的数组连接成的字符串和反转后的数组连接成的字符串比较</li></ul></li></ul><h2 id="Leetcode-3-无重复字符的最长子串（第五届字节跳动青训营前端题目）"><a href="#Leetcode-3-无重复字符的最长子串（第五届字节跳动青训营前端题目）" class="headerlink" title="Leetcode 3 无重复字符的最长子串（第五届字节跳动青训营前端题目）"></a>Leetcode 3 无重复字符的最长子串（第五届字节跳动青训营前端题目）</h2><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="title function_">includes</span>(x)) &#123;</span><br><span class="line">            queue.<span class="title function_">shift</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        queue.<span class="title function_">push</span>(x)</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, queue.<span class="property">length</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>1</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// let queue = []</span></span><br><span class="line">    <span class="comment">// let max = 0</span></span><br><span class="line">    <span class="comment">// for (const x of s) &#123;</span></span><br><span class="line">    <span class="comment">//     while (queue.includes(x)) &#123;</span></span><br><span class="line">    <span class="comment">//         queue.shift()</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     queue.push(x)</span></span><br><span class="line">    <span class="comment">//     max = Math.max(max, queue.length)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>, left = <span class="number">0</span>, right = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">            res.<span class="title function_">delete</span>(res.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">add</span>(s[right])</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, res.<span class="property">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：（滑动窗口）</p></li><li><ul><li>这道题用滑动窗口来解决，用set这个数据结构</li><li>注意：无重复字符的字串必须是<strong>连续的,否则就不是子串而是子序列</strong></li><li>如果 set中含有当前字符，就删除第一个字符,同时缩小窗口left++</li><li>如果没有含有，就添加当前值到 set上，同时把right++</li></ul></li></ul><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="Day-18-Leetcode-232-用栈实现队列"><a href="#Day-18-Leetcode-232-用栈实现队列" class="headerlink" title="Day 18 Leetcode 232 用栈实现队列"></a>Day 18 Leetcode 232 用栈实现队列</h2><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>很简单的数组应用</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>=[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size = <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">pop</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>&amp;&amp;!<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p></li><li><ul><li>用两个数组模拟栈，要实现队列的先进先出的功能，首先有一个进栈，然后当要出栈的时候，就把进栈末尾（先进来的元素）弹出并且压到出栈中，这是一个持续的过程</li></ul></li></ul><h2 id="Day-18-Leetcode-225-用队列实现栈"><a href="#Day-18-Leetcode-225-用队列实现栈" class="headerlink" title="Day 18 Leetcode 225 用队列实现栈"></a>Day 18 Leetcode 225 用队列实现栈</h2><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x=<span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>解法一：数组应用(最好不用)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法二：用一个队列模拟</p></li><li><ul><li>这道题比较简单，用一个队列实现的要点在于出栈的时候要先将队列的首元素弹出然后再放进队列末尾，这样就能模拟出栈的出栈顺序了</li></ul></li></ul><h2 id="Day-18-Leetcode-20-有效的括号"><a href="#Day-18-Leetcode-20-有效的括号" class="headerlink" title="Day 18 Leetcode 20 有效的括号"></a>Day 18 Leetcode 20 有效的括号</h2><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = s[i]</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(x!==stack.<span class="title function_">pop</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p></li><li><ul><li>这道题是栈的应用，js里用数组来模拟一个栈。</li><li>括号不匹配有三种情况</li><li>第一种：左括号多余</li><li>第二种：右括号多余</li><li>第三种：括号类型不匹配</li><li>从头遍历整个字符串，遇到左括号就把对应的有括号压入栈中，遇到右括号就开始和栈顶元素比较，如果相同就出栈。第一种情况在遍历完之后栈中还有元素，第二种情况是栈中美原油可匹配的元素，第三种情况是在遍历完之前栈就空了。</li><li>因此遍历完之后返回的栈如果是空的说明括号都匹配了，反之则不匹配</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">const</span> map=&#123;</span><br><span class="line">        <span class="string">&quot;&#123;&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(&quot;</span>:<span class="string">&quot;)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;[&quot;</span>:<span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x <span class="keyword">in</span> map)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(x)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[stack.<span class="title function_">pop</span>()]!==x)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：（简化版）</p></li><li><ul><li>和解法一思路一样，有一点不同的是这里压入栈的是左括号本身，用到了map的数据结构来做映射。这样的话在遍历字符串的时候就简化了一些操作。</li></ul></li></ul><h2 id="Day-18-Leetcode-1047-删除字符串中的所有相邻重复项"><a href="#Day-18-Leetcode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="Day 18 Leetcode  1047 删除字符串中的所有相邻重复项"></a>Day 18 Leetcode  1047 删除字符串中的所有相邻重复项</h2><h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="property">length</span>!==<span class="number">0</span>&amp;&amp;x===(temp=stack.<span class="title function_">pop</span>()))&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;        </span><br><span class="line">      <span class="keyword">if</span>(temp)stack.<span class="title function_">push</span>(temp)</span><br><span class="line">        <span class="comment">// if(stack.length!==0&amp;&amp;x===stack[stack.length-1])&#123;</span></span><br><span class="line">        <span class="comment">//     stack.pop()</span></span><br><span class="line">        <span class="comment">//     continue</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        stack.<span class="title function_">push</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：用栈来解决</p></li><li><ul><li>这道题用栈来解决很方便。</li><li>遍历字符串的时候先做一个判断，如果栈顶元素和当前元素相同，说明可以消掉，那么就出栈。否者就把当前元素压入栈。</li><li>因为是用数组模拟的栈，所以既可以用temp保存弹出的元素，也可以直接用数组访问元素来判断.</li><li>最后直接将栈中元素连接成字符串即可。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> str=<span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="keyword">let</span> top=-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(top===-<span class="number">1</span>||str[top]!==s[i])&#123;</span><br><span class="line">            str[++top]=s[i]<span class="comment">//进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            top--<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.<span class="property">length</span>=top+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：双指针法</p></li><li><ul><li>这道题还是用的数组的数据结构，不过用top来记录栈顶，这样直接操作一个数组，限定长度即可</li></ul></li></ul><h2 id="Day-19-Leetcode-150-逆波兰表达式求值"><a href="#Day-19-Leetcode-150-逆波兰表达式求值" class="headerlink" title="Day 19 Leetcode 150 逆波兰表达式求值"></a>Day 19 Leetcode 150 逆波兰表达式求值</h2><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span> (<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tokens.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="comment">// for (const x of tokens) &#123;</span></span><br><span class="line">    <span class="comment">//     if (isNaN(Number(x))) &#123;</span></span><br><span class="line">    <span class="comment">//         const num1 = stack.pop()</span></span><br><span class="line">    <span class="comment">//         const num2 = stack.pop()</span></span><br><span class="line">    <span class="comment">//         if (x === &#x27;+&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 + num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;-&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 - num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;*&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 * num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;/&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 / num1 | 0)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//         stack.push(Number(x))</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] === <span class="string">&#x27;+&#x27;</span> || tokens[i] === <span class="string">&#x27;-&#x27;</span> || tokens[i] === <span class="string">&#x27;*&#x27;</span> || tokens[i] === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> num1 = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">const</span> num2 = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;+&quot;</span>) stack.<span class="title function_">push</span>(num2 + num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;-&quot;</span>) stack.<span class="title function_">push</span>(num2 - num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;*&quot;</span>) stack.<span class="title function_">push</span>(num2 * num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;/&quot;</span>) stack.<span class="title function_">push</span>(num2 / num1 | <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(tokens[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>这道题用栈解决</li><li>遍历整个字符串，遇到数字就放到栈里，遇到运算符的话就弹出栈里两个元素然后做完运算后再放回去</li><li>需要注意的是这里的除法运算<strong>向零截断</strong> ，也就是要用到“|”这个为运算符</li></ul></li></ul><h2 id="Day-20-Leecode-239-滑动窗口最大值"><a href="#Day-20-Leecode-239-滑动窗口最大值" class="headerlink" title="Day 20 Leecode 239 滑动窗口最大值"></a>Day 20 Leecode 239 滑动窗口最大值</h2><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; value &gt; back &amp;&amp; back !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>()</span><br><span class="line">                back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">pop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; value === <span class="variable language_">this</span>.<span class="title function_">front</span>()) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> myQueue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>()</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        myQueue.<span class="title function_">push</span>(nums[j++])</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(myQueue.<span class="title function_">front</span>())</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        myQueue.<span class="title function_">push</span>(nums[j])</span><br><span class="line">        myQueue.<span class="title function_">pop</span>(nums[i])</span><br><span class="line">        res.<span class="title function_">push</span>(myQueue.<span class="title function_">front</span>())</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>1</li></ul></li></ul><h2 id="Day-21-Leetcode-347-前k个高频元素"><a href="#Day-21-Leetcode-347-前k个高频元素" class="headerlink" title="Day 21 Leetcode 347 前k个高频元素"></a>Day 21 Leetcode 347 前k个高频元素</h2><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">compareFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">compareFn</span> = compareFn</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value)</span><br><span class="line">        <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> (parent &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(parent, index) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[parent]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[parent], <span class="variable language_">this</span>.<span class="property">queue</span>[index]]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> out = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">let</span> searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="keyword">while</span> (searchChild !== <span class="literal">undefined</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(index, searchChild) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[searchChild]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[searchChild], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line">            index = searchChild;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">compare</span>(<span class="params">index1, index2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index1] === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index2] === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">compareFn</span>(<span class="variable language_">this</span>.<span class="property">queue</span>[index1], <span class="variable language_">this</span>.<span class="property">queue</span>[index2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> heap = <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">            heap.<span class="title function_">push</span>(entry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">                heap.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = heap.<span class="title function_">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = heap.<span class="title function_">pop</span>()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法:</p></li><li><ul><li>这道题需要用到小顶堆和优先级队列两种数据结构</li><li>首先定义一个map来储存每个字符出现的频率</li><li>然后用一个heap来模拟小顶堆</li><li>小顶堆本质上是一种树，它有上浮和下沉的操作，因此在编写弹出和压入两个操作的时候要注意下标的变化。</li><li>小顶堆的根节点是频率最小的字符，因此每次压入之后判断小顶堆的大小并且弹出节点，最后剩下的就是需要求的数组</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 第二篇文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第二篇文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
