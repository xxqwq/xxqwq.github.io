<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Node</title>
      <link href="/2023/03/15/Node/"/>
      <url>/2023/03/15/Node/</url>
      
        <content type="html"><![CDATA[<h1 id="Node基础"><a href="#Node基础" class="headerlink" title="Node基础"></a>Node基础</h1><p>资料：<a href="https://www.bilibili.com/video/BV1a34y167AZ/?p=3&spm_id_from=pageDriver&vd_source=83d30f851f424154f1ee0eeb70a6a728">02.初识Node-什么是Node.js哔哩哔哩bilibili</a></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ul><li><p>js的组成：js核心语法+webApi</p></li><li><p>js为什么能调用DOM、BOM：因为浏览器提供了这些API</p></li><li><p>浏览器中的js运行环境：V8解析引擎+内置的API</p></li><li><ul><li>V8引擎负责解析和执行js代码</li><li>内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用</li></ul></li></ul><h2 id="Nodejs简介"><a href="#Nodejs简介" class="headerlink" title="Nodejs简介"></a>Nodejs简介</h2><ul><li><p>是一个基于Chrome <strong>V8引擎</strong>的<strong>JavaScript运行环境</strong></p></li><li><p>Node.js运行环境：V8引擎+内置API注意：</p></li><li><ul><li>浏览器是js的前端运行环境</li><li>node.js是js的后端运行环境</li><li>node.js中<strong>无法调用DOM和BOM</strong>等浏览器内置API</li></ul></li></ul><h2 id="Node-js可以做什么"><a href="#Node-js可以做什么" class="headerlink" title="Node.js可以做什么"></a>Node.js可以做什么</h2><ul><li>基于 <a href="http://www.expressjs.com.cn/">Express 框架</a>，可以快速构建 Web 应用</li><li>基于 <a href="https://electronjs.org/">Electron 框架</a>，可以构建跨平台的桌面应用</li><li>基于 <a href="http://restify.com/">restify 框架</a>，可以快速构建 API 接口项目</li><li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li></ul><h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h2><ul><li>Buffer 的结构与数组类似，操作方法与数组类似</li><li>数组不能存储二进制文件，Buffer 是专门存储二进制数据的</li><li>Buffer 存储的是二进制数据，显示时以 16 进制的形式显示</li><li>Buffer 每一个元素范围是 00<del>ff，即 0</del>255、00000000~11111111</li><li>每一个元素占用一个字节内存(1byte&#x3D;8bit)</li><li>Buffer 是对底<strong>层内存的直接操作</strong>，因此大小一旦确定<strong>就不能修改</strong></li></ul><p>Buffer 常用方法：</p><ul><li>Buffer.from(str[, encoding])：将一个字符串转换为 Buffer</li><li>Buffer.alloc(size)：创建指定大小的 Buffer</li><li>Buffer.alloUnsafe(size)：创建指定大小的 Buffer，可能包含敏感数据（分配内存时不会清除内存残留的数据）</li><li>buf.toString()：将 Buffer 数据转为字符串</li></ul><h2 id="内置API模块"><a href="#内置API模块" class="headerlink" title="内置API模块"></a>内置API模块</h2><h3 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h3><h4 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h4><ul><li><p>fs模块是官方提供的用来操作we年的模块</p></li><li><p>fs.readFile() 方法用来读取指定文件中的内容</p></li><li><p>fs.writeFile() 方法用来写入内容</p></li><li><ul><li>需要先导入模块 ：const fs &#x3D; require(‘fs’)</li></ul></li></ul><h5 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile()"></a>fs.readFile()</h5><ul><li>语法格式：fs.readFile(path[,options],callback)</li><li>参数1：必选参数，表示文件的路径</li><li>参数2：可选参数，表示以什么编码格式来读取（一般指定utf-8)</li><li>参数3：必选参数，文件读取完成后通过回调函数拿到读取的结果（err,datastr)，如果读取成功，则err的值为null;如果读取失败，则err的值为错误对象，datastr的值为undefined</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)//导入fs模块</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;../files/1.txt&#x27;, &#x27;utf-8&#x27;, (err,datastr) =&gt; &#123;</span><br><span class="line">  console.log(&quot;err:&quot;, err)</span><br><span class="line">  console.log(&quot;success:&quot;,datastr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="fs-writeFile"><a href="#fs-writeFile" class="headerlink" title="fs.writeFile()"></a>fs.writeFile()</h5><ul><li><p>语法格式：fs.writeFile(file,data[,options],callback)</p></li><li><p>参数1：必选参数，表示文件的路径</p></li><li><p>参数2：必选参数，表示要写入的内容</p></li><li><p>参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8</p></li><li><p>参数4：必选参数，文件写入完成后的回调函数</p></li><li><ul><li>如果文件写入成功，则err的值等于null</li><li>如果文件写入失败，则err的值等于一个错误对象</li></ul></li><li><p>注意：这个api不能用来创建文件</p></li><li><p>注意：这个api写入文件是覆盖的写入</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.writeFile(&#x27;../files/write.txt&#x27;, &#x27;abcd&#x27;, &#x27;utf-8&#x27;, (err) =&gt; &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    fs.readFile(&#x27;../files/write.txt&#x27;, &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123;</span><br><span class="line">      console.log(dataStr)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="案例：考试成绩管理"><a href="#案例：考试成绩管理" class="headerlink" title="案例：考试成绩管理"></a>案例：考试成绩管理</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;../files/成绩.txt&#x27;, &#x27;utf-8&#x27;, (err, dataStr) =&gt; &#123;</span><br><span class="line">  if (!err) &#123;</span><br><span class="line">    const data = dataStr.split(&#x27; &#x27;)</span><br><span class="line">    const arrNew = []</span><br><span class="line">    data.forEach(item =&gt; &#123;</span><br><span class="line">      arrNew.push(item.replace(&#x27;=&#x27;, &#x27;:&#x27;))</span><br><span class="line">    &#125;)</span><br><span class="line">    const newstr = arrNew.join(&#x27;\r\n&#x27;)//处理数据</span><br><span class="line">    fs.writeFile(&#x27;../files/成绩-ok.txt&#x27;, newstr, &#x27;utf-8&#x27;, (err) =&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        console.log(&quot;写入失败&quot; + err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#x27;读取文件失败！&#x27;, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="路径动态拼接的问题"><a href="#路径动态拼接的问题" class="headerlink" title="路径动态拼接的问题"></a>路径动态拼接的问题</h5><ul><li>在使用fs模块操作文件时，如果提供的操作路径是相对路径是很容易出现路径错误的问题，因为node在执行的时候是以执行node命令的目录为基准的。</li><li>解决：给一个完整的路径</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf8&#x27;, (err, datastr) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&quot;err:&quot;+err)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(datastr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)//错误</span><br><span class="line">fs.readFile(&#x27;D:/桌面/Node.js/files/1.txt&#x27;, &#x27;UTF8&#x27;, (err, datastr) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&quot;err:&quot;,err)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(datastr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)//移植性很差</span><br><span class="line">fs.readFile(__dirname+&#x27;/../files/1.txt&#x27;, &#x27;utf8&#x27;, (err, datastr) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&quot;err:&quot;, err)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(datastr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>__dirname表示当前文件所在目录</li></ul><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>path模块是Node.js官方提供的用来处理路径的模块</p></li><li><p>常见方法：</p></li><li><ul><li>path.join():拼接路径</li><li>path.basename()：用来从路径字符串中将文件名解析出来</li></ul></li></ul><h5 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h5><ul><li>语法格式：path.join([…paths])</li><li>拼接路径都要使用path.join()，不要使用加号了</li><li>注意：’..&#x2F;‘会抵消前面的路径</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const pathstr = path.join(__dirname, &quot;/../files/1.txt&quot;)</span><br><span class="line">console.log(pathstr)</span><br></pre></td></tr></table></figure><h5 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename()"></a>path.basename()</h5><ul><li>用来获取路径的最后一个文件名</li><li>语法格式：path.basename(path,[…etx])</li><li>参数一：必选参数，表示路径的字符串</li><li>参数二：可选参数，表示文件的扩展名（用了之后就返回删除了扩展名的路径)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const pathstr=&quot;./1/2/3.html&quot;</span><br><span class="line">const res=path.basename(pathstr,&#x27;.html&#x27;)</span><br><span class="line">console.log(res)//3</span><br></pre></td></tr></table></figure><h5 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname()"></a>path.extname()</h5><ul><li>用来获取路径的扩展名</li><li>语法格式：path.basename(path,[…etx])</li><li>参数一：必选参数，表示路径的字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const path=require(&#x27;path&#x27;)</span><br><span class="line">const pathstr=&#x27;./1/2/321.txt&#x27;</span><br><span class="line">const str=path.extname(pathstr)</span><br><span class="line">console.log(str)//.txt</span><br></pre></td></tr></table></figure><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><ul><li>简介：是Nodejs官方提供的web服务器的模块，通过http.createServer()方法，就能方便的把一台普通的电脑变成一台web服务器，从而对外提供web资源服务</li><li>进一步理解：服务器与普通电脑的区别就在于服务器安装了web服务器软件，nodejs可以手写一个服务器</li></ul><h4 id="服务器相关的概念："><a href="#服务器相关的概念：" class="headerlink" title="服务器相关的概念："></a>服务器相关的概念：</h4><ul><li><p><strong>IP地址</strong>：是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。</p></li><li><ul><li>通常用点分十进制表示成a.b.c.d，a,b,c,d都是0-255之间的十进制整数</li><li>互联网中每台web服务器都有自己的ip地址，可以运行 ping <a href="http://www.baidu.com查询/">www.baidu.com查询</a></li><li>开发期间，自己的电脑既是一台服务器，也是一个客户端，在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当作一台服务器进行访问了</li></ul></li><li><p><strong>域名</strong>：字符型的地址方案（IP的别名)，IP和域名是一一对应的关系</p></li><li><ul><li>注意：单纯使用ip地址互联网中的电脑也能正常工作，但是有了域名更方便</li><li>开发中127.0.0.1对应的域名是localhost</li><li>一个ip可以对应多个域名，但是一个域名只能对应一个ip</li></ul></li><li><p><strong>域名服务器</strong>：负责提供域名和IP转换的服务的服务器。</p></li><li><p><strong>端口号</strong>：表示web服务，客户端发送的网络请求，通过端口号，可以被准确的交给对应的web服务进行处理。</p></li><li><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1677908256206-4e62e072-752c-49d1-861e-f98e921e960d.png" alt="img"></p></li><li><ul><li><strong>每个端口号不能同时被多个web服务占用</strong></li><li><strong>URL中的80端口可以被省略</strong></li></ul></li></ul><h4 id="创建web服务器"><a href="#创建web服务器" class="headerlink" title="创建web服务器"></a>创建web服务器</h4><h5 id="导入http模块"><a href="#导入http模块" class="headerlink" title="导入http模块"></a>导入http模块</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http=require(&#x27;http&#x27;)</span><br></pre></td></tr></table></figure><h5 id="创建web服务器实例"><a href="#创建web服务器实例" class="headerlink" title="创建web服务器实例"></a>创建web服务器实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const server=http.createServer()</span><br></pre></td></tr></table></figure><h5 id="为服务器实例绑定request事件，监听客户端的请求"><a href="#为服务器实例绑定request事件，监听客户端的请求" class="headerlink" title="为服务器实例绑定request事件，监听客户端的请求"></a>为服务器实例绑定request事件，监听客户端的请求</h5><ul><li><p>只要有客户端请求自己的服务器，就会触发request事件，从而调用这个事件处理函数</p></li><li><p><strong>req</strong>:如果在事件处理函数中访问与客户端相关的属性或书记可以使用以下的方法</p></li><li><ul><li>req.url:是客户端请求的url地址</li><li>req.methods是客户端的method请求类型</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1677909570953-8ba4e5df-5777-4f2b-9df6-8ef1d543c1ca.png" alt="img"></li><li>可以用postman测试post请求</li></ul></li><li><p><strong>res</strong>:响应对象，如果在事件处理函数中访问与服务器相关的数据或属性，可以使用以下的方式</p></li><li><ul><li>res.end（）：向客户端发送指定的内容，并结束这次请求的处理过程</li><li>为了防止中文乱码的为题，需要设置响应头Content-Type的值为text&#x2F;html；charset&#x3D;utf-8</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>)</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;<span class="comment">//使用服务器实例的on方法绑定一个request时间</span></span><br><span class="line">    <span class="comment">//只要有客户端请求自己的服务器，就会触发request事件，从而调用这个事件处理函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有请求&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> method=req.<span class="property">method</span></span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span></span><br><span class="line">    <span class="keyword">const</span> str=<span class="string">`Your request url is <span class="subst">$&#123;url&#125;</span>,and request method is <span class="subst">$&#123;method&#125;</span>`</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h5><ul><li>调用server.listen(端口号,cb回调)方法，即可启动web服务器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(<span class="number">8</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//调用server.listen(端口号,cb回调)方法，即可启动web服务器</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="根据不同的url响应不同的html内容"><a href="#根据不同的url响应不同的html内容" class="headerlink" title="根据不同的url响应不同的html内容"></a>根据不同的url响应不同的html内容</h4><ul><li>获取请求的url地址</li><li>设置默认的相应内容 404 Not found</li><li>判断用户请求的是否为&#x2F;或者&#x2F;index.html</li><li>判断用户请求的是否为&#x2F;about.html</li><li>设置Content-Type响应头，防止中文乱码</li><li>使用res.end()把内容响应给客户端</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1.获取请求的url地址</span></span><br><span class="line">    <span class="keyword">const</span> url = req.<span class="property">url</span></span><br><span class="line">    <span class="comment">//2. 设置默认的404页面</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">&#x27;&lt;h1&gt; 404 Not Found &lt;/h1&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//3.判断请求的url</span></span><br><span class="line">    <span class="keyword">if</span> (url === <span class="string">&quot;/&quot;</span> || url === <span class="string">&quot;/index.html&quot;</span>) &#123;</span><br><span class="line">        content = <span class="string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url === <span class="string">&quot;/about.html&quot;</span>) &#123;</span><br><span class="line">        content = <span class="string">&#x27;&lt;h1&gt;关于&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.设置响应头</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=utf-8&quot;</span>)</span><br><span class="line">    <span class="comment">//5.响应给客户端</span></span><br><span class="line">    res.<span class="title function_">end</span>(content)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="例子：时钟web服务器案例"><a href="#例子：时钟web服务器案例" class="headerlink" title="例子：时钟web服务器案例"></a>例子：时钟web服务器案例</h5><ul><li>核心思路：把文件的实际存放路径作为每个资源的请求url地址</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1677911360906-56b8d811-884d-4f0e-b74c-188dfde21b66.png" alt="img"></li><li>导入需要的模块</li><li>创建web服务器</li><li>将资源的请求url地址映射为文件的存放路径</li><li>读取文件内容并响应给客户端</li><li>优化资源的请求路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入需要的模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">//开启web服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//将资源的请求url地址映射为文件的存放地址</span></span><br><span class="line">    <span class="keyword">const</span> url = req.<span class="property">url</span></span><br><span class="line">    <span class="comment">// const fpath = path.join(__dirname, url)</span></span><br><span class="line">    <span class="comment">//优化路径</span></span><br><span class="line">    <span class="keyword">let</span> fpath = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (url === <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">        fpath = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;./clock/index.html&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fpath = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;/clock&quot;</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取文件内容并响应给客户端</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(fpath, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="comment">//读取失败，向客户端响应固定的错误消息</span></span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&quot;404 Not Found&quot;</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取失败&quot;</span> + err.<span class="property">message</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">end</span>(dataStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，对于整个系统来说，模块是可组合、分解和更换的单元。</p></li><li><p>编程领域中就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块</p></li><li><p>优点：</p></li><li><ul><li>提高了代码的复用性</li><li>提高了代码的可维护性</li><li>可以实现按需加载</li></ul></li></ul><h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><ul><li><p>优点：大家都遵守同样的模块化规范写代码，降低沟通成本，方便了各个模块之间的相互调用</p></li><li><ul><li>在每个模块内部，module变量代表当前模块</li><li>module变量是一个对象，他的exports属性是对外的接口</li><li>加载某个模块，其实是加载该模块的module.exports属性，require方法用于加载模块</li></ul></li></ul><h4 id="Node中的模块化"><a href="#Node中的模块化" class="headerlink" title="Node中的模块化"></a>Node中的模块化</h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>内置模块：node官方提供的，例如fs、path</li><li>自定义模块：用户创建的每个.js文件</li><li>第三方模块：第三方开发出来的模块，使用前需要先下载</li></ul><h5 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h5><ul><li>使用require（）方法加载模块</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1677915104952-0ea5a983-5ff0-4eb3-aec3-e4243d6a7e77.png" alt="img"></li><li>注意：通过require加载模块时，会执行里面的代码</li><li>注意：加载自定义模块不一定要提供后缀名</li></ul><h5 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h5><ul><li><p>定义：和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做作用域</p></li><li><p>优点：防止全局变量污染</p></li><li><p>遵循了commonjs规范，规定了模块的特性与各模块之间如何相互依赖</p></li><li><ul><li>在每个模块内部，module变量代表当前模块</li><li>module变量是一个对象，他的exports属性是对外的接口</li><li>加载某个模块，其实是加载该模块的module.exports属性，require方法用于加载模块</li></ul></li></ul><h5 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h5><ul><li>作用：每个js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息</li></ul><h6 id="module-exports对象"><a href="#module-exports对象" class="headerlink" title="module.exports对象"></a>module.exports对象</h6><ul><li>默认等于一个空对象</li><li>在自定义模块中可以使用这个对象姜模块内的成员共享出去，供外界使用</li><li>在外界使用require导入一个自定义模块的时候，得到的成员就是那个模块中，通过module。exports所指向的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载test模块&quot;</span>)</span><br><span class="line"><span class="comment">// console.log(module)</span></span><br><span class="line"><span class="keyword">const</span> username = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayhello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;大家好，我是&quot;</span> + username)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhello</span>()</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="number">1</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>:<span class="string">&quot;hh&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">username</span>=username</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">sayhello</span>=sayhello</span><br><span class="line"><span class="comment">//&#123; &#x27;1&#x27;: 1, &#x27;2&#x27;: &#x27;hh&#x27;, username: &#x27;张三&#x27;, sayhello: [Function: sayhello] &#125;</span></span><br></pre></td></tr></table></figure><ul><li>注意：使用require方法导入模块时，导入的结果，永远以module.exports指向的对象为准</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;加载test模块&quot;</span>)</span><br><span class="line"><span class="comment">// console.log(module)</span></span><br><span class="line"><span class="keyword">const</span> username = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayhello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;大家好，我是&quot;</span> + username)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayhello</span>()</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">username</span>=username</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">sayhello</span>=sayhello</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="number">1</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>:<span class="string">&quot;hh&quot;</span></span><br><span class="line">&#125;<span class="comment">//&#123; &#x27;1&#x27;: 1, &#x27;2&#x27;: &#x27;hh&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h5 id="exports对象"><a href="#exports对象" class="headerlink" title="exports对象"></a>exports对象</h5><ul><li>由于module.exports写起来比较复杂，因此提供了一个exports对象，写的时候还是以module.exports指向为准</li><li>注意：只是一开始是相等的，如果修改了指向就不一定了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">exports</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>===<span class="variable language_">module</span>.<span class="property">exports</span>)<span class="comment">//true</span></span><br><span class="line"><span class="built_in">exports</span>=&#123;&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>===<span class="variable language_">module</span>.<span class="property">exports</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><p>exports和module.exports的使用误区</p></li><li><ul><li>require（）时得到的永远是module.exports指向的对象</li><li>如果不改变exports的指向，那么它修改的结果可以作用域module.exports</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> 对象是 <span class="variable language_">module</span> 对象的一个属性,在初始时 <span class="variable language_">module</span>.<span class="property">exports</span> 和 <span class="built_in">exports</span> 指向同一块内存区域</span><br><span class="line">模块导出的是 <span class="variable language_">module</span>.<span class="property">exports</span> , <span class="built_in">exports</span> 只是对它的引用,在不改变<span class="built_in">exports</span> 内存的情况下,修改<span class="built_in">exports</span> 的值可以改变 <span class="variable language_">module</span>.<span class="property">exports</span> 的值</span><br><span class="line">导出时尽量使用 <span class="variable language_">module</span>.<span class="property">exports</span> ,以免因为各种赋值导致的混乱</span><br><span class="line">作者：闪现A小兵</span><br><span class="line">来源：稀土掘金</span><br></pre></td></tr></table></figure><h5 id="包与npm"><a href="#包与npm" class="headerlink" title="包与npm"></a>包与npm</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h6><ul><li>定义：Node.js的<strong>第三方模块</strong>又叫做包</li><li>来源：包是由第三方个人或团队开发出来的，免费供所有人使用</li><li>为什么需要：Node.js的内置模块仅提供了一些底层的API,导致在基于内置模块开发时，效率很低。包时基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率。</li><li>搜索：从<a href="https://www.npmjs.com/">npm</a> 搜索需要的包</li><li>下载：通过包管理工具 Node Package Manager （包管理工具)从<a href="https://registry.npmjs.org/">链接</a></li></ul><h6 id="例子：格式化时间的两种方法"><a href="#例子：格式化时间的两种方法" class="headerlink" title="例子：格式化时间的两种方法"></a>例子：格式化时间的两种方法</h6><ul><li>传统方法:<img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1677996863808-0da15194-144a-4f85-8eb6-cefa2c6d7865.png" alt="img"></li><li>高级做法：导入第三方包moment</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dt1 = <span class="title function_">moment</span>().<span class="title function_">format</span>(<span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dt1)</span><br></pre></td></tr></table></figure><h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ul><li><p>文件结构：</p></li><li><ul><li>node_modules文件夹用来存放所有安装到项目中的包</li><li>package-lock.json用来记录node_modules目录下的每一个包的下载信息</li><li>package.json主要用来定义项目中需要依赖的包</li></ul></li><li><p>安装指定版本的包:@</p></li><li><p>包的语义化版本规范：点分十进制，例如2.24.0</p></li><li><ul><li>第一位数字：大版本</li><li>第二位数字：功能版本（大版本没更新，但是更新了一些功能)</li><li>第三位数字：bug修复版本</li><li>提升的规则：<strong>只要前面的版本号增长了，则后面的版本号归零</strong></li></ul></li></ul><h6 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h6><ul><li>在项目根目录，必须提供一个叫做package.json的包管理配置文件，用来记录和项目有关的一些配置信息，例如项目的名称、版本号、描述、那些包在开发时用到等等</li><li>多人协作共享时，会遇到node_modules过大的问题，可以用package.json的配置文件记录项目中安装了哪些包，可以供团队成员共享。</li><li>注意：开发中要把node_moduls文件夹添加到.gitignore忽略文件中</li><li>快速创建:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><ul><li><ul><li>注意：只能在英文的目录下成功运行，运行时会自动把包的名称和版本号记录到package.json中</li></ul></li><li><p><strong>dependencies</strong>：记录安装了哪些包</p></li><li><ul><li>当执行npm i命令时，会先读取package.json的dependencies节点</li></ul></li><li><p><strong>devDependencies</strong>:记录某些包在项目开发阶段用到，上线之后不会用到</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -D<span class="comment">//简写</span></span><br><span class="line">npm install 包名 --save-dev<span class="comment">//完整写法,--save-dev放在包名前面或者后面都可以</span></span><br></pre></td></tr></table></figure><h6 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall moment</span><br></pre></td></tr></table></figure><ul><li>运行后会自动把包从package.json的dependencies节点中删除</li></ul><h6 id="切换镜像源"><a href="#切换镜像源" class="headerlink" title="切换镜像源"></a>切换镜像源</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i nrm -g</span><br><span class="line">nrm ls<span class="comment">//查看所有可用镜像源</span></span><br><span class="line">nrm use taobao<span class="comment">//切换淘宝镜像</span></span><br></pre></td></tr></table></figure><h6 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h6><ul><li><p>开发依赖包:-D</p></li><li><p>核心依赖包</p></li><li><p>全局包:-g</p></li><li><ul><li>只有工具性质的包，才有全局安装的必要性<img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678000548161-1d3ce4f8-888e-4ead-ab38-c58cdb7f2186.png" alt="img"></li><li>例：<strong>i5ting_toc：可以把md文档转成html</strong></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i i5ting_toc -g</span><br><span class="line">i5ting_tociting_toc-f 要转换的md文件路径 -<span class="title function_">o</span>(自动打开)</span><br></pre></td></tr></table></figure><h6 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h6><ul><li>包必须以单独的目录存在</li><li>包的顶级目录下必须包含package.json这个配置文件</li><li>package.json必须包含name,version,main这三个属性，分别代表名字，版本号，入口</li></ul><h6 id="开发一个自己的包"><a href="#开发一个自己的包" class="headerlink" title="开发一个自己的包"></a>开发一个自己的包</h6><ul><li><p>实现的功能：</p></li><li><ul><li>格式化时间</li><li>转义html中的特殊字符</li><li>还原html中的特殊字符</li></ul></li><li><p>初始化包的基本结构</p></li><li><ul><li>新建itheima-tools作为根目录</li><li>新建package.json、index.js、README.md</li></ul></li><li><p>初始化package.json</p></li><li><ul><li>name:包的名称</li><li>version:版本号</li><li>main:入口文件</li><li>description:描述</li><li>keyword:关键字</li><li>license:协议</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;date-html_tools&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;进行时间格式化以及html的转义与还原的小工具&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dateFormat&quot;</span><span class="punctuation">,</span><span class="string">&quot;htmlEscape&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>模块化拆分</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678002642482-cb34512f-b25b-482a-9b55-c8f46d4c4fd4.png" alt="img"></p><ul><li>编写说明文档</li><li>发布包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><ul><li><ul><li>注意：发布的时候必须切换回npm的服务器</li></ul></li><li><p>删除包</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish 包名 --force</span><br></pre></td></tr></table></figure><ul><li><ul><li>注意:npm unpublish命令只能删除72h以内的包</li><li>npm unpublish删除的包，24h内不能重复发布</li><li>最好不要发布没有意义的包</li></ul></li></ul><h5 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h5><h6 id="优先从缓存中加载"><a href="#优先从缓存中加载" class="headerlink" title="优先从缓存中加载"></a>优先从缓存中加载</h6><ul><li>模块在第一次加载后会被缓存，因此多次调用require不会导致模块的代码被执行多次，提高了效率</li></ul><h6 id="内置模块加载优先级最高"><a href="#内置模块加载优先级最高" class="headerlink" title="内置模块加载优先级最高"></a>内置模块加载优先级最高</h6><h6 id="加载自定义模块，必须指定-x2F-或-x2F-开头的路径标识符，否则会当成内置模块或者第三方模块加载"><a href="#加载自定义模块，必须指定-x2F-或-x2F-开头的路径标识符，否则会当成内置模块或者第三方模块加载" class="headerlink" title="加载自定义模块，必须指定.&#x2F;或.&#x2F;开头的路径标识符，否则会当成内置模块或者第三方模块加载"></a>加载自定义模块，必须指定.&#x2F;或.&#x2F;开头的路径标识符，否则会当成内置模块或者第三方模块加载</h6><ul><li><p>在导入自定义模块时，如果忽略的扩展名，则会按顺序分别尝试加载</p></li><li><ul><li>按照确切的文件名进行加载</li><li>补全.js扩展名进行加载</li><li>补全.json扩展名进行加载</li><li>补全.node扩展名进行加载</li><li>加载错误，报错</li></ul></li></ul><h6 id="加载第三方模块"><a href="#加载第三方模块" class="headerlink" title="加载第三方模块"></a>加载第三方模块</h6><ul><li>如果传递的模块标识符不是一个内置模块，也没有以’.&#x2F;‘或’..&#x2F;开头，则node会从当前模块的父目录开始，尝试从&#x2F;node_modules文件夹加载第三方模块</li><li>如果没有找到，那么会移动到上一层父目录进行加载，直到根目录</li></ul><h6 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h6><ul><li><p>当把目录作为模块标识符，传递给require时有三种加载方式</p></li><li><ul><li>在被加载的目录下查找package.json文件并寻找main属性作为入口</li><li>如果没有package.json或者main不存在，则node会试图加载目录下的index.js文件</li><li>如果以上都失败了，就会打印错误消息</li></ul></li></ul><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="初识express"><a href="#初识express" class="headerlink" title="初识express"></a>初识express</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li><p>官方:express是基于Node.js平台，快速、开放、极简的WEB开发框架</p></li><li><p>通俗的理解：Express的作用和http模块类似，是用来创建web服务器的</p></li><li><p>本质：本质上就是一个npm的第三方包，提供了快速创建web服务器的便捷方法，是基于http模块进一步封装出来的</p></li><li><p>作用：</p></li><li><ul><li>Web网站服务器：专门对外提供web网页资源的服务器</li><li>API接口服务器：专门对外提供API接口的服务器</li></ul></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure><h3 id="创建基本的Web服务器"><a href="#创建基本的Web服务器" class="headerlink" title="创建基本的Web服务器"></a>创建基本的Web服务器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()<span class="comment">//返回服务器实例</span></span><br><span class="line"><span class="comment">//启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express server is running&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="监听GET请求和Post请求"><a href="#监听GET请求和Post请求" class="headerlink" title="监听GET请求和Post请求"></a>监听GET请求和Post请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;请求URL&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>参数一：请求的URL地址</p></li><li><p>参数二：请求对应的处理函数</p></li><li><ul><li>req:请求对象，包含了与请求相关的属性和方法</li><li>res:响应对象，包含了与相应相关的属性与方法</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;请求URL&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>参数一：请求的URL地址</p></li><li><p>参数二：请求对应的处理函数</p></li><li><ul><li>req:请求对象，包含了与请求相关的属性和方法</li><li>res:响应对象，包含了与相应相关的属性与方法</li></ul></li></ul><h4 id="把内容响应给客户端"><a href="#把内容响应给客户端" class="headerlink" title="把内容响应给客户端"></a>把内容响应给客户端</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><h4 id="获取URL中携带的查询参数"><a href="#获取URL中携带的查询参数" class="headerlink" title="获取URL中携带的查询参数"></a>获取URL中携带的查询参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">query</span>)<span class="comment">//获取客户端发送过来的查询参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>默认是一个空对象</li></ul><h4 id="获取URL中携带的动态参数"><a href="#获取URL中携带的动态参数" class="headerlink" title="获取URL中携带的动态参数"></a>获取URL中携带的动态参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/user/:id&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">params</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>默认是一个空对象，里面存放着通过 ：动态匹配到的参数值</li></ul><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><h4 id="express-static"><a href="#express-static" class="headerlink" title="express.static()"></a>express.static()</h4><ul><li>方便的创建一个静态资源服务器</li><li>express在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong>因此存放静态文件的目录名不会出现在URL中</strong></li><li><strong>托管多个静态资源目录，只需要多次调用</strong></li><li><strong>访问时，express.static()函数会根据目录的添加顺序查找所需的文件</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&quot;../../clock&quot;</span>))</span><br></pre></td></tr></table></figure><ul><li>如果希望在托管的静态资源访问路径之前，挂在路径前缀，可以在第一个参数写</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;public&#x27;</span>，express.<span class="title function_">static</span>(<span class="string">&quot;../../clock&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="nodemon-工具"><a href="#nodemon-工具" class="headerlink" title="nodemon 工具"></a>nodemon 工具</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.<span class="property">js</span></span><br></pre></td></tr></table></figure><ul><li>代码被修改后，会被nodemon监听到，从而实现自动重启的效果</li></ul><h2 id="express路由"><a href="#express路由" class="headerlink" title="express路由"></a>express路由</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li>路由指的是客户端的请求与服务器处理函数之间的映射关系</li><li>分三部分组成，分别是请求的类型、请求的URL、处理函数</li><li>例如app.get&#x2F;post都是路由</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>,<span class="variable constant_">HANDLER</span>)</span><br></pre></td></tr></table></figure><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><ul><li>每当一个请求到达服务器后，需要先经过路由的匹配，只有匹配成功之后才会调用对应的处理函数</li><li>匹配时会<strong>按照路由的顺序进行匹配</strong>，如果<strong>请求类型和请求的URL同时匹配成功</strong>，则Express会将这次请求交给对应的function函数处理</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//挂载路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器已经启动&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="模块化-1"><a href="#模块化-1" class="headerlink" title="模块化"></a>模块化</h3><ul><li><p>为了方便对路由进行模块化的管理，不建议将路由直接挂载到app上，而是推荐抽离为单独的模块</p></li><li><p>步骤：</p></li><li><ul><li>创建路由模块对应的.js文件</li><li>调用express.Router()函数创建路由对象</li><li>向路由对象上挂载具体的路由</li><li>使用module.exports向外共享路由对象</li><li>使用app.use()函数注册路由模块</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)<span class="comment">//导入express</span></span><br><span class="line"><span class="keyword">const</span> router=express.<span class="title class_">Router</span>()<span class="comment">//创建路由对象</span></span><br><span class="line"><span class="comment">//挂载具体路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/user/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;get user list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/user/list&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;post user list&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//向外导出路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="comment">//注册路由模块</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意：app.use()函数的作用就是来<strong>注册全局中间件</strong></li><li><strong>添加前缀：和为静态资源添加前缀一样</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>,userRouter)</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li>概念：业务流程的中间处理环节</li><li>调用流程：当一个请求到达express的服务器之后，可连续调用多个中间件，从而对这次请求进行预处理</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678110481894-68102a2b-e0f0-4669-b4a5-cbe46c7c4122.png" alt="img"></li><li>格式：本质上就是一个function处理函数</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678110528257-b94c2e28-3d8a-45dd-a663-97b6369a50f0.png" alt="img"></p><ul><li><ul><li>中间件函数的形参列表中必须包含next参数，而路由处理函数中只包含req和res</li><li>next函数：是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由</li></ul></li></ul><h3 id="定义中间件函数"><a href="#定义中间件函数" class="headerlink" title="定义中间件函数"></a>定义中间件函数</h3><ul><li>最简单的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//定义一个最简单的中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw=<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是最简单的中间件函数&quot;</span>)</span><br><span class="line">    <span class="comment">//把流转关系转交给下一个中间件或路由</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listten</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="全局生效的中间件：客户端发起的任何请求，到达服务器之后都会触发的中间件"><a href="#全局生效的中间件：客户端发起的任何请求，到达服务器之后都会触发的中间件" class="headerlink" title="全局生效的中间件：客户端发起的任何请求，到达服务器之后都会触发的中间件"></a>全局生效的中间件：客户端发起的任何请求，到达服务器之后都会触发的中间件</h4><ul><li>通过app.use(中间件函数)，即可定义一个中间件函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mw=<span class="keyword">function</span>(<span class="params">req,res,next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是最简单的中间件函数&quot;</span>)</span><br><span class="line">    <span class="comment">//把流转关系转交给下一个中间件或路由</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将mw注册为全局生效的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(mw)</span><br></pre></td></tr></table></figure><ul><li>简化形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;简化版的中间件&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>作用</p></li><li><ul><li>多个中间件之间，共享同一份req和res。基于这样的特性，我们可以在上有的中间件中，统一为req或res对象添加自定义的属性或方法，共下游的中间件或路由进行使用</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678111642669-640de66b-8d8d-4274-8914-fd5235ffa260.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time=<span class="title class_">Date</span>.<span class="title function_">now</span>()<span class="comment">//获取请求到达服务器的时间</span></span><br><span class="line">    <span class="comment">//为req对象挂载自定义属性</span></span><br><span class="line">    req.<span class="property">startTime</span>=time</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;post&quot;</span>+req.<span class="property">startTime</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="局部生效的中间件：不使用app-use-定义的中间件"><a href="#局部生效的中间件：不使用app-use-定义的中间件" class="headerlink" title="局部生效的中间件：不使用app.use()定义的中间件"></a>局部生效的中间件：不使用app.use()定义的中间件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> mw = <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;局部生效中间件&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, mw, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Home page&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//mw只会在&#x27;/&#x27;中生效</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/user&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;user page&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>定义多个局部中间件：数组或 参数列表</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mw = <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;中间件&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mw1 = <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;中间件1&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, mw,mw1, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Home page&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, [mw,mw1], <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Home page&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><h4 id="应用级别"><a href="#应用级别" class="headerlink" title="应用级别"></a>应用级别</h4><ul><li>通过app.use或app.get或app.post绑定到app实例上的中间件</li></ul><h4 id="路由级别"><a href="#路由级别" class="headerlink" title="路由级别"></a>路由级别</h4><ul><li>绑定到express.Router实例上的中间件</li><li>用法和应用级别中间件没有任何区别</li></ul><h4 id="错误级别"><a href="#错误级别" class="headerlink" title="错误级别"></a>错误级别</h4><ul><li>专门用来捕获项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>错误级别中间件的function函数中必须有四个形参（err,req,res,next）</li><li><strong>必须注册在所有路由之后</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//人为的制造错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;服务器内部发生了错误&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Home page&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//定义错误级别的中间件捕获整个项目的异常错误</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发生了错误:&quot;</span>+err.<span class="property">message</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Error:&quot;</span>+err.<span class="property">message</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Express内置"><a href="#Express内置" class="headerlink" title="Express内置"></a>Express内置</h4><ul><li>express.static():快速托管静态资源</li><li>express.json:解析JSON格式(application&#x2F;json)的请求体数据（有兼容性，仅在4.116.0+版本中可用)并挂载到req.body上</li><li>express.urlencoded：解析URL-encoded格式的请求体数据（有兼容性，仅在4.116.0+版本中可用)—基于第三方中间件body-parser封装的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123;extended：<span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：除了错误级别的中间件，其他的中间件必须在路由之前进行配置</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/user&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//服务器可以使用req.body这个属性来接受客户端发送过来的请求体数据</span></span><br><span class="line">    <span class="comment">//默认情况下，如果不配置解析表单数据的中间件，则req.body默认等于undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extends</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/book&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//服务器可以使用req.body这个属性来接受客户端发送过来的请求体数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h4><ul><li><p>第三方开发出来的中间件，可以按需下载并配置第三方中间件</p></li><li><p>步骤：</p></li><li><ul><li>运行npm i 安装中间件</li><li>使用require导入中间件</li><li>调用app.use()调用并使用中间件</li></ul></li></ul><h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678114770635-41bc5af2-4bf5-41bb-ac2f-079966add9fe.png" alt="img"></p><h4 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//定义中间件的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="监听req的data事件"><a href="#监听req的data事件" class="headerlink" title="监听req的data事件"></a>监听req的data事件</h4><ul><li><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678114901908-18498e8a-be91-48ac-bbdc-0359ea55cd5e.png" alt="img"></li></ul><h4 id="监听req的end事件"><a href="#监听req的end事件" class="headerlink" title="监听req的end事件"></a>监听req的end事件</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678115051948-a6034065-35c8-498a-8f1c-83f52462b8a7.png" alt="img"></p><h4 id="使用querystring模块解析请求体数据"><a href="#使用querystring模块解析请求体数据" class="headerlink" title="使用querystring模块解析请求体数据"></a>使用querystring模块解析请求体数据</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678115202479-044b4d88-5bcf-472b-8b20-41752bf0e427.png" alt="img"></p><h4 id="将解析出来的数据对象挂在为req-body"><a href="#将解析出来的数据对象挂在为req-body" class="headerlink" title="将解析出来的数据对象挂在为req.body"></a>将解析出来的数据对象挂在为req.body</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678115302155-ced18aeb-b55b-4944-9919-d1473639fb00.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&quot;querystring&quot;</span>)</span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bodyparser</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//定义中间件的业务逻辑</span></span><br><span class="line">    <span class="comment">//定义变量，用来存储客户端发送过来的请求体数据</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//监听req的data事件</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        str += chunk</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//监听req的end事件</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//存放的是完整的请求体数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把字符串格式的请求体数据解析成对象格式</span></span><br><span class="line">        <span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br><span class="line">        req.<span class="property">body</span> = body</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=bodyparser</span><br></pre></td></tr></table></figure><h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><h3 id="创建API路由"><a href="#创建API路由" class="headerlink" title="创建API路由"></a>创建API路由</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> router=express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br></pre></td></tr></table></figure><h3 id="编写get接口"><a href="#编写get接口" class="headerlink" title="编写get接口"></a>编写get接口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> router=express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//拿到客户端通过查询字符串发送到服务器的数据</span></span><br><span class="line">    <span class="keyword">const</span> query=req.<span class="property">query</span></span><br><span class="line">    <span class="comment">//调用res.send方法响应结果</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>:<span class="number">0</span>,<span class="comment">//0表示处理成功，1表示处理失败</span></span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&quot;GET请求成功&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>:query<span class="comment">//相应给客户端的数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br></pre></td></tr></table></figure><h3 id="编写post接口"><a href="#编写post接口" class="headerlink" title="编写post接口"></a>编写post接口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> router=express.<span class="title class_">Router</span>()</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/post&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//通过req.body获取请求体上的url-encoded格式的数据</span></span><br><span class="line">    <span class="keyword">const</span> body=req.<span class="property">body</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&quot;Post请求成功&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>:body</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=router</span><br></pre></td></tr></table></figure><ul><li>注意：必须要配置解析表单数据的中间件</li></ul><h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><h4 id="接口的跨域问题"><a href="#接口的跨域问题" class="headerlink" title="接口的跨域问题"></a>接口的跨域问题</h4><ul><li>前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口。</li><li>要同时满足三个条件才会产生跨域问题，这也就是为什么会产生跨域的原因。</li><li>1、浏览器限制，而不是服务端限制，可以查看Network，请求能够正确响应，response返回的值也是正确的</li><li>2、请求地址的域名或端口和当前访问的域名或端口不一样</li><li>3、发送的是XHR（XMLHttpRequest）请求，可以使用 a 标签（模拟xhr请求）和 img 标签（模拟json请求）做对比（控制台只报了一个跨域异常）</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>CORS(主流方案)</li><li>JSONP（只支持GET请求)</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678261848041-32b23dfc-60c8-48c6-a6b2-0167c0321cd5.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678261898929-6446be59-a3d9-4ff1-a74c-6c824bd1a5b2.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678261998734-40bfba44-941f-481f-9825-9da527a3d2ab.png" alt="img"></p><h4 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h4><ul><li><p>定义：Cross-Origin Resource Sharing 跨域资源共享）<strong>由一系列HTTP响应头组成，决定浏览器是否阻止前端js代码跨域获取资源</strong></p></li><li><p>**浏览器的同源安全策略默认会组织网页跨域获取资源，但是如果配置了CORS相关的HTTP响应头就可以解除0浏览器端的跨域访问限制</p><p>**<img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678260958303-929d1118-d8dc-4da4-b5dc-95549be8280c.png" alt="img"></p></li><li><p>cors是express的一个第三方中间件,使用app.use()注册</p></li><li><p>一定要在路由之前配置，从而解决接口跨域的问题</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i cors</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br></pre></td></tr></table></figure><ul><li><p>注意点：</p></li><li><ul><li>主要在服务器端进行配置</li><li>cors在浏览器中有兼容性，只有支持XMLHttpRequest Level2的浏览器才能正常访问开启了cors的服务端接口</li></ul></li></ul><h5 id="相关的响应头"><a href="#相关的响应头" class="headerlink" title="相关的响应头"></a>相关的响应头</h5><ul><li><p>Access-Control-Allow-Origin</p></li><li><ul><li>origin参数的值指定了允许访问该资源的外域URL</li><li>如果制定了字段的值为通配符*，表示允许来自任何域的请求</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;URL&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>Access-Control-Allow-Headers:</p></li><li><ul><li>默认情况下，CORS金支持客户端向服务器发送如下的9个请求头</li><li><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678261226886-294c08a0-2a77-4d3e-a7fa-a7e7e943a1d1.png" alt="img"></li><li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端对额外的请求头进行声明</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,<span class="string">&quot;Headers&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>Access-Control-Allow-Methods:</p></li><li><ul><li>默认情况下，CORS金支持客户端发起GET,POST,HEAD请求</li><li>如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端指明请求所允许的HTTP方法</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>,<span class="string">&quot;Methods&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h5><ul><li><p>简单请求：</p></li><li><ul><li>请求方式：GET、POST、HEAD三者之一</li><li>HTTP头部信息不超过九种字段</li></ul></li><li><p>预检请求：</p></li><li><ul><li>请求方式为GET&#x2F;POST&#x2F;HEAD三者之外</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了application&#x2F;json格式的数据</li><li>在浏览器与服务器正是通信之前，浏览器会先<strong>发送OPTION请求进行预检，以获知服务器是否允许该实际请求</strong>，所以这一次的OPTION请求成为“预检请求”。<strong>服务器成功响应预检请求后才会发送真正的请求并携带真实数据</strong></li></ul></li><li><p><strong>简单请求与预检请求的区别：</strong></p></li><li><ul><li><strong>简单请求客户端与服务器之间只会发生一次请求，而预检请求会发送两次</strong></li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>数据库（database）：是用来组织、存储、管理数据的仓库</li></ul><h3 id="数据组织结构"><a href="#数据组织结构" class="headerlink" title="数据组织结构"></a>数据组织结构</h3><ul><li>数据库、数据表(table)、数据行(row)、字段(field)</li><li>不同的数据要存储到不同表中</li><li>每个表中具体寸尺那些信息，由字段来决定那个</li><li>表中的行代表具体数据</li></ul><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li><p>字段的特殊标识：</p></li><li><ul><li>PK：主键</li><li>NN(not null)：值不允许为空</li><li>UQ（Unique):值唯一</li><li>AI(auto increment):值自动增长</li></ul></li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h3><ul><li>sql(structure query language)：结构化查询语言，是专门用来访问和处理数据库的编程语言</li><li>是一门数据库编程语言</li><li>使用sql语言编写出来的代码叫做sql语句</li><li>只能在关系型数据库中使用</li><li>可以用来<strong>增删改查、创建数据库、创建表、存储过程、视图</strong></li></ul><h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>SELECT语句用于从表中查询数据，执行的结果被存储在一个结果表中（称为结果集）</li><li>对大小写不敏感</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> <span class="operator">-</span> 从指定的表中查询所有的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名称</span><br><span class="line"><span class="operator">-</span> <span class="operator">-</span> 从指定的表中查询指定列的数据</span><br><span class="line"><span class="keyword">SELECT</span> 列名称 <span class="keyword">FROM</span> 表名称</span><br></pre></td></tr></table></figure><h3 id="INSERT-INTO语句"><a href="#INSERT-INTO语句" class="headerlink" title="INSERT INTO语句"></a>INSERT INTO语句</h3><ul><li>insert into 语句用于向数据表中插入新的数据行</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li>向指定的表中插入如下几列数据</li><li>列和值要一一对应，多个列和多个值之间使用英文的逗号分隔</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (列<span class="number">1.</span>...列n) <span class="keyword">VALUES</span> (值<span class="number">1.</span>.....)</span><br></pre></td></tr></table></figure><h3 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h3><ul><li>update语句用于修改表中的数据</li></ul><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><ul><li>update指定要更新哪个表中的数据</li><li>用set指定列对应的新值</li><li>用where指定更新的条件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名称 <span class="keyword">SET</span> 列名称 <span class="operator">=</span> 新值 <span class="keyword">WHERE</span> 列名称<span class="operator">=</span>某值</span><br></pre></td></tr></table></figure><h3 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h3><ul><li>用于删除表里的行</li></ul><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名称 <span class="keyword">WHERE</span> 列名<span class="operator">=</span>值</span><br></pre></td></tr></table></figure><h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><ul><li>用于限定选择的标准，在select&#x2F;update&#x2F;delete中那节课使用where字句来限定选择的标准</li><li>可以使用的运算符：&#x3D; &lt;&gt;(不等于) &gt; &lt; &gt;&#x3D; &lt;&#x3D; BETWEEN LIKE</li></ul><h4 id="and-x2F-or运算符"><a href="#and-x2F-or运算符" class="headerlink" title="and&#x2F;or运算符"></a>and&#x2F;or运算符</h4><ul><li>可在where语句中把两个或多个条件结合起来</li><li>and表示必须同时满足多个条件</li><li>or表示只要满足其中一个条件就可以</li></ul><h3 id="order-BY-字句"><a href="#order-BY-字句" class="headerlink" title="order BY 字句"></a>order BY 字句</h3><ul><li>用于根据指定的列对结果集进行排序</li><li>默认按照升序对记录进行排序，如果希望降序，那么可以使用<strong>DESC关键字（ASC是升序)</strong></li></ul><h4 id="多重排序"><a href="#多重排序" class="headerlink" title="多重排序"></a>多重排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> name,id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT(*)函数"></a>COUNT(*)函数</h3><ul><li>用于返回查询结果的总数据条数</li><li>语法：SELECT COUNT(*) FROM 表名称</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="AS关键字"><a href="#AS关键字" class="headerlink" title="AS关键字"></a>AS关键字</h3><ul><li>可以用来设置别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> TOTAL <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="mysql模块"><a href="#mysql模块" class="headerlink" title="mysql模块"></a>mysql模块</h2><h3 id="安装第三方模块mysql"><a href="#安装第三方模块mysql" class="headerlink" title="安装第三方模块mysql"></a>安装第三方模块mysql</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mysql</span><br></pre></td></tr></table></figure><h3 id="配置mysql模块"><a href="#配置mysql模块" class="headerlink" title="配置mysql模块"></a>配置mysql模块</h3><ul><li><p>导入mysql模块</p></li><li><p>建立连接</p></li><li><ul><li>host:数据库的ip地址</li><li>user:登录数据库的账号</li><li>password:密码</li><li>database:要登陆的数据库</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>)<span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> db=mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&quot;127.0.0.1&quot;</span>,<span class="comment">//数据库的ip地址</span></span><br><span class="line">    <span class="attr">user</span>:<span class="string">&quot;root&quot;</span>,<span class="comment">//登录数据库的账号</span></span><br><span class="line">    <span class="attr">password</span>:<span class="string">&quot;20030319&quot;</span>,<span class="comment">//密码</span></span><br><span class="line">    <span class="attr">database</span>:<span class="string">&quot;my_db&quot;</span><span class="comment">//要登陆的数据库</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>调用db.query()指定要执行的sql语句，通过回调函数拿到执行的结果</p></li><li><ul><li>参数一：要执行的语句</li><li>参数二：回调函数，err是错误，results是查询结果</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&quot;SELECT 1&quot;</span>,<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="通过mysql模块执行SQL语句"><a href="#通过mysql模块执行SQL语句" class="headerlink" title="通过mysql模块执行SQL语句"></a>通过mysql模块执行SQL语句</h3><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><ul><li>执行的结果是一个数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&quot;SELECT * FROM user&quot;</span>,<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><ul><li>?在sql语句中代表占位符</li><li>affectedRows表示影响的列数，可以用来判断是不是插入成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;spiderman&quot;</span>, <span class="attr">id</span>: <span class="number">8</span>, <span class="attr">status</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">const</span> sqlstr=<span class="string">&quot;INSERT INTO user (name,id,status) values(?,?,?)&quot;</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlstr, [user.<span class="property">name</span>, user.<span class="property">id</span>, user.<span class="property">status</span>],<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)<span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">if</span>(results.<span class="property">affectedRows</span>===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;插入数据成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>快捷插入：如果数据对象的每个属性和数据表的字段一一对应</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">user</span> <span class="operator">=</span> &#123; name: &quot;spiderman&quot;, id: <span class="number">8</span>, status: <span class="number">0</span> &#125;</span><br><span class="line">const sqlstr<span class="operator">=</span>&quot;INSERT INTO user SET ?&quot;</span><br><span class="line">db.query(sqlstr, <span class="keyword">user</span>,(err,results)<span class="operator">=</span><span class="operator">&gt;</span>&#123;</span><br><span class="line">    if(err)console.<span class="built_in">log</span>(err.message)</span><br><span class="line">    if(results.affectedRows<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="number">1</span>)&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(&quot;插入数据成功&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><ul><li>执行了update语句之后，执行的结果也是一个对象，也可以通过affectedRows来判断是否更新成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;1111&quot;</span>, <span class="attr">id</span>: <span class="number">13</span>, <span class="attr">status</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> sqlstr = <span class="string">&quot;UPDATE user SET  name=? ,status=? where id= ?&quot;</span> <span class="comment">//?在sql语句中表示占位符</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlstr, [user.<span class="property">name</span>,user.<span class="property">status</span>,user.<span class="property">id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新数据成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>快捷更新：如果数据对象的每个属性和数据表的字段一一对应</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;1111&quot;</span>, <span class="attr">id</span>: <span class="number">13</span>, <span class="attr">status</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> sqlstr = <span class="string">&quot;UPDATE user SET? where id= ?&quot;</span> <span class="comment">//?在sql语句中表示占位符</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlstr, [user,user.<span class="property">id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新数据成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li>推荐根据唯一标识来删除对应的数据</li><li>执行delete语句之后，结果也是一个对象，也会包含affectedRows属性</li><li>注意：如果sql语句中有对各占位符，则必须使用数组为每个占位符指定具体的值，如果sql语句中只有一个占位符，则可以省略数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&quot;DELETE FROM user where id=12&quot;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h5><ul><li>使用delete会真正的吧数据从表中删除掉，为了保险起见推荐使用标记删除的形式来模拟删除的动作，也就是在表中设置类似于status这样的状态字段来标记当前这条数据是否被删除，当用户执行了删除的动作时我们并没有执行delete语句，二十使用update语句将对应的status字段标记为删除</li></ul><h1 id="前后端的身份认证"><a href="#前后端的身份认证" class="headerlink" title="前后端的身份认证"></a>前后端的身份认证</h1><h2 id="WEB开发模式"><a href="#WEB开发模式" class="headerlink" title="WEB开发模式"></a>WEB开发模式</h2><h3 id="基于服务端渲染的传统开发模式"><a href="#基于服务端渲染的传统开发模式" class="headerlink" title="基于服务端渲染的传统开发模式"></a>基于服务端渲染的传统开发模式</h3><ul><li><p>概念：服务器发送给客户端的html页面，实在服务器通过字符串的拼接动态生成的，客户端不需要使用ajax这样的技术</p></li><li><p>优点：</p></li><li><ul><li>前端耗时少，因为服务器端负责动态生成HTML内容，浏览器只需要直接渲染页面即可</li><li>有利于SEO，因为服务器端相应的的是完整的html页面内容，所以爬虫更容易爬取获得信息</li></ul></li><li><p>缺点：</p></li><li><ul><li>占用服务器端资源，如果请求较多会多服务器造成一定的访问压力</li><li>不利于前后端分离，开发效率低</li></ul></li></ul><h3 id="基于前后端分离的新型开发模式"><a href="#基于前后端分离的新型开发模式" class="headerlink" title="基于前后端分离的新型开发模式"></a>基于前后端分离的新型开发模式</h3><ul><li><p>概念：依赖于ajax技术的广泛应用，后端只负责提供api接口，前端使用ajax调用接口</p></li><li><p>优点：</p></li><li><ul><li>开发体验好，前端专注于UI页面的开发，后端专注于api的开发</li><li>用户体验好，可以轻松实现页面的局部刷新</li><li>减轻了服务器端的渲染压力，因为实在用户的浏览器中生成的</li></ul></li><li><p>缺点：</p></li><li><ul><li>不利于seo，因为完整的html页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息，解决方法是SSR</li></ul></li></ul><h3 id="如何选择开发模式"><a href="#如何选择开发模式" class="headerlink" title="如何选择开发模式"></a>如何选择开发模式</h3><ul><li>不谈业务场景而盲目选择使用何种开发模式都是耍流氓</li><li>企业级网站，主要功能是展示而不是交互，需要良好的seo就需要使用服务器端渲染</li><li>后台管理系统，交互性比较强，就可以使用前后端分离</li><li>当然也可以两种兼用</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>概念：又称鉴权，是指通过一定的手段完成对用户身份的确认</li></ul><h3 id="不同开发模式下的身份认证"><a href="#不同开发模式下的身份认证" class="headerlink" title="不同开发模式下的身份认证"></a>不同开发模式下的身份认证</h3><ul><li>服务端渲染推荐使用Session认证机制</li><li>前后端分离推荐使用JWT认证机制</li></ul><h3 id="Session认证机制"><a href="#Session认证机制" class="headerlink" title="Session认证机制"></a>Session认证机制</h3><h4 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h4><ul><li>客户端的每次http请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次http请求的状态。</li><li>如何突破：服务器主动给客户端发送一个身份认证的标识<strong>Cookie</strong></li></ul><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><ul><li><p>Cookie是存储在用户浏览器的一段不超过4KB的字符串，由一个<strong>名称</strong>，一个<strong>值</strong>和其他几个用于控制有效期、安全性、适用范围的<strong>可选属性</strong>组成</p></li><li><p>不同域名下的cookie各自独立，每当客户端发起请求时，会<strong>自动</strong>把当前域名下<strong>所有未过期的cookie</strong>一同发送到服务器。</p></li><li><p>特性：</p></li><li><ul><li>自动发送</li><li>域名独立</li><li>过期时限</li><li>4KB限制</li></ul></li><li><p>在身份认证中的作用：</p></li><li><ul><li>客户端在第一次请求服务器的时候，服务器通过响应头的形式向客户端发送一个身份认证的cookie，客户端会自动将Cookie保存在浏览器中。随后，当客户端每次请求服务器是，会自动将身份认证相关的cookie通过请求头的形式发送给服务器，服务器即可验明客户端的身份</li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678535064606-ad748d7f-00e1-4798-8d85-cfcd14a24f22.png" alt="img"></p></li><li><p>安全性：</p></li><li><ul><li>不具有安全性，因为浏览器提供的读写cookie的API，因此cookie很容易被伪造。、</li></ul></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678535459620-caaf2bd5-77e6-4936-9467-7088a5c7bc38.png" alt="img"></p><h4 id="express中使用session"><a href="#express中使用session" class="headerlink" title="express中使用session"></a>express中使用session</h4><ul><li>安装express-session中间件</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express<span class="operator">-</span>session</span><br></pre></td></tr></table></figure><ul><li>配置中间件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> session=<span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">  <span class="attr">secret</span>:<span class="string">&quot;test&quot;</span>,<span class="comment">//随意填写</span></span><br><span class="line">  <span class="attr">resave</span>:<span class="literal">false</span>,<span class="comment">//固定写法</span></span><br><span class="line">  <span class="attr">saveUninitialized</span>:<span class="literal">true</span><span class="comment">//固定写法</span></span><br><span class="line">&#125;))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;express服务器开启&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><ul><li>配置成功后即可通过req.session来访问和使用session对象</li></ul></li><li><p>清空session：req.session.destory()(只会清空当前用户的session)</p></li></ul><h3 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h3><ul><li><p>session认证机制需要配合Cookie才能实现，由于cookie默认不支持跨域访问，因此涉及到前端你跨域请求后端接口的时候需要做很多额外的配置才能实现跨域Session认证</p></li><li><p>定义：（JSON Web Token）是目前最流行的跨域认证解决方案</p></li><li><p>工作原理：</p></li><li><ul><li>用户的信息通过Token字符串的形式保存在客户端中，服务器通过还原Token的形式来认证用户的身份</li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678536726478-2b9bb387-57d4-407d-a8f2-4c4b37bef905.png" alt="img"></p></li><li><p>组成部分：Header、Payload(有效荷载）、Signature(签名)：Header.Payload.Signature</p></li><li><ul><li>Payload部分才是真正的用户信息，是加密后的字符串</li><li>Header和signature是安全性相关的部分，只是为了保证Token的安全性</li></ul></li><li><p>使用方式：</p></li><li><ul><li>客户端收到服务器返回的JWT之后通常会存储在localstorage或sessionStorage中，此后客户端每次与服务器通信都要带上这个JWT的字符串。推荐吧JWT放在HTTP请求头的Authorization字段中</li></ul></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization:Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h4 id="在express中使用JWT"><a href="#在express中使用JWT" class="headerlink" title="在express中使用JWT"></a>在express中使用JWT</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i jsonwebtoken express-jwt//</span><br></pre></td></tr></table></figure><ul><li>第一个包用于生成JWT字符串，第二个包用于将JWT字符串解析还原成JSON对象</li></ul><h5 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;expressjwt&#125; = <span class="built_in">require</span>(<span class="string">&quot;express-jwt&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="定义secret密钥"><a href="#定义secret密钥" class="headerlink" title="定义secret密钥"></a>定义secret密钥</h5><ul><li><p>为保证jwt字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，需要专门定义一个用于加密和解密的secret密钥</p></li><li><ul><li>生成jwt字符串的时候需要使用secret密钥对用户的信息进行加密最终得到加密好的JWT字符串</li><li>当把jwt字符串解析还原成JSON对象的时候需要使用secret密钥进行解密</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> secretKey=<span class="string">&quot;hhhsecret&quot;</span><span class="comment">//本质就是字符串</span></span><br></pre></td></tr></table></figure><h5 id="生成JWT字符串"><a href="#生成JWT字符串" class="headerlink" title="生成JWT字符串"></a>生成JWT字符串</h5><ul><li>jsonwebtoken提供了sign（）方法</li><li>参数一”用户信息对象</li><li>参数二：加密密钥</li><li>参数三：配置对象,可以配置当前token的有效期</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jwt.<span class="title function_">sign</span>(&#123; <span class="attr">username</span>: <span class="string">&quot;user.username&quot;</span> &#125;,secretKey,&#123;<span class="attr">expiresIn</span>:<span class="string">&quot;30s&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="还原json对象"><a href="#还原json对象" class="headerlink" title="还原json对象"></a>还原json对象</h5><ul><li>客户端每次访问有权限接口的时候都需要主动通过请求头中的Authorization字段将token字符串发送到服务器进行身份认证</li><li>expressJWT({ secret: secretKey }):用来解析Token</li><li>.unless({ path: [&#x2F;^/api/&#x2F;] }):用来指定哪些接口不需要访问权限</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: secretKey，<span class="attr">algorithms</span>:[<span class="string">&quot;HS256&quot;</span>] &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure><h5 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h5><ul><li>只要配置成功了express-jwt这个中间件，就可以把解析出来的用户信息挂载到req.auth上</li></ul><h5 id="捕获解析JWT失败后的错误"><a href="#捕获解析JWT失败后的错误" class="headerlink" title="捕获解析JWT失败后的错误"></a>捕获解析JWT失败后的错误</h5><ul><li>当使用express-JWT解析token时如果客户端发送的token国企或者不合法会产生一个解析失败的错误，影响项目的正常运行，可以通过Express的错误中间件捕获这个错误并进行相关的处理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29638251/1678538630854-09a1e1d5-2fe7-40d0-b78c-756907f653c4.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2023/02/09/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/09/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h2><h3 id="什么是回溯："><a href="#什么是回溯：" class="headerlink" title="什么是回溯："></a>什么是回溯：</h3><ul><li>回溯法又称回溯搜索法，是一种搜索的方法</li><li>回溯是递归的副产品，只要有递归就有回溯</li><li>是一种<strong>纯暴力的方法</strong></li></ul><h3 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h3><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li><li>其他</li></ul><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ul><li>可以抽象成一棵n叉树，树的宽度是集合的宽度，可以用for循环遍历；树的深度是递归的深度。</li></ul><h3 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span>(<span class="params">参数</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">  收集结果</span><br><span class="line">  <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">for</span>(集合元素)&#123;</span><br><span class="line">    处理节点</span><br><span class="line">    递归</span><br><span class="line">    回溯操作（撤销处理节点）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h2><h3 id="Day-36-Leetcode-77-组合"><a href="#Day-36-Leetcode-77-组合" class="headerlink" title="Day 36 Leetcode 77 组合"></a>Day 36 Leetcode 77 组合</h3><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span> (<span class="params">n, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = [], result = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">n, k, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> === k) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>([...path])<span class="comment">//收集结果</span></span><br><span class="line">            <span class="keyword">return</span><span class="comment">//结束递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.<span class="title function_">push</span>(i)<span class="comment">//处理节点</span></span><br><span class="line">            <span class="title function_">backtracking</span>(n, k, i + <span class="number">1</span>)<span class="comment">//递归</span></span><br><span class="line">            path.<span class="title function_">pop</span>()<span class="comment">//回溯，撤销处理节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>可以利用好回溯算法的模板</li><li>确定函数的参数：startIndex代表着本层递归中开始的位置，这样可以实现从这个元素开始遍历，防止出现重复的组合</li><li>确定递归结束条件：当path里的元素到了k个的时候，可以收集结果</li><li>确定单层递归逻辑：这里要注意回溯的这个过程不能忘记。这个过程就是一棵树的遍历过程。</li></ul></li></ul><h4 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combine = <span class="keyword">function</span> (<span class="params">n, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = [], result = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">n, k, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> === k) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt;= n - (k - path.<span class="property">length</span>) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.<span class="title function_">push</span>(i)</span><br><span class="line">            <span class="title function_">backtracking</span>(n, k, i + <span class="number">1</span>)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(n, k, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>优化的地方主要在循环的时候。</li><li>已经选择的元素个数：path.size();</li><li>所需要的元素个数为: k - path.size();</li><li>列表中剩余元素（n-i） &gt;&#x3D; 所需需要的元素个数（k - path.size()）&#x3D;》下一次最多从i &lt;&#x3D; n - (k - path.length) + 1开始遍历，之后的不用遍历</li></ul><h3 id="Day-37-Leetcode-216-组合总和③"><a href="#Day-37-Leetcode-216-组合总和③" class="headerlink" title="Day 37 Leetcode 216 组合总和③"></a>Day 37 Leetcode 216 组合总和③</h3><h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum3 = <span class="keyword">function</span> (<span class="params">k, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], path = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">target, k, sum, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> === k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target === sum) &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([...path])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt;= <span class="number">9</span>-(k-path.<span class="property">length</span>)+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">            path.<span class="title function_">push</span>(i)</span><br><span class="line">            <span class="title function_">backtracking</span>(target, k, sum, i + <span class="number">1</span>)</span><br><span class="line">            sum -= i</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// var combinationSum3 = function (k, n) &#123;</span></span><br><span class="line"><span class="comment">//     let res = [], path = []</span></span><br><span class="line"><span class="comment">//     const backtracking = (sum, startIndex) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//         if (sum &gt; n) &#123;</span></span><br><span class="line"><span class="comment">//             return</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (path.length === k) &#123;</span></span><br><span class="line"><span class="comment">//             if (sum === n) &#123;</span></span><br><span class="line"><span class="comment">//                 res.push([...path])</span></span><br><span class="line"><span class="comment">//                 return</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         for (let i = startIndex; i &lt;= 9 - (k - path.length) + 1; i++) &#123;</span></span><br><span class="line"><span class="comment">//             path.push(i)</span></span><br><span class="line"><span class="comment">//             backtracking(sum + i, i + 1)//这里是一个自动回溯</span></span><br><span class="line"><span class="comment">//             path.pop()</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     backtracking(0, 1)</span></span><br><span class="line"><span class="comment">//     return res</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ul><li>不难看出这道题仍然用的是回溯算法的模板，需要注意的地方就是可以进行剪枝操作</li><li>剪枝操作一：当传进去的sum已经比要求的目标值大的时候就不用往后找了，直接return</li><li>剪枝操作二：每层循环的时候，还没有放入集合中的元素有k-path.length个，9-i+1是还剩下的元素数，那么9-i+1&gt;&#x3D;k-path.length&#x3D;&gt;&lt;&#x3D; 9-(k-path.length)+1这是第二步剪枝。</li></ul><h3 id="Day-38-Leetcode-17-电话号码的字母组合"><a href="#Day-38-Leetcode-17-电话号码的字母组合" class="headerlink" title="Day 38 Leetcode 17 电话号码的字母组合"></a>Day 38 Leetcode 17 电话号码的字母组合</h3><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">digits</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="keyword">function</span> (<span class="params">digits</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!digits) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> path = [], res = [], k = digits.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> mapLetters = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">1</span>) <span class="keyword">return</span> mapLetters[digits].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">length</span> === k) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> mapLetters[digits[index]]) &#123;</span><br><span class="line">            path.<span class="title function_">push</span>(s)</span><br><span class="line">            <span class="title function_">backtracking</span>(index + <span class="number">1</span>)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>这道题仍然是用回溯的模板解决</li><li>要处理的结果是一个个字符串，可以用字符串来操作，也可以用数组存放字符串的元素然后用join方法连接成字符串。</li><li>首先定义一个数组来模拟手机按键映射字母，也可以用map来映射。</li><li>收集结果：条件就是当数组的元素和给的按键个数一样多的时候，就把连接成的字符串放到结果数组里。</li><li>循环：每次从映射的数组里取出需要取的元素，然后push进path里，进行递归。这里的index指的是题目给的按键的下标，这样digits[index]表示的是选取的按键，mapLetters[digits[index]]表示的是按键代表的字符串，s表示从按键代表的字符串里依次取出元素。</li></ul><h3 id="Day-38-Leetcode-39-组合总和"><a href="#Day-38-Leetcode-39-组合总和" class="headerlink" title="Day 38 Leetcode 39 组合总和"></a>Day 38 Leetcode 39 组合总和</h3><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">candidates</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum = <span class="keyword">function</span> (<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], path = []</span><br><span class="line">    candidates.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">sum, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt; candidates.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(candidates[i])</span><br><span class="line">            sum += candidates[i]</span><br><span class="line">            <span class="title function_">backtracking</span>(sum, i)</span><br><span class="line">            sum -= candidates[i]</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题和77 .组合问题有一些不一样，不过大体上类似</li><li>这道题是要求组合里元素之和为一个特定值，仍然是通过回溯不断地暴力搜索符合条件的元素。</li><li>注意：这里和组合问题不同的地方是，传进startIndex的时候，不用穿i+1而是传i+1，因为元素是可以重复使用的</li><li>终止条件：如果sum&gt;target就不用继续搜索了，直接返回上一层；如果sum&#x3D;&#x3D;&#x3D;target,找到了符合条件的元素，直接放进数组里；</li><li>剪枝：主要优化的就是for循环里面的部分，在一开始可以先给数组排一个序，让它从小到大，然后再for循环里判断，如果当前的sum和当前要取的元素相加已经大于target了，那么没有必要再往后循环了，因为后面一定比这个元素打，所以直接break。</li></ul></li></ul><h3 id="Day-39-Leetcide-40-组合总和②"><a href="#Day-39-Leetcide-40-组合总和②" class="headerlink" title="Day 39 Leetcide 40 组合总和②"></a>Day 39 Leetcide 40 组合总和②</h3><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">candidates</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="keyword">function</span> (<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = [], res = [], </span><br><span class="line">    candidates.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">sum, startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt; candidates.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] === candidates[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; i &gt; startIndex) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="title function_">push</span>(candidates[i])</span><br><span class="line">            sum += candidates[i]</span><br><span class="line">            <span class="title function_">backtracking</span>(sum, i + <span class="number">1</span>)</span><br><span class="line">            sum -= candidates[i]</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">candidates</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum2 = <span class="keyword">function</span> (<span class="params">candidates, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], path = [], k = candidates.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> used = <span class="keyword">new</span> <span class="title class_">Array</span>(k).<span class="title function_">fill</span>(<span class="literal">false</span>), sum = <span class="number">0</span></span><br><span class="line">    candidates.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum === target) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt; k &amp;&amp; sum &lt; target; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] === candidates[i - <span class="number">1</span>] &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span><span class="comment">//剪枝</span></span><br><span class="line">            path.<span class="title function_">push</span>(candidates[i])</span><br><span class="line">            sum += candidates[i]</span><br><span class="line">            used[i] = <span class="literal">true</span></span><br><span class="line">            <span class="title function_">backtracking</span>(i + <span class="number">1</span>)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">            sum -= candidates[i]</span><br><span class="line">            used[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（优化版）：</p><ul><li>这道题和上一道组合总和的题目大致是类似的，不同的点在于，这道题不能给重复使用元素，因此要做一个去重。难点就在于去重</li><li>先给整个数组排序，然后判断，如果当前元素和上一个元素相等，那么就不进入循环，因为一样的值出现的组合是类似的。这里可以用一个used数组来记录元素是否用过。这是一个比较好的设计,之后的回溯算法涉及到的去重也类似这个地方</li><li>这道题的去重体现在树层去重</li><li>used[i-1]&#x3D;&#x3D;&#x3D;true的时候，说明树枝用过,used[i-1]&#x3D;&#x3D;&#x3D;false的时候，说明树层用过</li></ul></li></ul><h2 id="切割字符串问题："><a href="#切割字符串问题：" class="headerlink" title="切割字符串问题："></a>切割字符串问题：</h2><h3 id="Day-40-Leetcode-131-切割回文串"><a href="#Day-40-Leetcode-131-切割回文串" class="headerlink" title="Day 40 Leetcode 131 切割回文串"></a>Day 40 Leetcode 131 切割回文串</h3><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">s, start, end</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] !== s[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> partition = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = [], res = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="property">length</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isPalindrome</span>(s, startIndex, i)) &#123;</span><br><span class="line">                path.<span class="title function_">push</span>(s.<span class="title function_">slice</span>(startIndex, i + <span class="number">1</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span></span><br><span class="line">            <span class="title function_">backtracking</span>(i + <span class="number">1</span>)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题和组合问题其实很类似，不过需要处理的东西改成了字符串。</li><li>这道题的要点有两个，一个是求分割方案，一个是求回文子串。求分割方案实际上和组合问题差不多的。</li><li>结束递归的条件就是startIndex移动到字符串最后位置。</li><li>求回文子串的方法就是首先用双指针法来判断是不是回文子串。[startIndex,i]就是一个回文子串，因此可以判断它是不是回文子串，是的话就放到path里；否则就continue。</li></ul></li></ul><h2 id="子集问题："><a href="#子集问题：" class="headerlink" title="子集问题："></a>子集问题：</h2><h3 id="Day-42-Leetcode-78-子集"><a href="#Day-42-Leetcode-78-子集" class="headerlink" title="Day 42 Leetcode 78 子集"></a>Day 42 Leetcode 78 子集</h3><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> path = [], res = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path))</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;<span class="comment">//这个终止条件可以不写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            path.<span class="title function_">push</span>(nums[i])</span><br><span class="line">            <span class="title function_">backtracking</span>(i + <span class="number">1</span>)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题还是类似的回溯算法的套路，只不过在收集结果的地方会有一些的差别。</li><li>收集结果应该是每一次放进path数组里元素或者是回溯的时候都收集，因此应该放在递归函数的最上层，这样可以收集到所有的子集。</li><li>递归里的终止条件可以不写，因为实际上在for循环里有体现。i从startIndex开始，循环条件是小于数组的大小，因此不可能循环到startIndex大于数组大小。</li></ul></li></ul><h3 id="Day-43-Leetcode-90-子集Ⅱ"><a href="#Day-43-Leetcode-90-子集Ⅱ" class="headerlink" title="Day 43 Leetcode 90 子集Ⅱ"></a>Day 43 Leetcode 90 子集Ⅱ</h3><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> path=[],res=[],used=<span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>)</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)  </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backtracking</span>=(<span class="params">startIndex</span>)=&gt;&#123;</span><br><span class="line">        res.<span class="title function_">push</span>([...path])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=startIndex;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]===nums[i-<span class="number">1</span>]&amp;&amp;!used[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="title function_">push</span>(nums[i])</span><br><span class="line">            used[i]=<span class="literal">true</span></span><br><span class="line">            <span class="title function_">backtracking</span>(i+<span class="number">1</span>)</span><br><span class="line">            used[i]=<span class="literal">false</span></span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backtracking</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题其实就是组合总和和子集的结合体，最主要的就是去重</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript</title>
      <link href="/2023/01/25/Typescript/"/>
      <url>/2023/01/25/Typescript/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-学习笔记"><a href="#TypeScript-学习笔记" class="headerlink" title="TypeScript 学习笔记"></a>TypeScript 学习笔记</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ul><li>是拥有类型的JavaScript超集，可以编译成普通、干净、完整的js代码</li><li>js拥有的特性，ts都支持。</li><li>ts在实现新特性的时候，总是保持和es标准的同步甚至是超前</li><li>不仅增加了类型约束，还包括一些语法的拓展，比如枚举类型、元组类型</li><li>最终会被编译成js代码，不用担心兼容性问题</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>始于JavaScript，归于JavaScript</li><li>是一个强大的工具，用于构建大型项目</li><li>拥有先进的JavaScript</li></ul><h3 id="直接运行typescript"><a href="#直接运行typescript" class="headerlink" title="直接运行typescript"></a>直接运行typescript</h3><ul><li>通过webpack配置本地的ts、编译环境和开启本地服务，可以直接运行在浏览器上</li><li>通过ts-node库来提供执行环境</li></ul><h2 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h2><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><ul><li>var&#x2F;let&#x2F;const  标识符：数据类型（类型注解 type annotion）&#x3D;赋值</li></ul><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><ul><li>声明一个标识符时如果直接进行赋值，那么会根据赋值的类型推导出变量的类型注解</li><li>let推导出来的是通用类型</li><li>const推导出来的是字面量类型</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>number：不区分整数和浮点类型，支持二进制、八进制、十六进制</p></li><li><p>string：是字符串类型，可以用单引号或者双引号表示，支持es6的模板字符串</p></li><li><p>boolean:布尔类型，true&#x2F;false</p></li><li><p>Array：</p><ul><li>明确的指定数组的类型注解：两种写法</li><li>\1. 类型[]: 数组类型（一般采用）</li><li>\2. Array&lt;类型&gt;:数组类型，存放字符串（泛型写法）</li><li>注意：在开发中数组一般存放相同的类型</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">names</span>: <span class="built_in">string</span>[] = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;bca&quot;</span>, <span class="string">&quot;cda&quot;</span>]</span><br><span class="line">names.<span class="title function_">push</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">nums</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">nums.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names, nums)<span class="comment">//[&quot;abc&quot;, &quot;bca&quot;, &quot;cda&quot;][1, 2, 3]</span></span><br><span class="line"><span class="keyword">export</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>Object：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般不直接给object类型，因为代表的是空对象类型</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">info</span>: &#123;<span class="comment">//缺点：必须要有所有要求的类型</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>symbol:定义相同的名称</li><li>null、undefined:数据类型和值是一样的</li><li>自定义对象类型：（别名）</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LyricType</span> = &#123;</span><br><span class="line">  <span class="attr">time</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">text</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的参数类型没有办法推导，要明确地指定</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1+num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数返回值类型可以被推导，也可以指定</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>匿名函数的参数：</p><ul><li>匿名函数最好不要加类型注解，因为本身可能就是有类型的，它会根据上下文来决定类型（上下文类型)</li></ul></li><li><p>可选参数：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PointType</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  z?:<span class="built_in">number</span><span class="comment">//可选类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h4><ul><li>某些情况无法确认类型就可以用any</li><li>any类型就表示不限制标识符的任意类型，并且可以在该标识符上面进行任意的操作</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">id</span>:<span class="built_in">any</span> = <span class="string">&quot;aaaa&quot;</span></span><br><span class="line">id=<span class="number">12345</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><ul><li>如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候我们可以使用any</li></ul><h4 id="unknown类型"><a href="#unknown类型" class="headerlink" title="unknown类型"></a>unknown类型</h4><ul><li>用于描述类型不确定的变量，但是做任何操作都是不合法的</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">unknown</span> = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>)<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ul><li>要求必须进行类型的校验（缩小）才能根据缩小后的类型进行<strong>对应的操作</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">unknown</span> = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> foo === <span class="string">&quot;string&quot;</span>) &#123;<span class="comment">//类型缩小</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><ul><li>在ts中如果一个函数没有任何的返回值那么返回值的类型就是void</li><li>如果返回值是void，也可以返回undefined</li><li>经常用来指定函数类型的返回值是void</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FooType</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span><span class="comment">//返回值是void</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">FooType</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当推导出是void类型的时候，不会对返回值做要求</li><li>但是如果明确定义是void类型的时候，不能有返回值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;bca&quot;</span>, <span class="string">&quot;cbs&quot;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><ul><li>开发中很少实际去定义never类型，某些情况会推导出</li><li>开发框架、工具的时候可能会用到</li><li>封装一些类型工具的时候可以使用never类型体操</li><li>never表示永远不会发生值的类型</li></ul><h4 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h4><ul><li>和数组类型类似，但是可以存放不同的数据类型，取出来的值有明确的类型。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">info3</span>:[<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">number</span>] = [<span class="string">&quot;lx&quot;</span>, <span class="number">18</span>, <span class="number">1.78</span>]</span><br></pre></td></tr></table></figure><ul><li>一般在函数中使用元组类型最多（函数的返回值）</li></ul><h3 id="语法细节"><a href="#语法细节" class="headerlink" title="语法细节"></a>语法细节</h3><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><ul><li>ts类型系统允许我们使用多种运算符从现有类型中构建新类型</li><li>联合类型是由两个或者多个其他类型组成的类型</li><li>表示可以是这些类型中的任何一个值，每一个类型被称为联合成员</li></ul><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul><li>类型别名，可以声明对象类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IdType</span>=<span class="built_in">number</span>|<span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: IdType</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="interface（接口）"><a href="#interface（接口）" class="headerlink" title="interface（接口）"></a>interface（接口）</h4><ul><li>和类型别名相似，也可以声明对象类型，大部分时候两种方法都可以用</li><li>接口中的方法大部分在type中也可以使用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointType1</span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  z?:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>与type的区别：</p><ul><li>type类型可以声明基本类型，使用范围更广</li><li>在声明对象时，interface可以多次声明；type不允许两个相同的别名存在</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Pointype</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> pointType&#123;</span><br><span class="line">  <span class="attr">z</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>interface支持继承</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span> <span class="keyword">extends</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">  <span class="attr">hobby</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>interface可以被类实现</p></li><li><p>总结：如果是非对象类型的定义使用type，对象类型的定义使用interface</p></li></ul><h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><ul><li>两种（多种类型）同时满足，通常是对对象类型交叉的</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NewType</span>=<span class="built_in">number</span> &amp; <span class="built_in">string</span><span class="comment">//never类型，没有意义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICoder</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">coding</span>:<span class="function">()=&gt;</span><span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IPerson</span> &amp; <span class="title class_">ICoder</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">coding</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;coding&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型断言as"><a href="#类型断言as" class="headerlink" title="类型断言as"></a>类型断言as</h4><ul><li>有时候ts无法获取具体的类型信息，name可以使用类型断言</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取DOM元素</span></span><br><span class="line"><span class="keyword">const</span> imgEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.img&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLImageElement</span></span><br><span class="line"><span class="keyword">if</span> (imgEl !== <span class="literal">null</span>) &#123;<span class="comment">//类型缩小</span></span><br><span class="line">  imgEl.<span class="property">src</span> = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">  imgEl.<span class="property">alt</span>=<span class="string">&quot;yyy&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ts类型检测来说是正确的，但本身不太正确</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> age2 = age <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line"><span class="keyword">const</span> age3 = age2 <span class="keyword">as</span> <span class="built_in">string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age3.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><h4 id="非空类型断言"><a href="#非空类型断言" class="headerlink" title="非空类型断言!"></a>非空类型断言!</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.<span class="property">friend</span>!.<span class="property">name</span>=<span class="string">&quot;james&quot;</span></span><br></pre></td></tr></table></figure><ul><li>表示可以确定某个标识值是有值的，可以跳过ts的编译检测</li></ul><h4 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本用法</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span></span><br><span class="line"><span class="comment">//将多个字面量类型联合起来</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span>|<span class="string">&quot;up&quot;</span>|<span class="string">&quot;down&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">d1</span>:<span class="title class_">Direction</span>=<span class="string">&quot;left&quot;</span></span><br></pre></td></tr></table></figure><ul><li>通常情况下使用联合的字面量类型</li><li>字面量推理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url: <span class="built_in">string</span>, method: Method</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ts细节</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;post&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能直接把string类型赋给字面量类型</span></span><br><span class="line"><span class="comment">// request(info.url,info.method)</span></span><br><span class="line"><span class="comment">//解决方案</span></span><br><span class="line"><span class="title function_">request</span>(info.<span class="property">url</span>, info.<span class="property">method</span> <span class="keyword">as</span> <span class="title class_">Method</span>)</span><br><span class="line"><span class="comment">//解决方案2：直接让info对象类型是字面量类型</span></span><br><span class="line"><span class="keyword">const</span> info1 = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;post&quot;</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="title function_">request</span>(info1.<span class="property">url</span>, info1.<span class="property">method</span>)</span><br></pre></td></tr></table></figure><h4 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h4><ul><li><p>通过类似于 typeof padding &#x3D;&#x3D;&#x3D;”number”的判断语句来改变Ts的执行路径，也可以称类型保护</p></li><li><p>第一种：typeof</p></li><li><p>第二种：平等缩小：可以使用switch或者相等的一些字符串来表达相等性（！&#x3D;&#x3D;，&#x3D;&#x3D;…)</p></li><li><p>第三种：instance of:</p><ul><li>判断是不是实例对象</li></ul></li><li><p>第四种：”” in  obj，可以判断某个对象是否有某个属性</p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h4><ul><li><p>函数类型表达式：</p><ul><li>格式：(参数列表)&#x3D;&gt;返回值</li><li>参数的名称不可以省略</li><li>ts对传入函数的参数的个数不检测，因为匿名函数太多了</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">BarType</span> = <span class="function">(<span class="params">num: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">bar</span>: <span class="title class_">BarType</span> = (<span class="attr">args</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>调用签名：函数除了可以被调用，自己也是可以有属性值的</p><ul><li>如果想描述一个带有属性的函数，我们可以在一个对象中写一个<strong>调用签名</strong></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IBar</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">//函数可以调用：函数调用签名</span></span><br><span class="line">  (<span class="attr">num1</span>:<span class="built_in">number</span>):<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>开发中如何选择？</p></li><li><p>1.如果只是描述函数类型本身，函数可以被调用，使用函数类型表达式</p></li><li><p>2.如果在描述函数作为对象可以被调用，同时也有其他属性时，使用函数调用签名</p></li><li><p>构造签名：</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ICTORPerson</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> ():<span class="title class_">Person</span><span class="comment">//构造签名，可以通过new调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factory</span>(<span class="params">fn:ICTORPerson</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><ul><li><p>可选参数</p><ul><li>基本用法：？</li><li>参数类型是什么？number | undefined联合类型</li></ul></li><li><p>默认值：</p><ul><li>有默认值的情况下，参数的类型注解可以省略</li><li>有默认值的参数是可以接受undefined的</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>=<span class="number">100</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x+y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  有默认值的情况下，参数的类型注解可以省略</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>)</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//  有默认值的参数是可以接受默认值的</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>,<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><ul><li><p>剩余参数：</p><ul><li>在js的基础上加类型注解就可以了</li></ul></li></ul><h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h4><ul><li>不可以直接用联合类型</li><li>一般是编写不同的重载签名表示函数可以以不同的方式进行调用</li><li>一般编写两个或者以上的重载签名，然后编写一个通用的签名</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写重载签名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add3</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">number</span></span>):<span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add3</span>(<span class="params">arg1:<span class="built_in">string</span>, arg2:<span class="built_in">string</span></span>):<span class="built_in">string</span></span><br><span class="line"><span class="comment">//编写通用的函数实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add3</span>(<span class="params">arg1: <span class="built_in">any</span>, arg2: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg1+arg2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>有实现体的函数不能直接调用</p></li><li><p>如何选择联合类型和函数重载？</p><ul><li>在可能的情况下，尽量使用联合类型实现</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength0</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数重载</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength1</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength1</span>(<span class="params">arg: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength1</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//联合类型实现(可以用尽量用)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength2</span>(<span class="params">arg: (<span class="built_in">string</span> | <span class="built_in">any</span>)[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象类型实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength3</span>(<span class="params">arg:&#123;length:<span class="built_in">number</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul><li>默认情况下this是any类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">studying</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//默认情况下this是any类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="string">&quot;studying&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">studying</span>()</span><br></pre></td></tr></table></figure><ul><li>可以在函数的第一个参数指定this类型，this参数会在编译后被抹除</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"><span class="variable language_">this</span>: &#123; name: <span class="built_in">string</span> &#125;,info:&#123;name:<span class="built_in">string</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,info)</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">call</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;why&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;lx&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="相关的内置工具："><a href="#相关的内置工具：" class="headerlink" title="相关的内置工具："></a>相关的内置工具：</h5><ul><li><p>ThisParameterType：</p><ul><li>用于提取一个函数类型Type的this参数类型</li><li>如果这个函数类型没有this参数返回unknown</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"><span class="variable language_">this</span>: &#123; name: <span class="built_in">string</span> &#125;,info:&#123;name:<span class="built_in">string</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,info)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooType</span> = <span class="keyword">typeof</span> foo</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooThisType</span>=<span class="title class_">ThisParameterType</span>&lt;<span class="title class_">FooType</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>OmitThisParameter</p><ul><li>用于移除一个函数类型Type的this参数类型并返回当前的函数类型</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PureFooType</span>=<span class="title class_">OmitThisParameter</span>&lt;<span class="title class_">FooType</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>ThisType</p><ul><li>不返回转换后的类型，被用作标记一个上下文的this类型</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IState</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStore</span> &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">IState</span></span><br><span class="line">  <span class="attr">eating</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">store</span>: <span class="title class_">IStore</span> &amp; <span class="title class_">ThisType</span>&lt;<span class="title class_">IState</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">eating</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h4 id="类的使用class"><a href="#类的使用class" class="headerlink" title="类的使用class"></a>类的使用class</h4><ul><li>类中包含特有的属性和方法</li><li>成员属性在类中必须要声明</li><li>如果在严格模式下不想给属性初始化，可以使用name!:string这种语法</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="comment">//成员属性</span></span><br><span class="line">  name=<span class="string">&quot;&quot;</span><span class="comment">//初始化类型推导</span></span><br><span class="line">  age=<span class="number">0</span></span><br><span class="line">  <span class="comment">// name!:string</span></span><br><span class="line">  <span class="comment">// age!:number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的继承extends"><a href="#类的继承extends" class="headerlink" title="类的继承extends"></a>类的继承extends</h4><ul><li>用extends关键字实现继承，子类中用super来访问父类</li></ul><h4 id="类的成员修饰符"><a href="#类的成员修饰符" class="headerlink" title="类的成员修饰符"></a>类的成员修饰符</h4><ul><li><p>public：在任何地方可见，共有的属性或方法（默认）</p></li><li><p>private：仅在同一类中（内部）可见</p><ul><li>想要在外界修改必须加setter&#x2F;getter：对属性的访问进行拦截操作</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="comment">//私有属性：属性前面会加_</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">_age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newValue: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = newValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>(): <span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_age</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>protected：仅在类自身及子类中可见、受保护的属性或方法（外界也不可以访问）</li><li>readonly：只能读取不能写入</li></ul><h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><ul><li>把一个构造函数参数转成类的属性</li><li>是一种<strong>语法糖</strong></li><li><strong>在构造函数前添加一个可见性修饰符，相当于创建了变量并且赋值</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//语法糖</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span>,</span>) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lx&quot;</span>, <span class="number">1.85</span>)</span><br></pre></td></tr></table></figure><h4 id="抽象类abstract"><a href="#抽象类abstract" class="headerlink" title="抽象类abstract"></a>抽象类abstract</h4><ul><li>继承是多态使用的前提，但是父类本身可能并不需要对某些方法的实现，可以用抽象类</li><li>抽象方法只能出现在抽象类中</li><li>抽象类不能被实例化</li><li>抽象类可以包含抽象方法，也可以包含有实现体的方法</li><li>抽象方法必须被实现</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="comment">//getArea方法只有声明没有实现体</span></span><br><span class="line">  <span class="comment">//实现让子类自己实现</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getArea</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型检测-鸭子类型"><a href="#类型检测-鸭子类型" class="headerlink" title="类型检测-鸭子类型"></a>类型检测-鸭子类型</h4><ul><li>如果一只鸟，走起来像鸭子，游起来想鸭子，看起来像鸭子，name可以认为它就是鸭子</li><li>鸭子类型只关心属性和行为，不关心具体是不是类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">p: Person</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>, p.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printPerson</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;LX&quot;</span>, <span class="number">19</span>))</span><br><span class="line"><span class="title function_">printPerson</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;hh&quot;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h4><ul><li><p>类本身可以作为一种数据类型</p></li><li><p>类的作用</p><ul><li>可以创建类对应的实例对象</li><li>类本身可以作为这个实例的类型</li><li>类可以当做一个有构造签名的函数</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;lx&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factory</span>(<span class="params">cotr: <span class="keyword">new</span> () =&gt; <span class="built_in">void</span></span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">factory</span>(<span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure><h4 id="对象类型的类型修饰符"><a href="#对象类型的类型修饰符" class="headerlink" title="对象类型的类型修饰符"></a>对象类型的类型修饰符</h4><ul><li>?：可选属性</li><li>readonly:只读</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义对象类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Iperson</span> = &#123;</span><br><span class="line">  <span class="comment">//?可选属性</span></span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span>&#123;</span><br><span class="line">  name?: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">score</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><ul><li>有时候不能提前知道一个类型里所有属性的名字，但是你知道这些值的特征，这时候就可以用索引签名来描述可能的值的类型</li><li>索引签名的属性类型必须是string或者是number</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ICollection</span> &#123;</span><br><span class="line">  <span class="comment">//索引签名</span></span><br><span class="line">  [<span class="attr">index</span>:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span><span class="comment">//必须满足索引签名的要求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过数字类型访问索引时，最终都会转换成string类型</li><li></li></ul><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><ul><li>可以从其他接口中继承过来属性，不支持多继承</li><li>减少了相同代码的重复编写</li><li>如果使用的三方库，给我们定义了一些属性，自定义一个接口，同时希望自定义接口拥有第三方库中某一个属性</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span> <span class="keyword">extends</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">  <span class="attr">score</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">IStudent</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">score</span>:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的类实现"><a href="#接口的类实现" class="headerlink" title="接口的类实现"></a>接口的类实现</h4><ul><li>接口中所有属性和方法都必须实现</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">score</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span>, <span class="keyword">public</span> score: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> stu</span><br></pre></td></tr></table></figure><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ul><li>抽象类是事物的抽象，用来捕捉子类的通用特性；接口通常是一些行为的描述</li><li>抽象类通常用于一系列关系紧密的类之间，接口只是用来描述一个类应该具有什么行为</li><li>接口可以被多层实现，而抽象类只能单一继承</li><li>抽象类中可以有实现体，接口中只能有函数的声明</li><li>抽象类是对事物的抽象，表达的是is a的关系</li><li>接口是对行为的抽象，表达的是has a的关系</li></ul><h4 id="严格的字面量赋值检测"><a href="#严格的字面量赋值检测" class="headerlink" title="严格的字面量赋值检测"></a>严格的字面量赋值检测</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义info，类型是IPerson类型</span></span><br><span class="line"><span class="comment">//奇怪的现象1</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="comment">//不可以新增属性</span></span><br><span class="line">  <span class="attr">height</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IPerson</span> = obj<span class="comment">//不报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">info</span>: <span class="title class_">IPerson</span> =&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="comment">//不可以新增属性</span></span><br><span class="line">  <span class="attr">height</span>: <span class="number">19</span></span><br><span class="line">&#125;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">person: IPerson</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printPerson</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="number">1.88</span> &#125;)<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">const</span> person=&#123; <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="number">1.88</span> &#125;</span><br><span class="line"><span class="title function_">printPerson</span>(person)<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure><ul><li>第一次创建的对象字面量，称之为**新鲜的,**会进行严格的类型检测，必须完全满足要求的类型，不能有多余的属性</li><li>当一个新的对象字面量分配给一个变量或传递给一个非空目标类型的参数时，对象字面量指定目标类型中不存在的属性时错误的</li><li>当类型断言或对象字面量的类型扩大时，新鲜度会消失</li></ul><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><ul><li>枚举就是将一组可能出现的值一个个列举出来定义在一个类中</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;</span><br><span class="line">  <span class="variable constant_">UP</span>, <span class="variable constant_">DOWN</span>, <span class="variable constant_">LEFT</span>, <span class="variable constant_">RIGHT</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">d1</span>:<span class="title class_">Direction</span>=<span class="title class_">Direction</span>.<span class="property">DOWN</span></span><br></pre></td></tr></table></figure><ul><li>枚举类型默认是有值的，第一个是0</li><li>位运算方便计算</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">  <span class="title class_">Read</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Write</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  foo = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">d1</span>: <span class="title class_">Direction</span> = <span class="title class_">Direction</span>.<span class="property">LEFT</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>类型参数化</li><li>会自动进行类型推导</li><li>方式一：使用&lt;&gt;传递类型</li><li>方式二：类型推导</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> bar&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>:<span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res1 = bar&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">const</span> res2 = bar&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="comment">//省略的写法</span></span><br><span class="line"><span class="keyword">const</span> res3=<span class="title function_">bar</span>(<span class="string">&quot;aaaa&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>接口&#x2F;类也可以使用泛型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span>&lt;T,E&gt; &#123;</span><br><span class="line">  <span class="attr">name</span>: E</span><br><span class="line">  <span class="attr">age</span>: T,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">stu</span>: <span class="title class_">IPerson</span>&lt;<span class="built_in">number</span>,<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;<span class="title class_">Type</span> = <span class="built_in">number</span>&gt;&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="title class_">Type</span></span><br><span class="line">  <span class="attr">y</span>: <span class="title class_">Type</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: Type, y: Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">x</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;321&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">y</span>)</span><br></pre></td></tr></table></figure><ul><li>也可以有默认值</li></ul><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><h4 id="简单泛型约束"><a href="#简单泛型约束" class="headerlink" title="简单泛型约束"></a>简单泛型约束</h4><ul><li>希望传入的参数有约束性</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span>&#123;</span><br><span class="line">  <span class="attr">length</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> getLength&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">arg</span>: T) &#123;</span><br><span class="line">  <span class="keyword">return</span> arg.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> length=<span class="title function_">getLength</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> length2 =<span class="title function_">getLength</span>([<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>])</span><br><span class="line"><span class="keyword">const</span> length3 =<span class="title function_">getLength</span>(&#123;<span class="attr">length</span>:<span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>type相当于是一个变量，用于记录本次调用的类型，所以在整个函数的执行周期中，一直保留着参数的类型</li><li>表示传入的类型必须有这个属性，也可以有其他属性</li></ul><h4 id="泛型约束-1"><a href="#泛型约束-1" class="headerlink" title="泛型约束"></a>泛型约束</h4><ul><li>在泛型约束中使用参数，可以声明一个类型参数，这个类型参数被其他类型参数约束</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的key类型是obj当中key的其中之一</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPersonKeys</span>=keyof <span class="title class_">IPerson</span><span class="comment">//&quot;name&quot;| &quot;age&quot;</span></span><br><span class="line"><span class="keyword">function</span> getObjectProperty&lt;O,K <span class="keyword">extends</span> keyof O&gt;(<span class="attr">obj</span>:O, <span class="attr">key</span>:K) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>keyof 获取所有属性的联合类型</li></ul><h4 id="映射类型（Mapped-Types"><a href="#映射类型（Mapped-Types" class="headerlink" title="映射类型（Mapped Types)"></a>映射类型（Mapped Types)</h4><ul><li>有时候，一个类型需要基于另一个类型，但是又不想拷贝就可以用到</li><li>大部分内置的工具都是通过映射类型实现的</li><li>大多数类型体操的题目也是通过映射类型完成的</li><li>映射类型建立在索引签名的基础上</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝一份IPerson</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MapPerson</span>&lt;<span class="title class_">Type</span>&gt;&#123;</span><br><span class="line">  <span class="comment">// [index: number]: any普通索引签名</span></span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]:<span class="title class_">Type</span>[<span class="title class_">Property</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span>=<span class="title class_">MapPerson</span>&lt;<span class="title class_">IPerson</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>映射类型不能使用interface定义</li></ul><h5 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h5><ul><li>readonly</li><li>?</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPerson</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]?:<span class="title class_">Type</span>[<span class="title class_">Property</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IPersonOptional</span>=<span class="title class_">MyPerson</span>&lt;<span class="title class_">IPerson</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>可以通过-和+来添加或者删除修饰符，默认使用+</li></ul><h5 id="内置工具和类型体操"><a href="#内置工具和类型体操" class="headerlink" title="内置工具和类型体操"></a>内置工具和类型体操</h5><ul><li>typescript的目的是为js添加一套类型校验系统，因此不得不增加更多附加的内容以适配js的灵活性</li><li>ts是一种支持类型编程的类型系统</li><li>如果在开发框架、库或者通用性的工具为了考虑各种适配就需要使用</li><li>ts本身为我们提供了类型工具，帮助我们辅助进行类型转换</li></ul><h2 id="Ts语法拓展"><a href="#Ts语法拓展" class="headerlink" title="Ts语法拓展"></a>Ts语法拓展</h2><h3 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h3><ul><li>Ts中使用的最主要的是Es module模块化方案（import、export语法）</li></ul><h4 id="非模块（non-module"><a href="#非模块（non-module" class="headerlink" title="非模块（non-module)"></a>非模块（non-module)</h4><ul><li>如果有一个文件没有任何import或者export，但是希望他被作为模块处理，那么可以使用**export{}**，这样可以把文件改成一个没有任何导出内容的模块，这样不会和全局中其他文件的变量或者类型冲突</li></ul><h4 id="内置类型导入（inline-type-imports）"><a href="#内置类型导入（inline-type-imports）" class="headerlink" title="内置类型导入（inline type imports）"></a>内置类型导入（inline type imports）</h4><ul><li>允许单独导入类型</li><li>如果导入的是类型,推荐在类型的前面加上type关键字，表明被导入的是一个类型，这样在编译的时候会安全删除</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">type</span> <span class="title class_">IPerson</span>,<span class="keyword">type</span> <span class="title class_">IDType</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/type&quot;</span></span><br></pre></td></tr></table></figure><h4 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h4><ul><li>命名空间在ts早期称为内部模块，目的是将一个模块内部再话费成不同的作用域，防止命名冲突</li><li>更推荐使用ES module</li><li>命名空间里的变量、函数等也要导出</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> date&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2023-01-20&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> price &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">price</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;$&quot;</span>+price</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型的查找"><a href="#类型的查找" class="headerlink" title="类型的查找"></a>类型的查找</h3><ul><li><p>一种特殊的ts文件：.d.ts文件</p><ul><li>他用来做类型的声明，称之为类型声明或者类型定义文件</li><li>仅仅用来作类型检测，告知ts我们有哪些类型</li></ul></li><li><p>ts会在哪找类型声明：内置类型声明、外部定义类型声明、自己定义类型声明</p></li><li><p>内置类型声明：ts自带的，帮助我们内置了js运行时的一些标准化api声明文件</p><ul><li>TypeScript 使用模式命名这些声明文件lib.[something].d.ts。</li></ul></li><li><p>外部定义类型声明:第三方库</p><ul><li>在自己库中进行声明(例如axios)</li><li>通过社区的一个公有库DefinitelyTyped存放类型声明文件</li></ul></li><li><p>外部定义类型声明：自定义声明</p><ul><li>使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</li><li>给自己的代码中声明一些类型，方便在其他地方直接进行使用；</li></ul></li></ul><h4 id="declare-声明模块"><a href="#declare-声明模块" class="headerlink" title="declare 声明模块"></a>declare 声明模块</h4><ul><li>语法：declare module 模块名 {}</li><li>在声明模块的内部，我们可以通过 export 导出对应库的类、函数等</li></ul><h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><ul><li>让ts compiler在编译的时候知道如何去编译</li><li>让编辑器可以按照正确的方式识别ts代码</li><li>在调用 tsc 命令并且没有其它输入文件参数时，编译器将由当前目录开始向父级目录寻找包含 tsconfig 文件的目录。</li><li>文档：<a href="https://www.typescriptlang.org/tsconfig">https://www.typescriptlang.org/tsconfig</a></li></ul><h5 id="重要的选项"><a href="#重要的选项" class="headerlink" title="重要的选项"></a>重要的选项</h5><ul><li><p>compilerOptions:编译配置</p><ul><li>target:目标代码，编译出什么类型的代码（es2016,es5,esnext…)</li><li>module:生成代码时候使用的模块化</li><li>strict:严格类型检查开关</li><li>noImpicitAny:不允许有模糊的any类型</li><li>jsx:jsx的处理方式</li><li>allowJs:允不允许js代码出现</li><li>moduleResolution：按照node的模块解析规则</li><li>skipLibCheck:跳过对整个库进行类类型检查，而仅仅检查用到的类型</li><li>exModuleInterop:允许es module和commonjs相互调用</li><li>allowSyntheticDefaultImports:允许合成默认模块导出，</li><li>sourceMap:是否要生成sourcemap文件</li><li>baseUrl:文件路径在解析时的基本url</li><li>paths:路径的映射设置，类似于别名</li><li>lib:指定需要用到的库</li></ul></li><li><p>files:编写一个数组，指定哪些ts文件是需要编译的</p></li><li><p>include:编写一个数组，指定哪些文件在项目中</p></li><li><p>exclude:编写一个数组，指定在include中排除那些文件</p></li></ul><h2 id="内置工具和类型体操-1"><a href="#内置工具和类型体操-1" class="headerlink" title="内置工具和类型体操"></a>内置工具和类型体操</h2><ul><li><p>TypeScript的目的是为JavaScript添加一套类型校验系统，因为JavaScript本身的灵活性，也让TypeScript类型系统不得不增加更附加的功能以适配JavaScript的灵活性；</p></li><li><p>这种类型编程系统为TypeScript增加了很大的灵活度，同时也增加了它的难度：</p></li><li><p>在开发一些框架、库，或者通用性的工具，为了考虑各种适配的情况，就需要使用类型编程；</p></li><li><p>TypeScript本身为我们提供了类型工具，帮助我们辅助进行类型转换（前面有用过关于this的类型工具）。</p></li><li><p><a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a></p></li></ul><h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><ul><li>很多时候要根据输入的值（类型）来决定输出的值（类型）</li><li>类似于js的三元表达式</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IDType</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="comment">//判断number是否是继承字IDType</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ResType</span> = <span class="built_in">number</span> <span class="keyword">extends</span> <span class="title class_">IDType</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="条件类型推断infer"><a href="#条件类型推断infer" class="headerlink" title="条件类型推断infer"></a>条件类型推断infer</h4><ul><li>可以从正在比较的类型中推断类型，然后在<strong>true分支里引用该推断结果</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CalcFnType</span> = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型体操题目:MyReturnType</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyParameterType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer A) =&gt; <span class="built_in">any</span> ? A : <span class="built_in">never</span></span><br><span class="line"><span class="comment">//获取一个函数的返回值类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooReturnType</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> foo&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CalcReturnType</span> = <span class="title class_">MyReturnType</span>&lt;<span class="title class_">CalcFnType</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CalcParameterType</span>=<span class="title class_">MyParameterType</span>&lt;<span class="title class_">CalcFnType</span>&gt;</span><br><span class="line"><span class="keyword">export</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="分发条件类型"><a href="#分发条件类型" class="headerlink" title="分发条件类型"></a>分发条件类型</h4><ul><li>在泛型中使用条件类型的时候，如果传入一个联合类型，就会变成<strong>分发的</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> toArray&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>? T[]:<span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumArray</span> = toArray&lt;<span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumAndStrArray</span> = toArray&lt;<span class="built_in">number</span>|<span class="built_in">string</span>&gt;<span class="comment">//number[]|string[]</span></span><br></pre></td></tr></table></figure><h3 id="内置工具"><a href="#内置工具" class="headerlink" title="内置工具"></a>内置工具</h3><h4 id="Partial-lt-gt"><a href="#Partial-lt-gt" class="headerlink" title="Partial&lt;&gt;:"></a>Partial&lt;&gt;:</h4><ul><li>把一个对象内部所有成员变成可选的</li></ul><h4 id="Required-lt-gt"><a href="#Required-lt-gt" class="headerlink" title="Required&lt;&gt;:"></a>Required&lt;&gt;:</h4><ul><li>把一个对象内部所有成员变成必选的</li></ul><h4 id="Readonly-lt-gt"><a href="#Readonly-lt-gt" class="headerlink" title="Readonly&lt;&gt;:"></a>Readonly&lt;&gt;:</h4><ul><li>把一个对象内部所有成员变成readonly的</li></ul><h4 id="Record-lt-keys-T-gt"><a href="#Record-lt-keys-T-gt" class="headerlink" title="Record&lt;keys,T&gt;:"></a>Record&lt;keys,T&gt;:</h4><ul><li>key必须是第一个参数里的</li><li>值的类型必须是第二个参数的类型</li></ul><h4 id="Pick-lt-T，Keys-gt"><a href="#Pick-lt-T，Keys-gt" class="headerlink" title="Pick&lt;T，Keys&gt;:"></a>Pick&lt;T，Keys&gt;:</h4><ul><li>取出对应类型中的一些属性</li></ul><h4 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type,Keys&gt;:"></a>Omit&lt;Type,Keys&gt;:</h4><ul><li>用于构造一个类型，从type里面去掉一些属性</li></ul><h4 id="Exclude-lt-UnionType-ExcludeMembers-gt"><a href="#Exclude-lt-UnionType-ExcludeMembers-gt" class="headerlink" title="Exclude&lt;UnionType,ExcludeMembers&gt;:"></a>Exclude&lt;UnionType,ExcludeMembers&gt;:</h4><ul><li>从联合类型里面 排除了所有可以赋给ExcludeMembers的类型</li></ul><h4 id="Extract-lt-UnionType-ExtractMembers-gt"><a href="#Extract-lt-UnionType-ExtractMembers-gt" class="headerlink" title="Extract&lt;UnionType,ExtractMembers&gt;:"></a>Extract&lt;UnionType,ExtractMembers&gt;:</h4><ul><li>从联合类型里面提取了所有可以赋给ExcludeMembers的类型</li></ul><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable:"></a>NonNullable<Type>:</h4><ul><li>从联合类型里面提取了所有可以赋给ExcludeMembers的类型</li></ul><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType:"></a>ReturnType<Type>:</h4><ul><li>返回返回值类型</li></ul><h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType:"></a>InstanceType<Type>:</h4><ul><li>构造一个由所有type的构造函数所构成的类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">//typeof Person ：构造函数具体的类型</span></span><br><span class="line"><span class="comment">//InstanceType:构造函数创建出来的实例对象的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPerson</span> = <span class="title class_">InstanceType</span>&lt;<span class="keyword">typeof</span> <span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>: <span class="title class_">MyPerson</span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> factory &lt; T <span class="keyword">extends</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt;(<span class="attr">ctor</span>: T) :<span class="title class_">InstanceType</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title function_">factory</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="keyword">export</span> &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2023/01/16/2023.01.16%E6%A0%91/"/>
      <url>/2023/01/16/2023.01.16%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Day22-二叉树理论基础"><a href="#Day22-二叉树理论基础" class="headerlink" title="Day22 二叉树理论基础"></a>Day22 二叉树理论基础</h1><ul><li><p>种类：</p><ul><li>满二叉树：每一层都是满结点的树，有2的k次方-1个结点（k为层数）。</li><li>完全二叉树：除底层之外，其它层都为满的树，但底层一定是从左到右连续的。最多有2的k次方-1个结点</li><li>二叉搜索树：搜索级别O(logn)，结点有顺序，每个左节点都小于根节点，每个右节点都大于根节点</li><li>平衡二叉搜索树：在二叉搜索树的基础上，要求左子树和右子树的高度的绝对值不超过1</li></ul></li><li><p>存储方式:</p><ul><li>链式存储</li><li>顺序存储</li></ul></li><li><p>遍历方式：</p><ul><li>深度优先：前、中、后序遍历</li><li>广度优先：层序遍历</li></ul></li></ul><h1 id="Day-22-Leetcode-144-前序遍历"><a href="#Day-22-Leetcode-144-前序遍历" class="headerlink" title="Day 22 Leetcode 144 前序遍历"></a>Day 22 Leetcode 144 前序遍历</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">front</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span></span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">front</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="title function_">front</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">front</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：递归</p><ul><li>递归三要素：确定递归函数的参数和返回值，确定终止条件，确定单层递归的逻辑</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.left = (left===undefined ? null : left)</span><br><span class="line"> *     this.right = (right===undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var preorderTraversal = function (root) &#123;</span><br><span class="line">    //迭代</span><br><span class="line">    const res = [], stack = []</span><br><span class="line">    if (!root) return res</span><br><span class="line">    stack.push(root)</span><br><span class="line">    let temp = null</span><br><span class="line">    while (stack.length) &#123;</span><br><span class="line">        temp = stack.pop()</span><br><span class="line">        res.push(temp.val)</span><br><span class="line">        temp.right &amp;&amp; stack.push(temp.right)</span><br><span class="line">        temp.left &amp;&amp; stack.push(temp.left)</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：非递归（迭代）</p><ul><li>迭代法是用栈来保存的</li><li>首先将根节点加入栈中，然后进入循环</li><li>弹出根节点，并且将值压入res中，然后判断左右孩子存不存在</li><li>注意：这里应该先压入右孩子再压入左孩子，因为栈是先进后出的，这样才能保证左节点先处理</li></ul></li></ul><h1 id="Day-22-Leetcode-94-中序遍历"><a href="#Day-22-Leetcode-94-中序遍历" class="headerlink" title="Day 22 Leetcode 94 中序遍历"></a>Day 22 Leetcode 94 中序遍历</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">middle</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span></span><br><span class="line">        <span class="title function_">middle</span>(root.<span class="property">left</span>)</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">middle</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">middle</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.left = (left===undefined ? null : left)</span><br><span class="line"> *     this.right = (right===undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var inorderTraversal = function (root) &#123;</span><br><span class="line">    //迭代</span><br><span class="line">    const stack = [], res = []</span><br><span class="line">    if (!root) return res</span><br><span class="line">    let cur = root</span><br><span class="line">    while (stack.length||cur) &#123;</span><br><span class="line">        if (cur !== null) &#123;</span><br><span class="line">            stack.push(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.push(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：非递归（迭代）</p><ul><li>和前序、后序的非递归遍历有些不同，遍历的顺序和处理的顺序不同</li><li>用cur来遍历节点，用stack来记录遍历过的节点</li><li>如果当前cur遍历的节点不是空节点，那么就加入到stack中，并且访问cur的左节点</li><li>如果cur是空，那么意味着遍历到叶子节点了，因此从stack中弹出元素，也就是cur的根节点来更新cur的值，并且把弹出的元素放到res里，再访问右孩子。</li></ul></li></ul><h1 id="Day-22-Leetcode-146-后序遍历"><a href="#Day-22-Leetcode-146-后序遍历" class="headerlink" title="Day 22 Leetcode 146 后序遍历"></a>Day 22 Leetcode 146 后序遍历</h1><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">back</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span></span><br><span class="line">        <span class="title function_">back</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="title function_">back</span>(root.<span class="property">right</span>)</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">back</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.left = (left===undefined ? null : left)</span><br><span class="line"> *     this.right = (right===undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var postorderTraversal = function(root) &#123;</span><br><span class="line">    //迭代</span><br><span class="line">    const res=[],stack=[root]</span><br><span class="line">    if(!root)return res</span><br><span class="line">    let temp=null</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        temp=stack.pop()</span><br><span class="line">        res.push(temp.val)</span><br><span class="line">        temp.left&amp;&amp;stack.push(temp.left)</span><br><span class="line">        temp.right&amp;&amp;stack.push(temp.right)</span><br><span class="line">    &#125;</span><br><span class="line">    return res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：非递归（迭代）</p><ul><li>和先序遍历的迭代法差不多，但是要先将压入左节点再压入右节点，这样得到的res是中右左，然后进行一次反转就可以得到后序遍历</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">back</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span></span><br><span class="line">        <span class="title function_">back</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="title function_">back</span>(root.<span class="property">right</span>)</span><br><span class="line">        res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">back</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.left = (left===undefined ? null : left)</span><br><span class="line"> *     this.right = (right===undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var postorderTraversal = function(root) &#123;</span><br><span class="line">    //迭代</span><br><span class="line">    const res=[],stack=[root]</span><br><span class="line">    if(!root)return res</span><br><span class="line">    let temp=null</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        temp=stack.pop()</span><br><span class="line">        res.push(temp.val)</span><br><span class="line">        temp.left&amp;&amp;stack.push(temp.left)</span><br><span class="line">        temp.right&amp;&amp;stack.push(temp.right)</span><br><span class="line">    &#125;</span><br><span class="line">    return res.reverse()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：非递归（迭代）</p><ul><li>和先序遍历的迭代法差不多，但是要先将压入左节点再压入右节点，这样得到的res是中右左，然后进行一次反转就可以得到后序遍历</li></ul></li></ul><h1 id="层序遍历题目"><a href="#层序遍历题目" class="headerlink" title="层序遍历题目"></a>层序遍历题目</h1><h2 id="Day-22-Leetcode-102-二叉树的层序遍历"><a href="#Day-22-Leetcode-102-二叉树的层序遍历" class="headerlink" title="Day 22 Leetcode 102 二叉树的层序遍历"></a>Day 22 Leetcode 102 二叉树的层序遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [], res = []</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> queuelevel=[]</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = queue.<span class="title function_">shift</span>()</span><br><span class="line">            queuelevel.<span class="title function_">push</span>(temp.<span class="property">val</span>)</span><br><span class="line">            temp.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(temp.<span class="property">left</span>)</span><br><span class="line">            temp.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(queuelevel)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：<ul><li>层序遍历也很简单，就是一种广度优先遍历</li><li>首先把根节点放到队列里面，记录下此时的队列大小为1，也就是判断要弹出多少个元素</li><li>在进入一个循环，队列可以做到先进先出的特点，因此用队列比较合适</li><li>每一层用一个一维数组来记录</li><li>根节点判断完之后，开始判断它的左右节点并且放到队列里</li></ul></li></ul><h2 id="Day-22-Leetcode-107-二叉树的层序遍历Ⅱ"><a href="#Day-22-Leetcode-107-二叉树的层序遍历Ⅱ" class="headerlink" title="Day 22 Leetcode 107 二叉树的层序遍历Ⅱ"></a>Day 22 Leetcode 107 二叉树的层序遍历Ⅱ</h2><h3 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrderBottom = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], queue = []</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> queuelevel=[]</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue.<span class="title function_">shift</span>()</span><br><span class="line">            queuelevel.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(queuelevel)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">reverse</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：<ul><li>层序遍历之后再反转数组就可以了</li></ul></li></ul><h2 id="Day-22-Leetcode-199-二叉树的右视图"><a href="#Day-22-Leetcode-199-二叉树的右视图" class="headerlink" title="Day 22 Leetcode 199 二叉树的右视图"></a>Day 22 Leetcode 199 二叉树的右视图</h2><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rightSideView = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [], res = []</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> queuelevel=[]</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> node=queue.<span class="title function_">shift</span>()</span><br><span class="line">            queuelevel.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(queuelevel[queuelevel.<span class="property">length</span>-<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>题目的意思就是取每一层的最后一个元素，可以用层序遍历先找到每一层的元素，然后把每一层的最后一个元素放到结果数组res里就可以了</li></ul></li></ul><h2 id="Day-22-Leetcode-639-二叉树的层平均值"><a href="#Day-22-Leetcode-639-二叉树的层平均值" class="headerlink" title="Day 22 Leetcode 639 二叉树的层平均值"></a>Day 22 Leetcode 639 二叉树的层平均值</h2><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> averageOfLevels = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue=[],res=[]</span><br><span class="line">    <span class="keyword">if</span>(root!==<span class="literal">null</span>)queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> temp=size</span><br><span class="line">        <span class="keyword">let</span> queueTotal=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            queueTotal+=node.<span class="property">val</span></span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(queueTotal/temp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>层序遍历之后获得每一层的层总和再除以每一层的元素数就可以了。可以用temp存储一下size</li></ul></li></ul><h2 id="Day-22-Leetcode-429-N叉树的层序遍历"><a href="#Day-22-Leetcode-429-N叉树的层序遍历" class="headerlink" title="Day 22 Leetcode 429 N叉树的层序遍历"></a>Day 22 Leetcode 429 N叉树的层序遍历</h2><h3 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node|null</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue=[],res=[]</span><br><span class="line">    <span class="keyword">if</span>(root!==<span class="literal">null</span>)queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> queueLevel=[]</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            queueLevel.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ;i&lt;node.<span class="property">children</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                queue.<span class="title function_">push</span>(node.<span class="property">children</span>[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(queueLevel)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这题和二叉树的层序遍历的区别在于，不存在左右子树，而是存在孩子，只需要在遍历每一层的时候，把所有的孩子都放到队列中就可以了。</li></ul></li></ul><h2 id="Day-22-Leetcode-515-在每个树行中寻找最大值"><a href="#Day-22-Leetcode-515-在每个树行中寻找最大值" class="headerlink" title="Day 22 Leetcode 515 在每个树行中寻找最大值"></a>Day 22 Leetcode 515 在每个树行中寻找最大值</h2><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestValues = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res=[],queue=[]</span><br><span class="line">    <span class="keyword">if</span>(root)queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> queueMax=-<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="keyword">if</span>(queueMax&lt;node.<span class="property">val</span>)queueMax=node.<span class="property">val</span></span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(queueMax)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>仍然是套用层序遍历的模板，在每一行遍历的时候比较除最大值</li></ul></li></ul><h2 id="Day-23-Leetcode-116-填充每个结点的下一个右侧结点指针"><a href="#Day-23-Leetcode-116-填充每个结点的下一个右侧结点指针" class="headerlink" title="Day 23 Leetcode 116 填充每个结点的下一个右侧结点指针"></a>Day 23 Leetcode 116 填充每个结点的下一个右侧结点指针</h2><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, left, right, next) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val === undefined ? null : val;</span></span><br><span class="line"><span class="comment"> *    this.left = left === undefined ? null : left;</span></span><br><span class="line"><span class="comment"> *    this.right = right === undefined ? null : right;</span></span><br><span class="line"><span class="comment"> *    this.next = next === undefined ? null : next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> connect = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue = []</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">let</span> queuelevel = []</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            queuelevel.<span class="title function_">push</span>(node)</span><br><span class="line">            node.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queuelevel.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            queuelevel[i].<span class="property">next</span>=queuelevel[i+<span class="number">1</span>]?queuelevel[i+<span class="number">1</span>]:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>利用层序遍历的特点，保存下每一层所有的节点，然后用一个循环从第一个开始给赋值next就可以了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, left, right, next) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val === undefined ? null : val;</span></span><br><span class="line"><span class="comment"> *    this.left = left === undefined ? null : left;</span></span><br><span class="line"><span class="comment"> *    this.right = right === undefined ? null : right;</span></span><br><span class="line"><span class="comment"> *    this.next = next === undefined ? null : next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> connect = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        root.<span class="property">left</span>.<span class="property">next</span> = root.<span class="property">right</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.<span class="property">right</span>.<span class="property">next</span> = root.<span class="property">next</span>.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">connect</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="title function_">connect</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>利用递归的方法，先把根节点的左右子节点连接起来，再递归左右子节点作为根节点</li></ul></li></ul><h2 id="Day-23-Leetcode-117-填充每个结点的下一个右侧结点指针Ⅱ"><a href="#Day-23-Leetcode-117-填充每个结点的下一个右侧结点指针Ⅱ" class="headerlink" title="Day 23 Leetcode 117 填充每个结点的下一个右侧结点指针Ⅱ"></a>Day 23 Leetcode 117 填充每个结点的下一个右侧结点指针Ⅱ</h2><h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, left, right, next) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val === undefined ? null : val;</span></span><br><span class="line"><span class="comment"> *    this.left = left === undefined ? null : left;</span></span><br><span class="line"><span class="comment"> *    this.right = right === undefined ? null : right;</span></span><br><span class="line"><span class="comment"> *    this.next = next === undefined ? null : next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> connect = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">const</span> queue=[]</span><br><span class="line">    queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;size)node.<span class="property">next</span>=queue[<span class="number">0</span>]</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题不是完美二叉树，但是还是可以用层序遍历的方法，需要加的条件就是i+1&lt;size ，这个条件代表的是遍历到本层最后一个元素之前，此时queue[0]就是本层下一个结点</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, left, right, next) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val === undefined ? null : val;</span></span><br><span class="line"><span class="comment"> *    this.left = left === undefined ? null : left;</span></span><br><span class="line"><span class="comment"> *    this.right = right === undefined ? null : right;</span></span><br><span class="line"><span class="comment"> *    this.next = next === undefined ? null : next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext=<span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp=node.<span class="property">next</span></span><br><span class="line">    <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>||temp.<span class="property">right</span>)<span class="keyword">break</span></span><br><span class="line">        temp=temp.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> connect = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">let</span> pre=root</span><br><span class="line">    <span class="keyword">while</span>(pre)&#123;</span><br><span class="line">        <span class="keyword">let</span> node=pre</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.<span class="property">left</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.<span class="property">right</span>)&#123;</span><br><span class="line">                    node.<span class="property">left</span>.<span class="property">next</span>=node.<span class="property">right</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> temp=<span class="title function_">getNext</span>(node)</span><br><span class="line">                    <span class="keyword">if</span>(temp)node.<span class="property">left</span>.<span class="property">next</span>=temp.<span class="property">left</span>||temp.<span class="property">right</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.<span class="property">right</span>)&#123;</span><br><span class="line">                <span class="keyword">let</span> temp=<span class="title function_">getNext</span>(node)</span><br><span class="line">                <span class="keyword">if</span>(temp)node.<span class="property">right</span>.<span class="property">next</span>=temp.<span class="property">left</span>||temp.<span class="property">right</span></span><br><span class="line">            &#125;</span><br><span class="line">            node=node.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre=pre.<span class="property">left</span>||pre.<span class="property">right</span>||pre.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这种解法是对前一种解法的一种优化，依据上一个节点来连接</li><li>首先判断最简单的情况，左右节点都有，那就直接连接就可以了</li><li>如果只有左节点没有右节点，那就往右找有子节点的节点</li><li>之后判断右节点存在的情况，右节点存在那得寻找根节点的右节点的节点</li><li>最后更新根节点的值</li></ul></li></ul><h1 id="Day-24-Leetcode-226-翻转二叉树"><a href="#Day-24-Leetcode-226-翻转二叉树" class="headerlink" title="Day 24 Leetcode 226 翻转二叉树"></a>Day 24 Leetcode 226 翻转二叉树</h1><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = root.<span class="property">right</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">invertTree</span>(root.<span class="property">left</span>)</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">invertTree</span>(temp)</span><br><span class="line">    <span class="comment">// [root.left,root.right]=[root.right,root.left]</span></span><br><span class="line">    <span class="comment">// invertTree(root.left)</span></span><br><span class="line">    <span class="comment">// invertTree(root.right)</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>翻转二叉树就是一个一个的把子节点翻转过来，因此可以用递归法</li><li>确认递归结束条件：root为空</li><li>递归逻辑：交换左右结点</li><li>递归返回值：返回根节点</li><li>这属于是前序遍历，后序遍历的方法也很简单，只要把交换左右节点写在递归下面就可以了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swap=<span class="keyword">function</span>(<span class="params">node,left,right</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp=left</span><br><span class="line">    left=right</span><br><span class="line">    right=temp</span><br><span class="line">    node.<span class="property">left</span>=left</span><br><span class="line">    node.<span class="property">right</span>=right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queue=[]</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node =queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="title function_">swap</span>(node,node.<span class="property">left</span>,node.<span class="property">right</span>)</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（迭代）：</p><ul><li>这种解法是层序遍历法，思路和递归一样，只要不断地交换左右节点就可以了</li></ul></li></ul><h1 id="Day-24-Leetcode-101-对称二叉树"><a href="#Day-24-Leetcode-101-对称二叉树" class="headerlink" title="Day 24 Leetcode 101 对称二叉树"></a>Day 24 Leetcode 101 对称二叉树</h1><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> compare = <span class="keyword">function</span> (<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left === <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left === <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left.<span class="property">val</span> !== right.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> outside = <span class="title function_">compare</span>(left.<span class="property">left</span>, right.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> inside = <span class="title function_">compare</span>(left.<span class="property">right</span>, right.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> result = outside &amp;&amp; inside</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">compare</span>(root.<span class="property">left</span>, root.<span class="property">right</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>判断是不是对称二叉树也就是判断左子树的左孩子和右子树的右孩子是否相等，左子树的右孩子和右子树的左孩子是否相等，也就是一个外侧，一个内侧。</li><li>这道题关键要确定是一个后序遍历的方法，因为要比较左子树和右子树是不是能翻转过来，然后再返回给根节点。因此顺序是左右中的遍历顺序。</li><li>注意：在判断左右子树的时候一定要把比较左右子树的值放在最后，因为但凡有一个为空，就会报错</li></ul></li></ul><h1 id="Day-24-Leetcode-100-相同的树"><a href="#Day-24-Leetcode-100-相同的树" class="headerlink" title="Day 24 Leetcode 100 相同的树"></a>Day 24 Leetcode 100 相同的树</h1><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> compare=<span class="keyword">function</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left!==<span class="literal">null</span>&amp;&amp;right===<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left===<span class="literal">null</span>&amp;&amp;right!==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left===<span class="literal">null</span>&amp;&amp;right===<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left.<span class="property">val</span>!==right.<span class="property">val</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> outside = <span class="title function_">compare</span>(left.<span class="property">left</span>,right.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> inside=<span class="title function_">compare</span>(left.<span class="property">right</span>,right.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> result=outside&amp;&amp;inside</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="keyword">function</span>(<span class="params">p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">compare</span>(p,q)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题和翻转二叉树的解法类似，不过改动是在比较的部分，不应该比较左子树的左孩子和右子树的右孩子，而是比较左子树的左孩子和右子树的左孩子这样两个对应的结点</li></ul></li></ul><h1 id="Day-24-Leetcode-572-另一棵树的子树"><a href="#Day-24-Leetcode-572-另一棵树的子树" class="headerlink" title="Day 24 Leetcode 572 另一棵树的子树"></a>Day 24 Leetcode 572 另一棵树的子树</h1><h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">subRoot</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> compare = <span class="keyword">function</span> (<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left === <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left === <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left.<span class="property">val</span> !== right.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> leftSide = <span class="title function_">compare</span>(left.<span class="property">left</span>, right.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightSide = <span class="title function_">compare</span>(left.<span class="property">right</span>, right.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> result = leftSide &amp;&amp; rightSide</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSubtree = <span class="keyword">function</span> (<span class="params">root, subRoot</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span> &amp;&amp; subRoot !== <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root !== <span class="literal">null</span> &amp;&amp; subRoot === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!root &amp;&amp; !subRoot) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> stack = [root]</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">compare</span>(node, subRoot)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        node.<span class="property">right</span> &amp;&amp; stack.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        node.<span class="property">left</span> &amp;&amp; stack.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题其实也是对称二叉树的变形</li><li>首先要判断一些特殊情况，比如root&#x3D;&#x3D;&#x3D;null、subRoot&#x3D;&#x3D;&#x3D;null的情况</li><li>关键就在于在root这棵树里遍历找到和subRoot根节点一样的结点，然后就按照《相同的树》那题的写法，递归比较左右孩子结点。如果知道最后也没有结果，那么说明root没有和subRoot根节点一样的结点，直接返回false就可以</li></ul></li></ul><h1 id="Day-25-Leetcode-104-二叉树的最大深度"><a href="#Day-25-Leetcode-104-二叉树的最大深度" class="headerlink" title="Day 25 Leetcode 104 二叉树的最大深度"></a>Day 25 Leetcode 104 二叉树的最大深度</h1><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><ul><li>求深度的遍历顺序实际上是前序，也可以用后序，但是这样实际上求的是根节点的高度（也就是最大深度）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getHeight = <span class="keyword">function</span> (<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> leftHeight = <span class="title function_">getHeight</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightHeight = <span class="title function_">getHeight</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> height = <span class="number">1</span> + <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight)</span><br><span class="line">    <span class="keyword">return</span> height</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getHeight</span>(root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>处理的逻辑实际上是从下往上处理的，遍历也属于后序遍历</li><li>用递归的方法，确定递归的返回值，递归的终止条件，递归的每层逻辑</li><li>最大深度就是根节点的最大高度，也就是左右子树的最大高度加一</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> queue=[root]</span><br><span class="line">    <span class="keyword">let</span> height=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        height++</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>运用层序遍历的思路，每遍历一层就把最大高度加1</li></ul></li></ul><h1 id="Day-25-Leetcode-559-n叉树的最大深度"><a href="#Day-25-Leetcode-559-n叉树的最大深度" class="headerlink" title="Day 25 Leetcode 559 n叉树的最大深度"></a>Day 25 Leetcode 559 n叉树的最大深度</h1><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node|null</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> depth=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> root.<span class="property">children</span>)&#123;</span><br><span class="line">        depth=<span class="title class_">Math</span>.<span class="title function_">max</span>(depth,<span class="title function_">maxDepth</span>(node))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth+<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>实际上就是在二叉树的最大高度的解法上多考虑一下孩子结点的处理，之前是遍历左右子树，这样的话就取每一个子树再进入深度的比较。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node|null</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> queue=[root]</span><br><span class="line">    <span class="keyword">let</span> height=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        height++</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;node.<span class="property">children</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.<span class="property">children</span>[i])queue.<span class="title function_">push</span>(node.<span class="property">children</span>[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>用层序遍历的时候在处理每一层时不再是考虑左右孩子，而是考虑整个孩子数组，这样的话只需要改一下处理子树的逻辑就可以了，高度仍然是在每一层循环开始的时候加。</li></ul></li></ul><h1 id="Day-26-Leetcode-111-二叉树的最小深度"><a href="#Day-26-Leetcode-111-二叉树的最小深度" class="headerlink" title="Day 26 Leetcode 111 二叉树的最小深度"></a>Day 26 Leetcode 111 二叉树的最小深度</h1><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getHeight=<span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> leftHeight=<span class="title function_">getHeight</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightHeight=<span class="title function_">getHeight</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">left</span>==<span class="literal">null</span>&amp;&amp;node.<span class="property">right</span>!==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">1</span>+rightHeight</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">left</span>!==<span class="literal">null</span>&amp;&amp;node.<span class="property">right</span>==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">1</span>+leftHeight</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">min</span>(leftHeight,rightHeight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getHeight</span>(root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>和求最大深度的方法类似的递归，但是不仅仅是把返回值从左右子树的最大值改为左右子树的最小值，而要考虑到当左右子树有一个不存在的时候，要返回的是存在的子树的高度，不能把不存在的子树的高度算为0</li><li>差别就在于处理左右孩子不为空的时候的逻辑</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> queue=[root]</span><br><span class="line">    <span class="keyword">let</span> depth=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        depth++</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node =queue.<span class="title function_">shift</span>()</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">            <span class="keyword">if</span>(!node.<span class="property">left</span>&amp;&amp;!node.<span class="property">right</span>)<span class="keyword">return</span> depth</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>层序遍历法，不过要在处理每层的时候寻找到左右子树都为空的叶子节点，这样既可以找到最小深度</li></ul></li></ul><h1 id="Day-27-Leetcode-222-完全二叉树的节点个数"><a href="#Day-27-Leetcode-222-完全二叉树的节点个数" class="headerlink" title="Day 27 Leetcode 222 完全二叉树的节点个数"></a>Day 27 Leetcode 222 完全二叉树的节点个数</h1><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> queue=[root]</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> size=queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="keyword">if</span>(node)num++</span><br><span class="line">            node.<span class="property">left</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span>&amp;&amp;queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>层序遍历法，每遍历一个就记录一下</li><li>时间复杂度略高</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leftNum=<span class="title function_">countNodes</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightNum=<span class="title function_">countNodes</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">let</span> result=leftNum+rightNum+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>还是把完全二叉树当成普通二叉树来算，用后序遍历。</li><li>运用的是递归的思维</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left=root.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">let</span> right=root.<span class="property">right</span>;</span><br><span class="line">    <span class="keyword">let</span> leftdepth=<span class="number">0</span>,rightdepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left)&#123;</span><br><span class="line">        left=left.<span class="property">left</span></span><br><span class="line">        leftdepth++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right)&#123;</span><br><span class="line">        right=right.<span class="property">right</span></span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftdepth===rightdepth)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;leftdepth)-<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> leftnum=<span class="title function_">countNodes</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> rightnum=<span class="title function_">countNodes</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">return</span> leftnum+rightnum+<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法三：</p><ul><li>这种解法利用的是完全二叉树的特点</li><li>完全二叉树是除最后一层外，其它层都满的二叉树，满二叉树是一种特殊的完全二叉树，它的结点数计算比较简单，即2的深度次方再减一，因此可以将完全二叉树拆分一下。</li><li>首先向最外侧遍历，如果左右的深度一样，那么说明这棵树是满二叉树，直接用公式计算就可以。如果不一样的话，那么就递归，再遍历左子树和右子树，得到左右结点数，最后再加上根节点就可以。</li><li>这种方法没有遍历所有的结点，只遍历了每个子树的外侧</li></ul></li></ul><h1 id="Day-27-Leetcode-110-平衡二叉树"><a href="#Day-27-Leetcode-110-平衡二叉树" class="headerlink" title="Day 27 Leetcode 110 平衡二叉树"></a>Day 27 Leetcode 110 平衡二叉树</h1><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getHeight = <span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leftNum=<span class="title function_">getHeight</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">if</span>(leftNum===-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> rightNum=<span class="title function_">getHeight</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">if</span>(rightNum===-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(leftNum-rightNum)&gt;<span class="number">1</span>)res= -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> res= <span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">max</span>(leftNum,rightNum)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">getHeight</span>(root)===-<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li><strong>求高度一定要用后序遍历</strong>，因为这样可以在遍历左右子树之后返回给根节点结果。</li><li>这道题在递归的时候处理了两件事，一是计算深度，二是比较左右子树。</li><li>如果在递归的时候发现左右子树已经不为平衡二叉树了，那么就返回-1给根结点，这样的话根结点会继续网上传。</li><li>根节点高度的计算是取左右子树的最大高度+1</li></ul></li></ul><h1 id="Day-27-Leetcode-257-二叉树的所有路径"><a href="#Day-27-Leetcode-257-二叉树的所有路径" class="headerlink" title="Day 27 Leetcode 257 二叉树的所有路径"></a>Day 27 Leetcode 257 二叉树的所有路径</h1><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getPath=<span class="keyword">function</span>(<span class="params">node,path,res</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">left</span>===<span class="literal">null</span>&amp;&amp;node.<span class="property">right</span>===<span class="literal">null</span>)&#123;</span><br><span class="line">        path+=node.<span class="property">val</span></span><br><span class="line">        res.<span class="title function_">push</span>(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    path+=node.<span class="property">val</span>+<span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">    node.<span class="property">left</span>&amp;&amp;<span class="title function_">getPath</span>(node.<span class="property">left</span>,path,res)</span><br><span class="line">    node.<span class="property">right</span>&amp;&amp;<span class="title function_">getPath</span>(node.<span class="property">right</span>,path,res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="title function_">getPath</span>(root,<span class="string">&#x27;&#x27;</span>,res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>这道题一定要用前序遍历，因为要用根节点去指向左右子节点。</li><li>这道题的核心思想是递归中带着回溯，回溯也可以理解为是回退的过程</li><li>递归的终止条件是递归到叶子结点，也就是左右孩子都为空</li><li>在遍历到叶子节点的时候就应当return 到根节点，也就是回溯的过程</li></ul><h1 id="Day-28-Leetcode-404-左叶子之和"><a href="#Day-28-Leetcode-404-左叶子之和" class="headerlink" title="Day 28 Leetcode 404 左叶子之和"></a>Day 28 Leetcode 404 左叶子之和</h1><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>===<span class="literal">null</span>&amp;&amp;root.<span class="property">right</span>===<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leftNum=<span class="title function_">sumOfLeftLeaves</span>(root.<span class="property">left</span>)<span class="comment">//左</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>&amp;&amp;!root.<span class="property">left</span>.<span class="property">left</span>&amp;&amp;!root.<span class="property">left</span>.<span class="property">right</span>)&#123;</span><br><span class="line">        leftNum=root.<span class="property">left</span>.<span class="property">val</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> rightNum=<span class="title function_">sumOfLeftLeaves</span>(root.<span class="property">right</span>)<span class="comment">//右</span></span><br><span class="line">    <span class="keyword">let</span> sum=leftNum+rightNum<span class="comment">//中</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>首先看题目要求，左叶子应当满足是叶子结点和是根节点的左孩子这两个条件</li><li>使用后序遍历比较好，因为这样是从下往上传递数据的</li><li>后序遍历三步处理左右中</li></ul></li></ul><h1 id="Day-28-Leetcode-513-找树左下角的值"><a href="#Day-28-Leetcode-513-找树左下角的值" class="headerlink" title="Day 28 Leetcode 513 找树左下角的值"></a>Day 28 Leetcode 513 找树左下角的值</h1><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.<span class="property">length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                res = node.<span class="property">val</span></span><br><span class="line">            &#125;</span><br><span class="line">            node.<span class="property">left</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            node.<span class="property">right</span> &amp;&amp; queue.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一（迭代）：</p><ul><li>层序遍历，找到最后一行的第一个元素就可以了。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxDepth = <span class="title class_">Number</span>.<span class="property">MIN_VALUE</span></span><br><span class="line">    <span class="keyword">let</span> res=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> travel = <span class="keyword">function</span> (<span class="params">root, depth</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth</span><br><span class="line">                res = root.<span class="property">val</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">left</span>) &#123;</span><br><span class="line">            depth++</span><br><span class="line">            <span class="title function_">travel</span>(root.<span class="property">left</span>,depth)</span><br><span class="line">            depth--</span><br><span class="line">          <span class="comment">//travel(root.left,depth+1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>)&#123;</span><br><span class="line">            depth++</span><br><span class="line">            <span class="title function_">travel</span>(root.<span class="property">right</span>,depth)</span><br><span class="line">            depth--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">travel</span>(root,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二（递归）：</p><ul><li>递归写法中实际上还隐含着回溯的思想</li><li>首先确定递归结束的条件，也就是便利到了叶子结点，同时要将本次的深度和之前记录过的最大深度对比，如果比之前记录的大，则更新一下最大深度，同时给结果赋值。</li><li>遍历左右子树用到了回溯的方法，因为遍历完左子树还要返回根节点，然后再遍历右子树，实际上是通过控制深度来实现的</li><li>这道题要优先左边搜索，这样才能确保找到的是最左边的结点</li></ul></li></ul><h1 id="Day-28-Leetcode-112-路径总和"><a href="#Day-28-Leetcode-112-路径总和" class="headerlink" title="Day 28 Leetcode 112 路径总和"></a>Day 28 Leetcode 112 路径总和</h1><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span> (<span class="params">root, targetsum</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> travel=<span class="keyword">function</span>(<span class="params">node,target</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="property">left</span>&amp;&amp;!node.<span class="property">right</span>&amp;&amp;target===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="property">left</span>&amp;&amp;!node.<span class="property">right</span>&amp;&amp;target!==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>&amp;&amp;<span class="title function_">travel</span>(node.<span class="property">left</span>,target-node.<span class="property">left</span>.<span class="property">val</span>))<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span>&amp;&amp;<span class="title function_">travel</span>(node.<span class="property">right</span>,target-node.<span class="property">right</span>.<span class="property">val</span>))<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">travel</span>(root,targetsum-root.<span class="property">val</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一（递归）：</p><ul><li>这道题仍然是递归中带着回溯，遍历顺序任意，因为不需要处理中结点<br>求结点的值的和可以用减法，遍历一条线就用target以此减去各节点的值，最后判断是不是0就可以了</li><li>确定递归结束条件：遍历到叶子节点并且此时target正好减为0，即找到了符合条件的路径；反之则返回false</li><li>递归执行逻辑：向左遍历的时候，target应当先减去左孩子的值，再进行递归，然后再把target加回来，这样是一个回溯的过程。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> queue=[root]</span><br><span class="line">    <span class="keyword">let</span> valArr=[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> curNode=queue.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="keyword">let</span> curVal=valArr.<span class="title function_">shift</span>()</span><br><span class="line">        curVal+=curNode.<span class="property">val</span></span><br><span class="line">        <span class="keyword">if</span>(!curNode.<span class="property">left</span>&amp;&amp;!curNode.<span class="property">right</span>&amp;&amp;curVal===targetSum)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(curNode.<span class="property">left</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(curNode.<span class="property">left</span>)</span><br><span class="line">            valArr.<span class="title function_">push</span>(curVal)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curNode.<span class="property">right</span>)&#123;</span><br><span class="line">            queue.<span class="title function_">push</span>(curNode.<span class="property">right</span>)</span><br><span class="line">            valArr.<span class="title function_">push</span>(curVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二（迭代）：</p><ul><li>迭代法需要模拟出递归的操作</li><li>定义两个数组来模拟，一个用来储存结点，另一个用来储存节点的值</li><li>每次循环的时候从头部弹出一个结点和值，然后判断是不是叶子节点，以及是不是达到了目标值</li><li>然后遍历左右结点并把他们加入到队列中</li></ul></li></ul><h1 id="Day-29-Leetcode-113-路径总和②"><a href="#Day-29-Leetcode-113-路径总和②" class="headerlink" title="Day 29 Leetcode 113 路径总和②"></a>Day 29 Leetcode 113 路径总和②</h1><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> pathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">const</span> travelSal = <span class="keyword">function</span> (<span class="params">root, cnt, path</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt === <span class="number">0</span> &amp;&amp; !root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>([...path])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt !== <span class="number">0</span> &amp;&amp; !root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">left</span>) &#123;</span><br><span class="line">            path.<span class="title function_">push</span>(root.<span class="property">left</span>.<span class="property">val</span>)</span><br><span class="line">            <span class="title function_">travelSal</span>(root.<span class="property">left</span>, cnt - root.<span class="property">left</span>.<span class="property">val</span>, path)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">right</span>) &#123;</span><br><span class="line">            path.<span class="title function_">push</span>(root.<span class="property">right</span>.<span class="property">val</span>)</span><br><span class="line">            <span class="title function_">travelSal</span>(root.<span class="property">right</span>, cnt - root.<span class="property">right</span>.<span class="property">val</span>, path)</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res</span><br><span class="line">    <span class="title function_">travelSal</span>(root, targetSum - root.<span class="property">val</span>, [root.<span class="property">val</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一（递归）：</p><ul><li>比前一题多处理一个路径的数组</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">targetSum</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="keyword">function</span> (<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> nodeArr = [root]</span><br><span class="line">    <span class="keyword">let</span> res = [], temp = [[]], valArr = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> (nodeArr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curNode = nodeArr.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="keyword">let</span> curVal = valArr.<span class="title function_">shift</span>()</span><br><span class="line">        <span class="keyword">let</span> curNodeArr = temp.<span class="title function_">shift</span>()</span><br><span class="line">        curVal += curNode.<span class="property">val</span></span><br><span class="line">        curNodeArr.<span class="title function_">push</span>(curNode.<span class="property">val</span>)</span><br><span class="line">        <span class="keyword">if</span> (!curNode.<span class="property">left</span> &amp;&amp; !curNode.<span class="property">right</span> &amp;&amp; curVal === targetSum) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(curNodeArr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode.<span class="property">left</span>) &#123;</span><br><span class="line">            nodeArr.<span class="title function_">push</span>(curNode.<span class="property">left</span>)</span><br><span class="line">            valArr.<span class="title function_">push</span>(curVal)</span><br><span class="line">            temp.<span class="title function_">push</span>([...curNodeArr])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode.<span class="property">right</span>) &#123;</span><br><span class="line">            nodeArr.<span class="title function_">push</span>(curNode.<span class="property">right</span>)</span><br><span class="line">            valArr.<span class="title function_">push</span>(curVal)</span><br><span class="line">            temp.<span class="title function_">push</span>([...curNodeArr])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二（迭代）：</p><ul><li>和上一题类似的写法，不过要多处理一个路径的数组</li></ul></li></ul><h1 id="Day-29-Leetcode-106-从中序与后序遍历序列构造二叉树"><a href="#Day-29-Leetcode-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="Day 29 Leetcode 106 从中序与后序遍历序列构造二叉树"></a>Day 29 Leetcode 106 从中序与后序遍历序列构造二叉树</h1><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">postorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span> (<span class="params">inorder, postorder</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!postorder.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> rootval = postorder.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">let</span> index = inorder.<span class="title function_">indexOf</span>(rootval)</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootval)</span><br><span class="line">    <span class="keyword">let</span> middleLeft = inorder.<span class="title function_">slice</span>(<span class="number">0</span>, index)</span><br><span class="line">    <span class="keyword">let</span> middleRight = inorder.<span class="title function_">slice</span>(index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> backLeft = postorder.<span class="title function_">slice</span>(<span class="number">0</span>, middleLeft.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">let</span> backRight = postorder.<span class="title function_">slice</span>(middleLeft.<span class="property">length</span>)</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">buildTree</span>(middleLeft, backLeft)</span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">buildTree</span>(middleRight, backRight)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题要利用好中序和后序的特点，分步走</li><li>第一步：在后序遍历中找到根节点，也就是最后一个元素，并构造一个跟结点</li><li>第二步：记录下根节点在中序遍历中的坐标</li><li>第三步：切割中序数组，也就是把中序数组以根节点为中心分为左右两部分</li><li>第四步：切割后序数组，切割的数目由中序数组切割的数目确定</li><li>第五步：构造左子树，把切割完的数组再传进buildTree中</li><li>第六步：构造右子树，把切割完的数组再传进buildTree中</li></ul></li></ul><h1 id="Day-29-Leetcode-105-从中序与前序遍历序列构造二叉树"><a href="#Day-29-Leetcode-105-从中序与前序遍历序列构造二叉树" class="headerlink" title="Day 29 Leetcode 105 从中序与前序遍历序列构造二叉树"></a>Day 29 Leetcode 105 从中序与前序遍历序列构造二叉树</h1><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">preorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">inorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span> (<span class="params">preorder, inorder</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="keyword">let</span> index = inorder.<span class="title function_">indexOf</span>(rootVal)</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal)</span><br><span class="line">    <span class="keyword">let</span> middleLeft = inorder.<span class="title function_">slice</span>(<span class="number">0</span>, index)</span><br><span class="line">    <span class="keyword">let</span> middleRight = inorder.<span class="title function_">slice</span>(index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> preLeft = preorder.<span class="title function_">slice</span>(<span class="number">0</span>, middleLeft.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">let</span> preRight = preorder.<span class="title function_">slice</span>(middleLeft.<span class="property">length</span>)</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">buildTree</span>(preLeft, middleLeft)</span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">buildTree</span>(preRight, middleRight)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题和中序和后序构造二叉树类似，只要把切割后序数组的操作换成切割前序数组的操作就可以了</li></ul></li></ul><h1 id="Day-30-Leetcode-654-最大二叉树"><a href="#Day-30-Leetcode-654-最大二叉树" class="headerlink" title="Day 30 Leetcode 654 最大二叉树"></a>Day 30 Leetcode 654 最大二叉树</h1><h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructMaximumBinaryTree = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">buildTree</span> = (<span class="params">arr, left, right</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> maxVal = -<span class="number">1</span>, index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = arr[i]</span><br><span class="line">                index = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal)</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">buildTree</span>(arr, left, index - <span class="number">1</span>)</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">buildTree</span>(arr, index + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="title function_">buildTree</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题和中序后序构造二叉树的思路差别不大，这种构造二叉树的题目都得使用前序遍历法，因为前序遍历是首先生成根节点的。</li><li>这道题首先要找到数组中的最大值，然后把数组分成左右两部分，分别进入递归构造左子树和右子树</li></ul></li></ul><h1 id="Day-30-Leetcode-617-合并二叉树"><a href="#Day-30-Leetcode-617-合并二叉树" class="headerlink" title="Day 30 Leetcode 617 合并二叉树"></a>Day 30 Leetcode 617 合并二叉树</h1><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTrees = <span class="keyword">function</span>(<span class="params">root1, root2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root1===<span class="literal">null</span>)<span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="literal">null</span>)<span class="keyword">return</span> root1</span><br><span class="line">    root1.<span class="property">val</span>+=root2.<span class="property">val</span></span><br><span class="line">    root1.<span class="property">left</span>=<span class="title function_">mergeTrees</span>(root1.<span class="property">left</span>,root2.<span class="property">left</span>)</span><br><span class="line">    root1.<span class="property">right</span>=<span class="title function_">mergeTrees</span>(root1.<span class="property">right</span>,root2.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这题用前中后序遍历都可以，只需要稍微改一下代码的顺序就可以了</li><li>这道题可以不用构建第三棵树，在第一棵树上改就可以</li><li>如果第一棵树遍历为空，那么要加上第二棵树在此处的值，反过来也一样</li><li>如果两处都有结点那么就直接相加</li><li>最后递归进入左子树、右子树再比较就可以了</li></ul></li></ul><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="Day-31-Leetcode-700-二叉搜索树中的搜索"><a href="#Day-31-Leetcode-700-二叉搜索树中的搜索" class="headerlink" title="Day 31 Leetcode 700 二叉搜索树中的搜索"></a>Day 31 Leetcode 700 二叉搜索树中的搜索</h2><h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span> (<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span> || root.<span class="property">val</span> === val) <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.<span class="property">val</span>) &#123;</span><br><span class="line">        result = <span class="title function_">searchBST</span>(root.<span class="property">left</span>,val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.<span class="property">val</span>) &#123;</span><br><span class="line">        result = <span class="title function_">searchBST</span>(root.<span class="property">right</span>,val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一（递归）：</p><ul><li>首先要知道二叉搜索树的特征，二叉搜索树的每个结点的大小都大于它的左子树所有的节点，小于它的右子树所有的结点。</li><li>这道题不用纠结于选用什么遍历顺序，因为二叉搜索树的特征让我们很快知道改怎么遍历。</li><li>每次递归的时候根据当前结点的值和要搜索的值来判断递归左边还是右边</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchBST = <span class="keyword">function</span> (<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="comment">// if (root === null || root.val === val) return root</span></span><br><span class="line">    <span class="comment">// let result = new TreeNode(null)</span></span><br><span class="line">    <span class="comment">// if (val &lt; root.val) &#123;</span></span><br><span class="line">    <span class="comment">//     result = searchBST(root.left,val)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// if (val &gt; root.val) &#123;</span></span><br><span class="line">    <span class="comment">//     result = searchBST(root.right,val)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return result</span></span><br><span class="line">    <span class="keyword">while</span>(root!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;root.<span class="property">val</span>)&#123;</span><br><span class="line">            root=root.<span class="property">left</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val&gt;root.<span class="property">val</span>)&#123;</span><br><span class="line">            root=root.<span class="property">right</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二（迭代）：</p><ul><li>不断地通过比对当前节点的值和要求的值的大小来移动。</li></ul></li></ul><h2 id="Day-32-Leetcode-98-验证二叉搜索树"><a href="#Day-32-Leetcode-98-验证二叉搜索树" class="headerlink" title="Day 32 Leetcode 98 验证二叉搜索树"></a>Day 32 Leetcode 98 验证二叉搜索树</h2><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// let pre = null</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxval = <span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">inOrder</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">val</span> &gt; maxval) &#123;</span><br><span class="line">            maxval = cur.<span class="property">val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">inOrder</span>(cur.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">inOrder</span>(root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>递归的方法很简单，就是按照中序遍历的方法来遍历二叉搜索树。</li><li>左：进入递归，并返回一个判断值left</li><li>中：如果当前的最大值（也就是前一个结点的值）小于等于当前的结点的值，说明不是二叉搜索树，反之则把当前结点的值赋给它</li><li>右：进入递归，并返回一个判断值right</li><li>最后只要判断left和right是不是都是true就可以了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// let pre = null</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">inOrder</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; cur.<span class="property">val</span> &lt;= pre.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">inOrder</span>(cur.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">inOrder</span>(root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>利用了双指针，在上一种解法的基础上，重新定义了一个结点pre来记录前一个结点的值，主要变化的部分是中间处理的部分。</li><li>如果pre不为空并且当前结点的值小于pre，name说明不是二叉搜索树。</li><li>每次递归要给pre更新值，递归的过程中实际上也带着回溯的过程</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res=[]</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">buildArr</span>=(<span class="params">root</span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="title function_">buildArr</span>(root.<span class="property">left</span>)</span><br><span class="line">            res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">            <span class="title function_">buildArr</span>(root.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">buildArr</span>(root)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;res.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;=res[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（辅助数组）：</p><ul><li>利用二叉搜索树的特性，二叉搜索树转换成数组之后一定是一个递增的数组，因此可以先构造一个二叉搜索树转成的数组，然后遍历来判断是不是递增的数组就可以了</li></ul></li></ul><h2 id="Day-32-Leetcode-530-二叉搜索树的最小绝对差"><a href="#Day-32-Leetcode-530-二叉搜索树的最小绝对差" class="headerlink" title="Day 32 Leetcode 530 二叉搜索树的最小绝对差"></a>Day 32 Leetcode 530 二叉搜索树的最小绝对差</h2><h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travel</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="title function_">travel</span>(root.<span class="property">left</span>)</span><br><span class="line">            res.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">            <span class="title function_">travel</span>(root.<span class="property">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">travel</span>(root)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="title class_">Math</span>.<span class="title function_">abs</span>(res[i + <span class="number">1</span>] - res[i])</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; min) &#123;</span><br><span class="line">            min = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p></li><li><ul><li>仍然是转换成一个有序的数组，然后从头开始计算差值就可以了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>, min = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travel</span> = (<span class="params">cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">travel</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span> (pre !== <span class="literal">null</span>) &#123;</span><br><span class="line">            min = <span class="title class_">Math</span>.<span class="title function_">min</span>(min, cur.<span class="property">val</span> - pre.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="title function_">travel</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">travel</span>(root)</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>这道题仍然是中序利用双指针遍历，一个指针pre指向前一个结点，一个指针cur指向当前节点。递归的部分不用动，需要动的地方就是在根节点的处理逻辑上，不仅要更新min 的数值，也要给pre更新值，</li><li>也是递归中带着回溯的题目</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMinimumDifference = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [], res = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>, cur = root, pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (cur !== <span class="literal">null</span> || stack.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(cur)</span><br><span class="line">            cur = cur.<span class="property">left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (pre !== <span class="literal">null</span>) &#123;</span><br><span class="line">                res = <span class="title class_">Math</span>.<span class="title function_">min</span>(res, cur.<span class="property">val</span> - pre.<span class="property">val</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="property">right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（迭代）：</p><ul><li>递归可以做的事可以用栈来模拟，也不难理解</li></ul></li></ul><h2 id="Day-32-Leetcode-501-二叉搜索树中的众数"><a href="#Day-32-Leetcode-501-二叉搜索树中的众数" class="headerlink" title="Day 32 Leetcode 501 二叉搜索树中的众数"></a>Day 32 Leetcode 501 二叉搜索树中的众数</h2><h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMode = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, maxcount = <span class="number">0</span>, pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travel</span> = (<span class="params">cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">travel</span>(cur.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span> (pre === <span class="literal">null</span>) &#123;</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.<span class="property">val</span> === cur.<span class="property">val</span>) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur</span><br><span class="line">        <span class="keyword">if</span> (count === maxcount) res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxcount) &#123;</span><br><span class="line">            maxcount = count</span><br><span class="line">            res.<span class="title function_">splice</span>(<span class="number">0</span>, res.<span class="property">length</span>)</span><br><span class="line">            res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">travel</span>(cur.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">travel</span>(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>二叉搜索树的每道题都需要用中序遍历，因为这样可以保证是有序的</li><li>二叉搜索树相同的结点一定是连续的。</li><li>这道题count是用来记录当前节点值的个数，maxcount是记录最多的节点的个数，pre代表前一个结点。</li><li>递归的逻辑中，中间的逻辑比较难写。</li><li>首先，如果pre指向的是null，说明cur是最左下角的那个结点，也就是第一个结点，这个时候count应该初始化为1.</li><li>如果pre的值和cur的值一样，此时应该给count++</li><li>如果pre的值和cur的值不一样，那么count的个数应该再次初始化为1。</li><li>要确保pre跟在cur后面，那么每次递归的时候就应该给pre重新赋值</li><li>比较count和maxcount的值，如果一样的话，就说明当前结点的值到现在为止是最多的，可以加到res里；如果count的值更大的话，应该更新maxcount的值并且清空res数组，并且把当前的节点的值加进去</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMode = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, maxcount = <span class="number">0</span>, pre = <span class="literal">null</span>, cur = root</span><br><span class="line">    <span class="keyword">const</span> stack = [], res = []</span><br><span class="line">    <span class="keyword">while</span> (cur !== <span class="literal">null</span> || stack.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur !== <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(cur)</span><br><span class="line">            cur = cur.<span class="property">left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (pre === <span class="literal">null</span>) &#123;</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.<span class="property">val</span> === cur.<span class="property">val</span>) &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count === maxcount) res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxcount) &#123;</span><br><span class="line">                maxcount = count</span><br><span class="line">                res.<span class="title function_">splice</span>(<span class="number">0</span>, res.<span class="property">length</span>)</span><br><span class="line">                res.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="property">right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（迭代）：</p><ul><li>迭代法和递归法的思路一致，无非是用栈来模拟递归，中间的处理步骤是一样的。</li></ul></li></ul><h2 id="Day-33-Leetcode-235-二叉搜索树的最近公共祖先"><a href="#Day-33-Leetcode-235-二叉搜索树的最近公共祖先" class="headerlink" title="Day 33 Leetcode 235 二叉搜索树的最近公共祖先"></a>Day 33 Leetcode 235 二叉搜索树的最近公共祖先</h2><h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span> (<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &gt; q.<span class="property">val</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>, p, q)</span><br><span class="line">        <span class="keyword">if</span> (left !== <span class="literal">null</span>) <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt;p.<span class="property">val</span> &amp;&amp;root.<span class="property">val</span>&lt;q.<span class="property">val</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> right=<span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>,p,q)</span><br><span class="line">        <span class="keyword">if</span>(right!==<span class="literal">null</span>)<span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>要找到最近的公共祖先，首先确定这个祖先的值一定是在它们两个的值中间的，这是由二叉搜索树的特性知道的。</li><li>求最近的公共祖先一定用的是后序遍历，因为这样可以从底向上的返回值</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span> (<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = root</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; cur.<span class="property">val</span> &gt; q.<span class="property">val</span>) &#123;</span><br><span class="line">            cur = cur.<span class="property">left</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur.<span class="property">val</span> &lt; p.<span class="property">val</span> &amp;&amp; cur.<span class="property">val</span> &lt; q.<span class="property">val</span>) &#123;</span><br><span class="line">            cur = cur.<span class="property">right</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> cur</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（迭代）：</p><ul><li>和递归法的思路一样，只是把递归左右子树地步骤放到了循环里来模拟。这样的话只要当前节点不为空就一直遍历下去。</li></ul></li></ul><h2 id="Day-34-Leetcode-236-二叉树的最近公共祖先"><a href="#Day-34-Leetcode-236-二叉树的最近公共祖先" class="headerlink" title="Day 34 Leetcode 236 二叉树的最近公共祖先"></a>Day 34 Leetcode 236 二叉树的最近公共祖先</h2><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">q</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span> (<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travel</span> = (<span class="params">root, p, q</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (root === p || root === q || root === <span class="literal">null</span>) <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>, p, q)</span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>, p, q)</span><br><span class="line">        <span class="keyword">if</span> (left !== <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span>) <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> (left === <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span>) <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">travel</span>(root, p, q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>当遍历到p或者遍历到q的时候，就把当前遍历的结点返回。</li><li>这道题应该用后序遍历，这样可以先遍历左右子树然后返回一个值给根节点这样一层一层的返回。</li><li>用left和right来接住递归的结果。如果left和right都不为空的话，说明找到了公共祖先，直接返回root；如果有一个为空的话那就继续向上返回，直到找到公共祖先为止</li></ul></li></ul><h2 id="Day-34-Leetcode-701-二叉搜索树中的插入操作"><a href="#Day-34-Leetcode-701-二叉搜索树中的插入操作" class="headerlink" title="Day 34 Leetcode 701 二叉搜索树中的插入操作"></a>Day 34 Leetcode 701 二叉搜索树中的插入操作</h2><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="keyword">function</span> (<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root.<span class="property">val</span>) &#123;</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">left</span>, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; root.<span class="property">val</span>) &#123;</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">right</span>, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>要利用好二叉搜索树的特性。这道题并不复杂，插入节点的话一定是在叶子节点插入，想明白这个题目就不难了</li><li>首先确定递归结束的条件，当当前遍历的结点为空时，说明这棵树本来就是空的，或者是遍历到了叶子结点。这个时候要创建一个结点并且返回。</li><li>如果要插入的值小于根节点的值的话，就要一路向左遍历，并且用root.left接住，这样的话当找到应该插入的位置后就可以连接起来。右子树同理</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="keyword">function</span> (<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cur = root, par = root</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        par = cur</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="property">val</span> &gt; val) cur = cur.<span class="property">left</span></span><br><span class="line">        <span class="keyword">else</span> cur = cur.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val)</span><br><span class="line">    <span class="keyword">if</span> (val &lt; par.<span class="property">val</span>) par.<span class="property">left</span> = node</span><br><span class="line">    <span class="keyword">if</span> (val &gt; par.<span class="property">val</span>) par.<span class="property">right</span> = node</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（迭代）：</p><ul><li>迭代法的重点就是记录下上一个结点。</li><li>当cur（当前遍历的结点）为空的时候，这个时候符合插入 条件了，并且这个空结点的父节点也被pre记录下来了，因此再判断一下这个节点和父节点的大小，用父节点操作插入就很简单了</li></ul></li></ul><h2 id="Day-35-Leetcode-450-删除二叉搜索树中的节点"><a href="#Day-35-Leetcode-450-删除二叉搜索树中的节点" class="headerlink" title="Day 35 Leetcode 450 删除二叉搜索树中的节点"></a>Day 35 Leetcode 450 删除二叉搜索树中的节点</h2><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span> (<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> === key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = root.<span class="property">right</span></span><br><span class="line">            <span class="keyword">while</span> (cur.<span class="property">left</span>) &#123;</span><br><span class="line">                cur = cur.<span class="property">left</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur.<span class="property">left</span> = root.<span class="property">left</span></span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &gt; key) &#123;</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">deleteNode</span>(root.<span class="property">left</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; key) &#123;</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>这道题稍微有点复杂，因为需要调整二叉搜索树的结构</li><li>在确认递归函数返回值的时候可以分五种情况。</li><li>第一种情况：在整个二叉搜索树里找不到要删除的结点，也就是递归到了叶子结点还没有找到要删除的结点，返回null；或者说整个树就是空的树，也直接返回null</li><li>第二种到第四种都是找到了要删除的结点的情况</li><li>第二种情况：要删除的结点是叶子结点时，只需要返回null，也就是之后让父节点指向null就可以了</li><li>第三种情况：要删除的结点不是叶子节点，并且左孩子不为空，右孩子为空。这个时候返回的应该是左孩子，这样之后让这个节点的父节点指向左孩子就相当于删掉了这个根节点。</li><li>第四种情况：要删除的结点不是叶子节点，并且右孩子不为空，左孩子为空，返回右孩子，之后让该节点的父节点指向右孩子</li><li>第五种情况：最复杂的情况，要删除的节点既有左孩子又有右孩子这个时候要调整结构。用一个指针来遍历右子树的节点（遍历左子树也可以），因为这是一棵二叉搜索树，因此右子树的节点一定比左子树的值大，找到右子树的最左侧的节点，并且把左子树拼接过去，这样就又变成了左孩子为空，右孩子不为空的情况，返回root.right就可以了（如果是把右孩子拼接成左孩子，就找左子树最右侧的节点拼接，最后返回左子树）</li><li>单层递归逻辑很简单，因为二叉搜索树可以帮我们缩小范围。这样上一层直接左右子树来接返回值就可以了。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteOneNode = <span class="keyword">function</span> (<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(target===<span class="literal">null</span>)<span class="keyword">return</span> tar<span class="keyword">get</span></span><br><span class="line">    <span class="title function_">if</span>(<span class="params">target.right===<span class="literal">null</span></span>)<span class="keyword">return</span> target.<span class="property">left</span><span class="comment">//没有右孩子</span></span><br><span class="line">    <span class="keyword">let</span> cur=target.<span class="property">right</span><span class="comment">//左右子树都有或者没有左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">left</span>)&#123;</span><br><span class="line">        cur=cur.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="property">left</span>=target.<span class="property">left</span></span><br><span class="line">    <span class="keyword">return</span> target.<span class="property">right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span> (<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">let</span> cur=root,pre=<span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">val</span>===key)<span class="keyword">break</span>;</span><br><span class="line">        pre=cur</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">val</span>&gt;key)cur=cur.<span class="property">left</span></span><br><span class="line">        <span class="keyword">else</span> cur=cur.<span class="property">right</span></span><br><span class="line">    &#125;<span class="comment">//找到要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span>(pre===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">deleteOneNode</span>(cur)</span><br><span class="line">    &#125;<span class="comment">//如果第一个节点就是要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="property">left</span>&amp;&amp;pre.<span class="property">left</span>.<span class="property">val</span>===key)&#123;</span><br><span class="line">        pre.<span class="property">left</span>=<span class="title function_">deleteOneNode</span>(cur)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="property">right</span>&amp;&amp;pre.<span class="property">right</span>.<span class="property">val</span>===key)&#123;</span><br><span class="line">        pre.<span class="property">right</span>=<span class="title function_">deleteOneNode</span>(cur)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（迭代）：</p><ul><li>迭代法中的核心部分和递归中的核心部分差不多</li><li>用pre来记录上一个节点，用cur来记录当前遍历的节点</li><li>如果pre是空的话，证明是第一个节点，那么直接删除cur指向的这个节点就可以了</li><li>因为pre代表的是cur的上一个节点，因此可以用pre的指向来进行删除操作。</li></ul></li></ul><h2 id="Day-35-Leetcode-669-修剪二叉搜索树"><a href="#Day-35-Leetcode-669-修剪二叉搜索树" class="headerlink" title="Day 35 Leetcode 669 修剪二叉搜索树"></a>Day 35 Leetcode 669 修剪二叉搜索树</h2><h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">low</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">high</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> trimBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&lt;low)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">right</span>,low,high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span>&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">left</span>,low,high)</span><br><span class="line">    &#125;</span><br><span class="line">    root.<span class="property">left</span>=<span class="title function_">trimBST</span>(root.<span class="property">left</span>,low,high)</span><br><span class="line">    root.<span class="property">right</span>=<span class="title function_">trimBST</span>(root.<span class="property">right</span>,low,high)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>这道题主要要想明白返回值。</li><li>递归的时候，如果这个值小于区间最小值的话，那么就继续向右子树递归修剪，并且返回一个修剪完了的右子树的根节点，（左子树不用看，因为左子树一定小于区间最小值），并且将root.left指向这个返回了之后的根节点就可以了。</li><li>右子树递归类似，换了个方向而已。</li></ul></li></ul><h2 id="Day-35-Leetcode-108将有序数组转换成二叉搜索树"><a href="#Day-35-Leetcode-108将有序数组转换成二叉搜索树" class="headerlink" title="Day 35 Leetcode 108将有序数组转换成二叉搜索树"></a>Day 35 Leetcode 108将有序数组转换成二叉搜索树</h2><h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travel</span> = (<span class="params">arr, left, right</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(left + (right - left) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[mid])</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">travel</span>(arr, left, mid - <span class="number">1</span>)</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">travel</span>(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">travel</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法（递归）：</p><ul><li>同样是构造二叉树，不过是加上了条件：二叉搜索平衡树，但是由于数组是有序的，因此不用手动排序，直接构造即可。</li><li>构造可以先选择一个中间的值作为根节点，然后左右两边分为左右子树。注意这里构造的区间定义的是左闭右闭的区间。</li></ul></li></ul><h2 id="Day-35-Leetcode-538-把二叉搜索树转换为累加树"><a href="#Day-35-Leetcode-538-把二叉搜索树转换为累加树" class="headerlink" title="Day 35 Leetcode 538 把二叉搜索树转换为累加树"></a>Day 35 Leetcode 538 把二叉搜索树转换为累加树</h2><h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertBST = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travelsal</span> = (<span class="params">cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">travelsal</span>(cur.<span class="property">right</span>)<span class="comment">//右</span></span><br><span class="line">        cur.<span class="property">val</span> += pre<span class="comment">//中</span></span><br><span class="line">        pre = cur.<span class="property">val</span></span><br><span class="line">        <span class="title function_">travelsal</span>(cur.<span class="property">left</span>)<span class="comment">//左</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">travelsal</span>(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题很简单，题意就是把这棵树每个节点的值更新成本身的值再加上所有比它大的值。</li><li>这道题需要用到反中序遍历（也就是右中左的顺序），因为这样可以保证是从最大的值开始往下来加，这样可以让双指针不断地移动从而来实现累加</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convertBST = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, stack = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">travelsal</span> = (<span class="params">cur</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur || stack.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!==<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(cur)</span><br><span class="line">                cur=cur.<span class="property">right</span><span class="comment">//右</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.<span class="title function_">pop</span>()</span><br><span class="line">                cur.<span class="property">val</span>+=pre<span class="comment">//中</span></span><br><span class="line">                pre=cur.<span class="property">val</span></span><br><span class="line">                cur=cur.<span class="property">left</span><span class="comment">//左</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">travelsal</span>(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>和中序遍历的迭代法一样的步骤，只不过处理的顺序有点变化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2023/01/14/2023.01.13%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/01/14/2023.01.13%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-18-Leetcode-232-用栈实现队列"><a href="#Day-18-Leetcode-232-用栈实现队列" class="headerlink" title="Day 18 Leetcode 232 用栈实现队列"></a>Day 18 Leetcode 232 用栈实现队列</h1><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>很简单的数组应用</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>=[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size = <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="title function_">pop</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x=<span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">stackIn</span>.<span class="property">length</span>&amp;&amp;!<span class="variable language_">this</span>.<span class="property">stackOut</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyQueue()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>用两个数组模拟栈，要实现队列的先进先出的功能，首先有一个进栈，然后当要出栈的时候，就把进栈末尾（先进来的元素）弹出并且压到出栈中，这是一个持续的过程</li></ul></li></ul><h1 id="Day-18-Leetcode-225-用队列实现栈"><a href="#Day-18-Leetcode-225-用队列实现栈" class="headerlink" title="Day 18 Leetcode 225 用队列实现栈"></a>Day 18 Leetcode 225 用队列实现栈</h1><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x=<span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>解法一：数组应用(最好不用)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (size-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="variable language_">this</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.empty()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><p>解法二：用一个队列模拟</p><ul><li>这道题比较简单，用一个队列实现的要点在于出栈的时候要先将队列的首元素弹出然后再放进队列末尾，这样就能模拟出栈的出栈顺序了</li></ul></li></ul><h1 id="Day-18-Leetcode-20-有效的括号"><a href="#Day-18-Leetcode-20-有效的括号" class="headerlink" title="Day 18 Leetcode 20 有效的括号"></a>Day 18 Leetcode 20 有效的括号</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = s[i]</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.<span class="title function_">push</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(x!==stack.<span class="title function_">pop</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>这道题是栈的应用，js里用数组来模拟一个栈。</li><li>括号不匹配有三种情况</li><li>第一种：左括号多余</li><li>第二种：右括号多余</li><li>第三种：括号类型不匹配</li><li>从头遍历整个字符串，遇到左括号就把对应的有括号压入栈中，遇到右括号就开始和栈顶元素比较，如果相同就出栈。第一种情况在遍历完之后栈中还有元素，第二种情况是栈中美原油可匹配的元素，第三种情况是在遍历完之前栈就空了。</li><li>因此遍历完之后返回的栈如果是空的说明括号都匹配了，反之则不匹配</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">const</span> map=&#123;</span><br><span class="line">        <span class="string">&quot;&#123;&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;(&quot;</span>:<span class="string">&quot;)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;[&quot;</span>:<span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x <span class="keyword">in</span> map)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(x)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map[stack.<span class="title function_">pop</span>()]!==x)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：（简化版）</p><ul><li>和解法一思路一样，有一点不同的是这里压入栈的是左括号本身，用到了map的数据结构来做映射。这样的话在遍历字符串的时候就简化了一些操作。</li></ul></li></ul><h1 id="Day-18-Leetcode-1047-删除字符串中的所有相邻重复项"><a href="#Day-18-Leetcode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="Day 18 Leetcode  1047 删除字符串中的所有相邻重复项"></a>Day 18 Leetcode  1047 删除字符串中的所有相邻重复项</h1><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=<span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="property">length</span>!==<span class="number">0</span>&amp;&amp;x===(temp=stack.<span class="title function_">pop</span>()))&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;        </span><br><span class="line">      <span class="keyword">if</span>(temp)stack.<span class="title function_">push</span>(temp)</span><br><span class="line">        <span class="comment">// if(stack.length!==0&amp;&amp;x===stack[stack.length-1])&#123;</span></span><br><span class="line">        <span class="comment">//     stack.pop()</span></span><br><span class="line">        <span class="comment">//     continue</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        stack.<span class="title function_">push</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：用栈来解决</p><ul><li>这道题用栈来解决很方便。</li><li>遍历字符串的时候先做一个判断，如果栈顶元素和当前元素相同，说明可以消掉，那么就出栈。否者就把当前元素压入栈。</li><li>因为是用数组模拟的栈，所以既可以用temp保存弹出的元素，也可以直接用数组访问元素来判断.</li><li>最后直接将栈中元素连接成字符串即可。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> str=<span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="keyword">let</span> top=-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(top===-<span class="number">1</span>||str[top]!==s[i])&#123;</span><br><span class="line">            str[++top]=s[i]<span class="comment">//进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            top--<span class="comment">//出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.<span class="property">length</span>=top+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：双指针法</p><ul><li>这道题还是用的数组的数据结构，不过用top来记录栈顶，这样直接操作一个数组，限定长度即可</li></ul></li></ul><h1 id="Day-19-Leetcode-150-逆波兰表达式求值"><a href="#Day-19-Leetcode-150-逆波兰表达式求值" class="headerlink" title="Day 19 Leetcode 150 逆波兰表达式求值"></a>Day 19 Leetcode 150 逆波兰表达式求值</h1><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span> (<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tokens.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="comment">// for (const x of tokens) &#123;</span></span><br><span class="line">    <span class="comment">//     if (isNaN(Number(x))) &#123;</span></span><br><span class="line">    <span class="comment">//         const num1 = stack.pop()</span></span><br><span class="line">    <span class="comment">//         const num2 = stack.pop()</span></span><br><span class="line">    <span class="comment">//         if (x === &#x27;+&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 + num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;-&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 - num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;*&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 * num1)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else if (x === &#x27;/&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//             stack.push(num2 / num1 | 0)</span></span><br><span class="line">    <span class="comment">//             continue</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//         stack.push(Number(x))</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] === <span class="string">&#x27;+&#x27;</span> || tokens[i] === <span class="string">&#x27;-&#x27;</span> || tokens[i] === <span class="string">&#x27;*&#x27;</span> || tokens[i] === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> num1 = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">const</span> num2 = stack.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;+&quot;</span>) stack.<span class="title function_">push</span>(num2 + num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;-&quot;</span>) stack.<span class="title function_">push</span>(num2 - num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;*&quot;</span>) stack.<span class="title function_">push</span>(num2 * num1)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i] === <span class="string">&quot;/&quot;</span>) stack.<span class="title function_">push</span>(num2 / num1 | <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(tokens[i]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题用栈解决</li><li>遍历整个字符串，遇到数字就放到栈里，遇到运算符的话就弹出栈里两个元素然后做完运算后再放回去</li><li>需要注意的是这里的除法运算<strong>向零截断</strong> ，也就是要用到“|”这个为运算符</li></ul></li></ul><h1 id="Day-20-Leecode-239-滑动窗口最大值"><a href="#Day-20-Leecode-239-滑动窗口最大值" class="headerlink" title="Day 20 Leecode 239 滑动窗口最大值"></a>Day 20 Leecode 239 滑动窗口最大值</h1><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; value &gt; back &amp;&amp; back !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>()</span><br><span class="line">                back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">pop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> !== <span class="number">0</span> &amp;&amp; value === <span class="variable language_">this</span>.<span class="title function_">front</span>()) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> myQueue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>()</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        myQueue.<span class="title function_">push</span>(nums[j++])</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(myQueue.<span class="title function_">front</span>())</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        myQueue.<span class="title function_">push</span>(nums[j])</span><br><span class="line">        myQueue.<span class="title function_">pop</span>(nums[i])</span><br><span class="line">        res.<span class="title function_">push</span>(myQueue.<span class="title function_">front</span>())</span><br><span class="line">        i++</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>1</li></ul></li></ul><h1 id="Day-21-Leetcode-347-前k个高频元素"><a href="#Day-21-Leetcode-347-前k个高频元素" class="headerlink" title="Day 21 Leetcode 347 前k个高频元素"></a>Day 21 Leetcode 347 前k个高频元素</h1><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">compareFn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">compareFn</span> = compareFn</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value)</span><br><span class="line">        <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">size</span>() - <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> (parent &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(parent, index) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[parent]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[parent], <span class="variable language_">this</span>.<span class="property">queue</span>[index]]</span><br><span class="line">            index = parent</span><br><span class="line">            parent = <span class="title class_">Math</span>.<span class="title function_">floor</span>((index - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> out = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>] = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">let</span> searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="keyword">while</span> (searchChild !== <span class="literal">undefined</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(index, searchChild) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="variable language_">this</span>.<span class="property">queue</span>[index], <span class="variable language_">this</span>.<span class="property">queue</span>[searchChild]] = [<span class="variable language_">this</span>.<span class="property">queue</span>[searchChild], <span class="variable language_">this</span>.<span class="property">queue</span>[index]];</span><br><span class="line">            index = searchChild;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            searchChild = <span class="variable language_">this</span>.<span class="title function_">compare</span>(left, left + <span class="number">1</span>) &gt; <span class="number">0</span> ? left + <span class="number">1</span> : left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">compare</span>(<span class="params">index1, index2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index1] === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>[index2] === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">compareFn</span>(<span class="variable language_">this</span>.<span class="property">queue</span>[index1], <span class="variable language_">this</span>.<span class="property">queue</span>[index2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, (map.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> heap = <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">            heap.<span class="title function_">push</span>(entry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="title function_">size</span>() &gt; k) &#123;</span><br><span class="line">                heap.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = heap.<span class="title function_">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = heap.<span class="title function_">pop</span>()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法:</p><ul><li>这道题需要用到小顶堆和优先级队列两种数据结构</li><li>首先定义一个map来储存每个字符出现的频率</li><li>然后用一个heap来模拟小顶堆</li><li>小顶堆本质上是一种树，它有上浮和下沉的操作，因此在编写弹出和压入两个操作的时候要注意下标的变化。</li><li>小顶堆的根节点是频率最小的字符，因此每次压入之后判断小顶堆的大小并且弹出节点，最后剩下的就是需要求的数组</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2023/01/14/2023.01.13%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/01/14/2023.01.13%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-13-Leetcode-344-反转字符串"><a href="#Day-13-Leetcode-344-反转字符串" class="headerlink" title="Day 13 Leetcode 344 反转字符串"></a>Day 13 Leetcode 344 反转字符串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/reverse-string/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">character[]</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len=s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>,r=len-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">      <span class="comment">// 解法一</span></span><br><span class="line">        <span class="comment">// let t=s[l]</span></span><br><span class="line">        <span class="comment">// s[l]=s[r]</span></span><br><span class="line">        <span class="comment">// s[r]=t</span></span><br><span class="line">      <span class="comment">//解法二：解构赋值</span></span><br><span class="line">        [s[l],s[r]]=[s[r],s[l]]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//解法三:s.reverse()</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题很简单，直接用双指针法，一个从左边第一个出发，一个从右边第一个出发，两个交换位置之后再分别前进&#x2F;后退就可以了</li><li>交换的时候可以定义临时变量，也可以解构赋值</li></ul></li></ul><h1 id="Day-13-Leetcode-541-反转字符串②"><a href="#Day-13-Leetcode-541-反转字符串②" class="headerlink" title="Day 13 Leetcode 541 反转字符串②"></a>Day 13 Leetcode 541 反转字符串②</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span> (<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> resArr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span> * k) &#123;</span><br><span class="line">        <span class="keyword">let</span> l = i - <span class="number">1</span>, r = i + k &gt; len ? len : i + k;</span><br><span class="line">        <span class="keyword">while</span> (++l &lt; --r) &#123;</span><br><span class="line">            [resArr[l], resArr[r]] = [resArr[r], resArr[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法</p><ul><li>这道题主要就是边界条件的判断</li><li>注意：循环的时候i要加2k而不是加加，这样可以减少判断</li><li>之后反转操作的时候要判断一下i+k和s.length的大小来决定反转的右边是什么位置</li></ul></li></ul><h1 id="Day-14-Leetcode-151-翻转字符串里的单词"><a href="#Day-14-Leetcode-151-翻转字符串里的单词" class="headerlink" title="Day 14 Leetcode 151 翻转字符串里的单词"></a>Day 14 Leetcode 151 翻转字符串里的单词</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/\s+/g</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>直接调用api</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> strArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);</span><br><span class="line">   <span class="title function_">removeExtraSpaces</span>(strArr);</span><br><span class="line">   <span class="title function_">reverse</span>(strArr, <span class="number">0</span>, strArr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= strArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (strArr[i] === <span class="string">&#x27; &#x27;</span> || i === strArr.<span class="property">length</span>) &#123;</span><br><span class="line">       <span class="title function_">reverse</span>(strArr, start, i - <span class="number">1</span>);</span><br><span class="line">       start = i + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeExtraSpaces</span>(<span class="params">strArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> fastIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(fastIndex &lt; strArr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strArr[fastIndex] === <span class="string">&#x27; &#x27;</span> &amp;&amp; (fastIndex === <span class="number">0</span> || strArr[fastIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      fastIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      strArr[slowIndex++] = strArr[fastIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  strArr.<span class="property">length</span> = strArr[slowIndex - <span class="number">1</span>] === <span class="string">&#x27; &#x27;</span> ? slowIndex - <span class="number">1</span> : slowIndex;</span><br><span class="line">  <span class="comment">//通过改变数组长度来移除末尾的空格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">strArr, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = end;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];</span><br><span class="line">    left++</span><br><span class="line">    right--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li><p>这道题需要完成的功能：</p><ul><li>删除多余的空格</li><li>反转字符串</li><li>反转单词</li></ul></li><li><p>反转在前面已经实现过，这里可以额外用两个变量来定义开始和结尾，这样可以也可以实现字符串里面的单词反转</p></li><li><p>第二步是删除多余的空格，删除多余的空格用的方法是双指针法，参考前面数组题目的删除元素。</p></li><li><p>然后先将题目给的字符串变成一个数组，之后删除多余的空格，然后反转整个数组</p></li><li><p>之后用循环，当遇到空格的时候，说明一个单词便利完了，可以进行反转，最后更新一下start</p></li><li><p>最后调用js中的join方法把数组变成一个字符串就可以了</p></li></ul></li></ul><h1 id="Day-15-Leetcode-剑指offer-58-左旋转字符串"><a href="#Day-15-Leetcode-剑指offer-58-左旋转字符串" class="headerlink" title="Day 15 Leetcode 剑指offer 58 左旋转字符串"></a>Day 15 Leetcode 剑指offer 58 左旋转字符串</h1><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span> (<span class="params">start, end, s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left=start,right=end</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        [s[left],s[right]]=[s[right],s[left]]</span><br><span class="line">        left++</span><br><span class="line">        right--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="keyword">function</span> (<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="number">0</span>,n-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="title function_">reverse</span>(n,s.<span class="property">length</span>-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="number">0</span>,s.<span class="property">length</span>-<span class="number">1</span>,strArr)</span><br><span class="line">    <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>这道题比较简单，整体的思路就是反转三次字符串</li><li>第一次反转从开头到n-1位置的字符串</li><li>第二次反转从n到结尾的字符串</li><li>第三次反转整个字符串</li><li>这样就实现了将开头n个放到结尾的操作</li></ul></li></ul><h1 id="Day-16-KMP算法（理论）"><a href="#Day-16-KMP算法（理论）" class="headerlink" title="Day 16 KMP算法（理论）"></a>Day 16 KMP算法（理论）</h1><ul><li><p>解决问题：字符串匹配问题</p></li><li><p>以aabaabaaf和aabaaf举例</p></li><li><p>前缀：包含首字母，不包含尾字母的字符串（模式串中）</p></li><li><p>后缀：只包含尾字母，不包含首字母的字符串（模式串中）</p></li><li><p>前缀表：记录最长相等前后缀，比如a-&gt;0,aa-&gt;1,aab-&gt;0，aaba-&gt;0,aabaa-&gt;2,aabaaf-&gt;0,那么前缀表就是010020</p></li><li><p>找到最长下相等前后缀的位置，最长相等前后缀的长度也就是下标，比如aabaaf-&gt;下标为2也就是b所在的位置，从b所在的位置重新匹配</p></li><li><p>next数组 ：存放前缀表，<strong>告诉发生冲突的时候回退到哪里</strong></p><ul><li>如果右移前缀表作为next数组，那么回退的下标就是冲突的位置对应的前缀表中下标</li><li>如果直接拿前缀表作为next数组，那么回退的下标是冲突的位置前一位对应的前缀表中下标</li><li>如果统一减一后作为next数组，那么回退的下标是冲突的位置前一位对应的前缀表中下标+1…</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNext</span>(<span class="params">next,s</span>)&#123;</span><br><span class="line">  <span class="comment">//初始化next数组和遍历</span></span><br><span class="line">  <span class="keyword">let</span> j=<span class="number">0</span><span class="comment">//i指向后缀末尾位置，j指向前缀末尾位置以及i之前字串的最长相等前后缀的长度</span></span><br><span class="line">  next[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;s.<span class="property">length</span>;i++)&#123;<span class="comment">//因为在aa的时候才有前后缀，此时i为1，j为0</span></span><br><span class="line">      <span class="comment">//处理前后缀不相同的情况</span></span><br><span class="line">    <span class="keyword">while</span>(s[i]!==s[j]&amp;&amp;j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      j=next[j-<span class="number">1</span>]</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//处理前后缀相同的地方</span></span><br><span class="line">    <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">      j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新next数组的值</span></span><br><span class="line">    next[i]=j</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Day-17-Leecode-459-重复的子字符串"><a href="#Day-17-Leecode-459-重复的子字符串" class="headerlink" title="Day 17 Leecode 459 重复的子字符串"></a>Day 17 Leecode 459 重复的子字符串</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext= <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> next=[]</span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span></span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!==s[j])&#123;</span><br><span class="line">            j=next[j-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]===s[j])&#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        next[i]=j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> next=<span class="title function_">getNext</span>(s)</span><br><span class="line">    <span class="keyword">if</span>(next[next.<span class="property">length</span>-<span class="number">1</span>]!==<span class="number">0</span>&amp;&amp;s.<span class="property">length</span>%(s.<span class="property">length</span>-next[next.<span class="property">length</span>-<span class="number">1</span>])===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：KMP（时间复杂度O(m+n ))</p><ul><li>KMP解法中，找到最长相等前后缀，不相等的那一部分就是重复的最小子串（此处需要数学推导一下）</li><li>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；</li><li>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</li><li>如果数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>===<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// let next=getNext(s)</span></span><br><span class="line">    <span class="comment">// if(next[next.length-1]!==0&amp;&amp;s.length%(s.length-next[next.length-1])===0)return true</span></span><br><span class="line">    <span class="comment">// return false</span></span><br><span class="line">    ssArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(s+s)</span><br><span class="line">    ssArr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    ssArr.<span class="title function_">splice</span>(ssArr.<span class="property">length</span>-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> ss=ssArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(ss.<span class="title function_">indexOf</span>(s)!==-<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：移动匹配(时间复杂度O(m*n))</p><ul><li>如果一个字符串是由重复子串构成，那么两个它拼接起来中间一定会有它本身这个字符串，因此可以调用库函数</li><li>注意：js里面要将字符串转化为数组，然后将第一个和最后一个字符删除（因为本身就有两个字符串本身，一定能找到本身）</li></ul></li></ul><h1 id="Day-17-Leetcode-28-找出字符串中第一个匹配项的下标"><a href="#Day-17-Leetcode-28-找出字符串中第一个匹配项的下标" class="headerlink" title="Day 17 Leetcode 28 找出字符串中第一个匹配项的下标"></a>Day 17 Leetcode 28 找出字符串中第一个匹配项的下标</h1><h2 id="找出字符串中第一个匹配项的下标"><a href="#找出字符串中第一个匹配项的下标" class="headerlink" title="找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getNext = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = []</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] !== s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === s[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span> (<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="title function_">getNext</span>(needle)</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] !== needle[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] === needle[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j === needle.<span class="property">length</span>)</span><br><span class="line">            <span class="keyword">return</span> (i-needle.<span class="property">length</span>+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>首先，求模式串的next数组（这串代码可以背下来)</li><li>然后从0开始遍历长的字符串，依然是分两种情况</li><li>第一种情况：s[i]和t[j]不相同的情况，这个时候j要做回退</li><li>第二种情况：s[i]和t[j]相同的情况，这个时候i、j都向前走一个</li><li>当j走到了模式串的末尾的时候，那么说明字符串中有模式串，这个时候返回i（原字符串走到的位置)-模式串长度+1</li></ul></li></ul><h1 id="Leetcode-125-验证回文串"><a href="#Leetcode-125-验证回文串" class="headerlink" title="Leetcode 125 验证回文串"></a>Leetcode 125 验证回文串</h1><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (arr[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)||(arr[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;arr[i]&lt;=<span class="number">9</span>)) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> str = res.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> reverArr = res.<span class="title function_">reverse</span>()</span><br><span class="line">    <span class="keyword">let</span> str1 = reverArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> res1=str.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">let</span> res2=str1.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">if</span> (res1 === res2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题比较简单，把字符串中多余的符号删除掉之后，转换成数组然后反转，用反转前的数组连接成的字符串和反转后的数组连接成的字符串比较</li></ul></li></ul><h1 id="Leetcode-3-无重复字符的最长子串"><a href="#Leetcode-3-无重复字符的最长子串" class="headerlink" title="Leetcode 3 无重复字符的最长子串"></a>Leetcode 3 无重复字符的最长子串</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="title function_">includes</span>(x)) &#123;</span><br><span class="line">            queue.<span class="title function_">shift</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        queue.<span class="title function_">push</span>(x)</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, queue.<span class="property">length</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// let queue = []</span></span><br><span class="line">    <span class="comment">// let max = 0</span></span><br><span class="line">    <span class="comment">// for (const x of s) &#123;</span></span><br><span class="line">    <span class="comment">//     while (queue.includes(x)) &#123;</span></span><br><span class="line">    <span class="comment">//         queue.shift()</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     queue.push(x)</span></span><br><span class="line">    <span class="comment">//     max = Math.max(max, queue.length)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>, left = <span class="number">0</span>, right = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">            res.<span class="title function_">delete</span>(res.<span class="title function_">values</span>().<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">add</span>(s[right])</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, res.<span class="property">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：（滑动窗口）</p><ul><li>这道题用滑动窗口来解决，用set这个数据结构</li><li>注意：无重复字符的字串必须是<strong>连续的,否则就不是子串而是子序列</strong></li><li>如果 set中含有当前字符，就删除第一个字符,同时缩小窗口left++</li><li>如果没有含有，就添加当前值到 set上，同时把right++</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/01/14/2023.01.13%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/01/14/2023.01.13%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-9-Leetcode-242-有效的字母异位词"><a href="#Day-9-Leetcode-242-有效的字母异位词" class="headerlink" title="Day 9 Leetcode 242 有效的字母异位词"></a>Day 9 Leetcode 242 有效的字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/valid-anagram/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span> (<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> !== t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> record = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> a=<span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        record[s[i].<span class="title function_">charCodeAt</span>() - a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        record[t[i].<span class="title function_">charCodeAt</span>() - a]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[i] !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>本题用哈希法进行解题，思路就是用一个数组来记录每个字母重复的次数</li><li>先遍历第一个字符串，遇到字符就在record数组中对应的位置加一记录下</li><li>之后遍历第二个，遇到字符后再record数组中对应的位置减一来记录</li><li>最后遍历record，如果出现不为0的位置证明两个字符串所含字母不一定相同</li><li>注意：js里获取字符串的ascii码必须要用charCodeAt（）方法</li></ul></li></ul><h1 id="Day-10-Leetcode-349-两个数组的交集"><a href="#Day-10-Leetcode-349-两个数组的交集" class="headerlink" title="Day 10 Leetcode 349 两个数组的交集"></a>Day 10 Leetcode 349 两个数组的交集</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/submissions/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums1.<span class="property">length</span>&lt;nums2.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> t=nums1</span><br><span class="line">        nums1=nums2</span><br><span class="line">        nums2=t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hash=<span class="keyword">new</span> <span class="title class_">Set</span>(nums1)</span><br><span class="line">    <span class="keyword">const</span> res=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums2.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(nums2[i]))&#123;</span><br><span class="line">            res.<span class="title function_">add</span>(nums2[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(res)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题主要要注意返回的是一个不含重复数字的数组，因此可以使用set来保证没有重复，最后转换成数组就可以了</li><li>先找到比较大的那个数组，然后让这个数组转成hash表（set结构）这样的话只需要用另一个数组中的元素来和这个hash表来判断有没有重复就可以了，有重复就加到res这个表中</li><li>注意：只有当数值比较小的时候才能用数组做哈希表</li></ul></li></ul><h1 id="Day-10-Leetcode-202-快乐数"><a href="#Day-10-Leetcode-202-快乐数" class="headerlink" title="Day 10 Leetcode  202 快乐数"></a>Day 10 Leetcode  202 快乐数</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/happy-number/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        sum += (num % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> ()</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="title function_">has</span>(n))<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(n===<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        m.<span class="title function_">set</span>(n,<span class="number">1</span>)</span><br><span class="line">        n=<span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：</p><ul><li>当出现了要快速判断一个元素是否在集合里的时候就要考虑哈希法</li><li>根据题意，首先要定义一个函数来算整个数每一位平方和</li><li>然后定义一个map，用has可以判断n是不是在里面，n已经在map中的话那么就是在无限循环。如果n不在里面的话，为map添加一个制定了key:n,value:1的键值对，最后再更新n</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        sum += (num % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> set=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="keyword">while</span>(n!==<span class="number">1</span>&amp;&amp;!set.<span class="title function_">has</span>(n))&#123;</span><br><span class="line">        set.<span class="title function_">add</span>(n)</span><br><span class="line">        n=<span class="title function_">getSum</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n===<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法二：</p><ul><li>用set可以保证不会有重复的元素</li><li>如果在循环中某个值重复出现，说明此时陷入死循环，也就说明这个值不是快乐数</li></ul></li></ul><h1 id="Day-11-Leetcode-454-四数相加"><a href="#Day-11-Leetcode-454-四数相加" class="headerlink" title="Day 11 Leetcode 454 四数相加"></a>Day 11 Leetcode 454 四数相加</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/4sum-ii/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>,sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> sumMap= <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n1 <span class="keyword">of</span> nums1)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> n2 <span class="keyword">of</span> nums2)&#123;</span><br><span class="line">            sum=n1+n2</span><br><span class="line">            <span class="keyword">let</span> num=sumMap.<span class="title function_">get</span>(sum)||<span class="number">0</span></span><br><span class="line">            sumMap.<span class="title function_">set</span>(sum,num+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n3 <span class="keyword">of</span> nums3)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> n4 <span class="keyword">of</span> nums4)&#123;</span><br><span class="line">            sum=n3+n4</span><br><span class="line">            count+=(sumMap.<span class="title function_">get</span>(<span class="number">0</span>-sum)||<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>用一个map来存储两个数组元素相加和的值和出现次数</li><li>首先遍历nums1、nums2，把所有元素相加，放入map里，统计出现的次数</li><li>然后遍历nums3、nums4，和为sum，在map中找到key为0-sum的元素，出现的次数value即为所要求值。</li><li>两个两个遍历是为了减少时间复杂度。</li></ul></li></ul><h1 id="Day-12-Leetcode-15-三数之和"><a href="#Day-12-Leetcode-15-三数之和" class="headerlink" title="Day 12 Leetcode 15 三数之和"></a>Day 12 Leetcode 15 三数之和</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/3sum/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a - b &#125;)</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>, res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125;</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法</p><ul><li>这道题不太适合用哈希法来做，因为需要去重</li><li>首先将数组排序，然后开始遍历数组</li><li>注意点一：如果nums[i]已经大于0的话，说明后面不会有合适的元素了，因此直接返回res</li><li>去重一：如果nums[i]&#x3D;&#x3D;&#x3D;nums[i-1]就代表之前出现过这个元素，因此不管这个组合直接continue</li><li>注意点二：这里不用nums[i+1]的原因是因为会影响到left的取值</li><li>之后开始算三数之和，如果三数之和大于0说明数字大了，那么移动right–，如果小于0说明数字笑了，那么移动left++。如果刚好等于0，说明是符合条件的三元组，那么就将三个数放到数组里</li><li>去重二：如果nums[left&#x2F;right]&#x3D;&#x3D;&#x3D;nums[left+1&#x2F;right+1]那么说明left&#x2F;right要重复了，就移动对应的指针</li><li>正常情况还要移动一下指针</li></ul></li></ul><h1 id="Day-12-Leetcode-18-四数之和"><a href="#Day-12-Leetcode-18-四数之和" class="headerlink" title="Day 12 Leetcode 18 四数之和"></a>Day 12 Leetcode 18 四数之和</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/4sum/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span> (<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">4</span>) <span class="keyword">return</span> []</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; target &gt; <span class="number">0</span>) <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] + nums[i] &gt; target &amp;&amp; nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l = j + <span class="number">1</span>, r = len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123; l++ &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123; r-- &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题和三数之和的方法类似，但要注意去重的地方有些不同</li><li>在第一个循环的时候要进行第一次剪枝</li><li>第一次剪枝要判断nums[i]是不是大于0，因为负数相加可以变小</li><li>第二次循环的时候要进行第二次剪枝</li><li>第二次剪枝吧nums[i]和nums[j]当做一个整体来判断</li><li>注意：这里和三数之和不同的地方在于：target可以是负数，这样的话进行驱虫的时候</li></ul></li></ul><h1 id="Day-12-Leetcode-383-赎金信"><a href="#Day-12-Leetcode-383-赎金信" class="headerlink" title="Day 12 Leetcode 383 赎金信"></a>Day 12 Leetcode 383 赎金信</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/ransom-note/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">ransomNote</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">magazine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canConstruct = <span class="keyword">function</span> (<span class="params">ransomNote, magazine</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hashArr=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> a=<span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> magazine)&#123;</span><br><span class="line">        hashArr[i.<span class="title function_">charCodeAt</span>()-a]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> ransomNote)&#123;</span><br><span class="line">        <span class="keyword">const</span> index=i.<span class="title function_">charCodeAt</span>()-a</span><br><span class="line">        <span class="keyword">if</span>(!hashArr[index])<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        hashArr[index]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题直接用哈希法</li><li>用一个数组存储26个字母</li><li>然后遍历magazine字符串，把出现的数字次数记下来</li><li>然后遍历ransomNote字符串，记录对应的字母的ascii值，然后看hashArr里有没有，没有的话说明ransomNote有magazine里面没有的字母，直接返回false；有的话把数组的对应位置减一</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/01/14/2023.01.13%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/01/14/2023.01.13%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-5-Leetcode-203-移除链表元素"><a href="#Day-5-Leetcode-203-移除链表元素" class="headerlink" title="Day 5 Leetcode 203 移除链表元素"></a>Day 5 Leetcode 203 移除链表元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">  <span class="comment">//分情况删除法</span></span><br><span class="line">  <span class="comment">// let cur=head</span></span><br><span class="line">  <span class="comment">// while(head!==null&amp;&amp;head.val===val)&#123;</span></span><br><span class="line">  <span class="comment">//     head=head.next</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// while(cur!==null&amp;&amp;cur.next!==null)&#123;</span></span><br><span class="line">  <span class="comment">//     if(cur.next.val===val)&#123;</span></span><br><span class="line">  <span class="comment">//         cur.next=cur.next.next</span></span><br><span class="line">  <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">  <span class="comment">//         cur=cur.next</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//虚拟头结点法</span></span><br><span class="line">  <span class="keyword">const</span> virnode=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="literal">null</span>,head)</span><br><span class="line">  <span class="keyword">let</span> cur=virnode<span class="comment">//记录头结点的位置</span></span><br><span class="line">  <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span>===val)&#123;</span><br><span class="line">      cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur=cur.<span class="property">next</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> virnode.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：分情况讨论</p><ul><li>分情况讨论主要分的是头结点和普通结点，这里的头结点是一个真正的结点，有自己的next指针和val</li></ul></li><li><p>解法二：虚拟头结点法</p><ul><li>这种解法省去了分情况讨论，将两种情况合在一起。</li><li>首先定义一个虚拟头结点指向原本的head结点（这里可能和我平时理解的头结点一样）</li><li>之后所有的操作和解法一的删除普通结点方法一样</li><li>需要注意的是最后返回的应该是虚拟头结点的下一个位置。</li></ul></li></ul><h1 id="Day-6-Leetcode-707-设计链表"><a href="#Day-6-Leetcode-707-设计链表" class="headerlink" title="Day 6 Leetcode 707 设计链表"></a>Day 6 Leetcode 707 设计链表</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/design-linked-list/submissions/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">var MyLinkedList = function() &#123;</span></span><br><span class="line"><span class="comment">    this._size = 0;</span></span><br><span class="line"><span class="comment">    this._tail = null;</span></span><br><span class="line"><span class="comment">    this._head = null;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the value of the index-th node in the linked list. If the index is invalid, return -1. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getNode</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">_head</span>);</span><br><span class="line">    <span class="comment">// 0 -&gt; head</span></span><br><span class="line">    <span class="keyword">while</span>(index-- &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index).<span class="property">val</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtHead</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, <span class="variable language_">this</span>.<span class="property">_head</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Append a node of value val to the last element of the linked list. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtTail</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, <span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span>.<span class="property">next</span> = node;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtIndex</span> = <span class="keyword">function</span>(<span class="params">index, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index - <span class="number">1</span>);</span><br><span class="line">    node.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val, node.<span class="property">next</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delete the index-th node in the linked list, if the index is valid. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteAtIndex</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">_size</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_head</span> = <span class="variable language_">this</span>.<span class="property">_head</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span> - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_tail</span> = <span class="variable language_">this</span>.<span class="property">_head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="title function_">getNode</span>(index - <span class="number">1</span>);    </span><br><span class="line">    node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === <span class="variable language_">this</span>.<span class="property">_size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyLinkedList()</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(index)</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val)</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val)</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val)</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>虚拟头结点的运用</li><li>主要就是边界条件的判断</li><li>注意：在第n个节点前插入节点要注意：current要指向虚拟头节点</li></ul><h1 id="Day-6-Leetcode-206-反转链表"><a href="#Day-6-Leetcode-206-反转链表" class="headerlink" title="Day 6 Leetcode 206 反转链表"></a>Day 6 Leetcode 206 反转链表</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">var</span> reverse=<span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!cur) <span class="keyword">return</span> pre</span><br><span class="line">     <span class="keyword">const</span> temp=cur.<span class="property">next</span></span><br><span class="line">     cur.<span class="property">next</span>=pre</span><br><span class="line">     <span class="keyword">return</span> <span class="title function_">reverse</span>(cur,temp)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">//双指针法</span></span><br><span class="line">    <span class="comment">// if(!head||!head.next) return head</span></span><br><span class="line">    <span class="comment">// let cur=head,pre=null,temp=null</span></span><br><span class="line">    <span class="comment">// while(cur)&#123;</span></span><br><span class="line">    <span class="comment">//     temp=cur.next</span></span><br><span class="line">    <span class="comment">//     cur.next=pre</span></span><br><span class="line">    <span class="comment">//     pre=cur</span></span><br><span class="line">    <span class="comment">//     cur=temp</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return pre</span></span><br><span class="line">    <span class="comment">//递归法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(<span class="literal">null</span>,head)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法：</p><ul><li>双指针法要定义两个指针，一个是pre一个是cur，cur指向的是第一个节点，pre的初始指向是null。</li><li>然后先要保存下来cur.next，因为接下来要将cur.next的指向翻转</li><li>反转后先移动pre到cur的位置再把cur移到之前的cur.next的位置，这样就完成了一个结点的反转</li><li>当cur为null的时候，也就是pre移动到了最后一个结点处，这个时候返回pre就可以了</li></ul></li><li><p>解法二：递归法：</p><ul><li>递归法和双指针法差不多，都需要定义两个指针来反转，但是递归法需要另外一个函数，并且在函数结束的时候返回这个函数，但是参数变为反转后的pre和cur</li></ul></li></ul><h1 id="Day-7-Leetcode-24-两两交换链表中的节点"><a href="#Day-7-Leetcode-24-两两交换链表中的节点" class="headerlink" title="Day 7 Leetcode 24 两两交换链表中的节点"></a>Day 7 Leetcode 24 两两交换链表中的节点</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> cur=vhead</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>&amp;&amp;cur.<span class="property">next</span>.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=cur.<span class="property">next</span></span><br><span class="line">        <span class="keyword">let</span> temp1=cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span>=temp</span><br><span class="line">        cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">next</span>=temp1</span><br><span class="line">        cur=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vhead.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>本题依然要使用虚拟头结点，这样可以省去对头结点的单独判断</li><li>首先要让cur指向虚拟头结点</li><li>这道题要注意的一点是判断循环结束的条件，也就是要清楚想要反转两个结点，必须把cur指向两个结点之前的那个结点，因此循环结束条件就是cur.next不为null并且cur.next.next不为空，这样可以保证cur之后有两个结点来反转。注意：必须要把cur.next不为空写在前面，因为&amp;&amp;有“短路”，如果cur.next.next先为空的话就少判断一个结点了</li><li>之后用temp，temp1分别保存下第一个结点和第三个结点</li><li>cur.next&#x3D;cur.next.next</li><li>cur.next.next&#x3D;temp</li><li>cur.next.next.next&#x3D;temp1完成反转</li><li>最后不要忘记把cur往后移动两位</li></ul></li></ul><h1 id="Day-7-Leetcode-19-删除链表倒数第N个结点"><a href="#Day-7-Leetcode-19-删除链表倒数第N个结点" class="headerlink" title="Day 7 Leetcode 19 删除链表倒数第N个结点"></a>Day 7 Leetcode 19 删除链表倒数第N个结点</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> fast=vhead</span><br><span class="line">    <span class="keyword">let</span> slow=vhead</span><br><span class="line">    n++</span><br><span class="line">    <span class="keyword">while</span>(n--&amp;&amp;fast!==<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast!==<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span></span><br><span class="line">        slow=slow.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow.<span class="property">next</span>=slow.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    <span class="keyword">return</span> vhead.<span class="property">next</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> vhead=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head)</span><br><span class="line">    <span class="keyword">let</span> x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> cur=vhead</span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span>!==<span class="literal">null</span>)&#123;</span><br><span class="line">        cur=cur.<span class="property">next</span></span><br><span class="line">        x++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x===n)&#123;</span><br><span class="line">        head=head.<span class="property">next</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cur=head</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;x-n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cur=cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法一：双指针法</p><ul><li>本题使用了虚拟头结点和双指针法</li><li>删除操作很容易，就是让需要删除的元素target前一个元素slow的next不指向target而是指向target.next。本题主要的问题就是在寻找target前一个元素</li><li>双指针法定义了一个slow，一个fast指针，先让fast前进n+1步然后slow和fast一起走，这样当fast走完链表到null的时候，slow刚好指向target的前一个元素</li><li>这里要注意让fast前进n+1步，可以先让n++，再进行循环，也可以在fast走完n步之后再走一步,即fast&#x3D;fast.next</li></ul></li><li><p>解法二：判断结点数法</p><ul><li>这种解法的思路就是，通过找出要删除的那个数处于正数的第几位来删除</li><li>首先要知道整个链表的长度，需要用一个循环来找出。</li><li>注意：当n与链表长度相等时，说明要删除的是头结点，只需要让头结点等于下一个结点就可以</li><li>找到链表长度后，从头开始遍历，找到第length-n-1个元素，也就是要删除的元素前一个元素，接着进行删除就可以了</li></ul></li></ul><h1 id="Day-7-Leetcode-142-环形链表"><a href="#Day-7-Leetcode-142-环形链表" class="headerlink" title="Day 7 Leetcode 142 环形链表"></a>Day 7 Leetcode 142 环形链表</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head.<span class="property">next</span>)<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> slow = head,fast=head</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        slow = slow.<span class="property">next</span></span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            <span class="keyword">let</span> index1 = fast</span><br><span class="line">            <span class="keyword">let</span> index2 = head</span><br><span class="line">            <span class="keyword">while</span> (index1 !== index2) &#123;</span><br><span class="line">                index1 = index1.<span class="property">next</span></span><br><span class="line">                index2 = index2.<span class="property">next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>这道题有两个难点，一个难点是判断有没有环，另一个难点是找到环的入口</li><li>第一个难点的解决办法是用两个指针，一个slow一次移动一格，一个fast一次移动两格，如果他们能相遇，那么一定存在环，反之则不存在环。因为fast指针相对于slow指针速度为1，相当于slow静止，二fast以速度为1追赶slow。</li><li>第二个难点的解决办法涉及到数学公式，设头结点到环入口有x个结点，环入口到fast和slow相遇处有y个结点，环中剩余结点数为z。</li><li>相遇时，fast走过：x+y+n(y+z),slow走过:x+y,因为fast指针速度是slow的两倍，因此fast走过的结点数也是slow的两倍-&gt;2*(x+y)&#x3D;x+y+n(y+z);由此可得  x &#x3D; (n - 1) (y + z) + z</li><li>这样也就是从头结点和相遇处各有一个指针出发，他们一定会在入口处相遇。</li></ul></li></ul><h1 id="Day-8-剑指offer-35-复杂链表的复制"><a href="#Day-8-剑指offer-35-复杂链表的复制" class="headerlink" title="Day 8 剑指offer 35 复杂链表的复制"></a>Day 8 剑指offer 35 复杂链表的复制</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">题目</a></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, next, random) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node.<span class="property">next</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(node.<span class="property">val</span>, node.<span class="property">next</span>)</span><br><span class="line">        node = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        node.<span class="property">next</span>.<span class="property">random</span> = node.<span class="property">random</span> ? node.<span class="property">random</span>.<span class="property">next</span>: <span class="literal">null</span></span><br><span class="line">        node = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newNode = head.<span class="property">next</span>, res = newNode</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">next</span> &amp;&amp; newNode.<span class="property">next</span>) &#123;</span><br><span class="line">        node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        newNode.<span class="property">next</span> = newNode.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        node = node.<span class="property">next</span>;</span><br><span class="line">        newNode = newNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解法：</li></ul><ol><li>首先遍历原链表，在每个节点后面复制一个新节点。这样原链表和新链表就形成了一个“拼接”的形式，如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原链表：    A -&gt; B -&gt; C -&gt; D </span><br><span class="line">新链表： A&#x27;-&gt; A -&gt; B&#x27;-&gt; B -&gt; C&#x27;-&gt; C -&gt; D&#x27;-&gt; D</span><br></pre></td></tr></table></figure><ol><li>然后再次遍历原链表，根据原链表中每个节点的 random 指针，为新链表中对应的节点建立 random 指针。由于原链表和新链表是“拼接”在一起的，因此可以通过每个节点的 next 指针来访问新链表中的节点。</li><li>最后再次遍历原链表，将原链表和新链表从中间“拆分”开来，即将原链表中的每个节点的 next 指针指向原链表的下一个节点，将新链表中的每个节点的 next 指针指向新链表的下一个节点。最终得到的就是两个独立的链表：原链表和新链表。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/12/19/2023.01.13%E6%95%B0%E7%BB%84/"/>
      <url>/2022/12/19/2023.01.13%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-Leetcode-704二分查找"><a href="#Day1-Leetcode-704二分查找" class="headerlink" title="Day1 Leetcode 704二分查找"></a>Day1 Leetcode 704二分查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/binary-search/">题目</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var search = function (nums, target) &#123;</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = nums.length - 1</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    let middle = left + Math.floor((right - left) / 2)</span><br><span class="line">    if (nums[middle] &gt; target) &#123;</span><br><span class="line">      right = middle - 1</span><br><span class="line">    &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">      left = middle + 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return middle</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>二分查找法是很简单的一类题目，但是经常容易写错。主要在于区间的取值以及对左右的更新</li><li>首先对于left和right的取值，需要根据区间来判断，如果左闭右闭left就取0，right取数组大小减1，如果左闭右开right得取数组的大小。</li><li>第二个点是while循环里面的条件，如果是左闭右闭的话left&lt;&#x3D;right,如果是左闭右开的话那么left&lt;right</li><li>第三个点是left、right的更新，如果左闭右闭那么更新的时候right、left就不能是middle而要是middle-1、middle+1，因为middle那个点已经不算在搜索区间里了。如果左闭右开的话right就可以是middle，因为本身middle就取不到</li></ul><h1 id="Day-1-Leetcode-27-删除元素"><a href="#Day-1-Leetcode-27-删除元素" class="headerlink" title="Day 1 Leetcode 27 删除元素"></a>Day 1 Leetcode 27 删除元素</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/remove-element/">题目</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//双指针法</span><br><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">let slow = 0</span><br><span class="line">for (let fast = 0; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">if (nums[fast] !== val) &#123;</span><br><span class="line">nums[slow++] = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">return slow</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//暴力求解</span><br><span class="line">var size = nums.length</span><br><span class="line">for (let i = 0; i &lt; size; i++) &#123;</span><br><span class="line">if (nums[i] === val) &#123;</span><br><span class="line">for (let j = i + 1; j &lt; size; j++) &#123;</span><br><span class="line">nums[j - 1] = nums[j]</span><br><span class="line">    &#125;</span><br><span class="line">i--</span><br><span class="line">size--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return size</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解：</p><ul><li>使用两个for循环，第一个for循环用来遍历数组，第二个for循环用来将需要删除的元素后面的所有元素都往前移动一位。</li><li>需要注意的是移动完之后数组的大小要减少（因为题目要求返回数组大小）</li></ul></li><li><p>双指针法：</p><ul><li>双指针法只需要用一个for循环，因此时间复杂度为O(N）</li><li>定义一个slow一个fast指针，slow指针用来指向新数组的下标，fast指针用来指向原数组中的元素<br>首先让fast指针往前走，当fast指针指向的不是要删除的元素的时候，slow所在位置的数据应当被fast指向的数据给覆盖掉，然后slow往前走。从而实现一个覆盖的功能</li></ul></li></ul><h1 id="Day-2-Leetcode-977-有序数组的平方"><a href="#Day-2-Leetcode-977-有序数组的平方" class="headerlink" title="Day 2 Leetcode 977 有序数组的平方"></a>Day 2 Leetcode 977 有序数组的平方</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">题目</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var sortedSquares = function (nums) &#123;</span><br><span class="line">  //暴力求解</span><br><span class="line">  let result = []</span><br><span class="line">  // for(let i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">  //     nums[i]*=nums[i]</span><br><span class="line">  // &#125;</span><br><span class="line">  // nums.sort((a,b)=&gt;&#123;return a-b&#125;)</span><br><span class="line">  // return nums</span><br><span class="line">  let left = 0</span><br><span class="line">  let right = nums.length - 1</span><br><span class="line">  let res = nums.length - 1</span><br><span class="line">  while (left &lt;= right) &#123;</span><br><span class="line">    if (nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;</span><br><span class="line">      result[res--] = nums[right] * nums[right]</span><br><span class="line">      right--</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      result[res--] = nums[left] * nums[left]</span><br><span class="line">      left++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>暴力求解:</p><ul><li>本题暴力求解方法很简单，将所有数组元素都平方后放入另一个数组里再进行一次排序就可以了，不过需要注意的是js里的排序方法要指定一下升序还是降序。时间复杂度为O（n+logn）</li></ul></li><li><p>双指针法:</p><ul><li>这种方法要重新定义一种数组，然后用left和right分别指向原数组的开头和结尾。当left&lt;&#x3D;right的时候，开始比较nums[left]平方和nums[right]平方的大小，并把大的放进新数组的最后。根据情况left++或者right–。时间复杂度为O(n)</li></ul></li></ul><h1 id="Day-3-Leetcode-209-长度最小的子数组"><a href="#Day-3-Leetcode-209-长度最小的子数组" class="headerlink" title="Day 3 Leetcode 209 长度最小的子数组"></a>Day 3 Leetcode 209 长度最小的子数组</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">题目</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var minSubArrayLen = function (target, nums) &#123;</span><br><span class="line">    //双指针法</span><br><span class="line">    let i=0</span><br><span class="line">    let sum=0</span><br><span class="line">    let result=Infinity</span><br><span class="line">    let subL=0</span><br><span class="line">    for(let j=0;j&lt;nums.length;j++)&#123;</span><br><span class="line">        sum+=nums[j];</span><br><span class="line">        while(sum&gt;=target)&#123;</span><br><span class="line">            subL=j-i+1</span><br><span class="line">            result=Math.min(result,subL)</span><br><span class="line">            sum-=nums[i++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result===Infinity?0:result</span><br><span class="line">    //暴力求解</span><br><span class="line">    // let result = Infinity</span><br><span class="line">    // let sum = 0</span><br><span class="line">    // let subL = 0</span><br><span class="line">    // for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    //     sum = 0</span><br><span class="line">    //     for (let j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">    //         sum += nums[j]</span><br><span class="line">    //         while (sum &gt;= target) &#123;</span><br><span class="line">    //             subL = j - i + 1</span><br><span class="line">    //             result = Math.min(result, subL)</span><br><span class="line">    //             break</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // return result === Infinity ? 0 : result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>暴力求解：用两个for循环不断地寻找所有符合条件的子数组，时间复杂度是O(n²)</li><li>双指针法：<ul><li>用两个指针i和j分别指向起始位置和终止位置</li><li>首先先让j指针往后走，然后用sum记录数组元素之和，当sum符合条件的时候记录数组长度，并且和当前最小的数组长度开始比较，然后再让起始位置往后走，同时要在sum里减去去掉的元素。</li><li>这题的要点一个是for循环里写的是终止位置，另一个是起始位置什么时候走</li></ul></li></ul><h1 id="Day-4-Leetcode-59-螺旋矩阵"><a href="#Day-4-Leetcode-59-螺旋矩阵" class="headerlink" title="Day 4 Leetcode 59 螺旋矩阵"></a>Day 4 Leetcode 59 螺旋矩阵</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">题目</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var generateMatrix = function (n) &#123;</span><br><span class="line">    let startx = 0, starty = 0;</span><br><span class="line">    let count = 1, offset = 1;</span><br><span class="line">    let mid = Math.floor(n / 2)</span><br><span class="line">    let loop = mid</span><br><span class="line">    let res = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0));</span><br><span class="line">    while (loop) &#123;</span><br><span class="line">        let row = startx, col = starty</span><br><span class="line">        for (; col &lt; n - offset; col++) &#123;</span><br><span class="line">            res[startx][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (; row &lt; n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        for (; col &gt; starty; col--) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        for (; row &gt; startx; row--) &#123;</span><br><span class="line">            res[row][col] = count++</span><br><span class="line">        &#125;</span><br><span class="line">        startx++</span><br><span class="line">        starty++</span><br><span class="line">        offset++</span><br><span class="line">        loop--</span><br><span class="line">    &#125;</span><br><span class="line">    if (n % 2 == 1) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>解法：</p><ul><li>本题比较重要的思想是循环不变量思想，为了防止考虑过多边界条件，每次循环的时候采用左闭右开的区间。</li><li>奇偶的情况只差最中间一位，因此只要用一个if来判断奇数的情况就可以了</li><li>用四个for循环来表示每一条边，当转完一圈之后，总圈数loop要减一，第二圈起始点的横纵坐标startx&#x2F;starty都是前一圈加一，最边上一点离本条边结束点的距离offset要增加1.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 代码 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
